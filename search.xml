<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS中FormData对象</title>
      <link href="/2022/11/22/JS%E4%B8%ADFormData%E5%AF%B9%E8%B1%A1/"/>
      <url>/2022/11/22/JS%E4%B8%ADFormData%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>uni-app学习篇</title>
      <link href="/2022/09/02/uni-app%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
      <url>/2022/09/02/uni-app%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://uniapp.dcloud.net.cn/">uni-app</a> 是什么呢？</li></ul><p>用官方的语言介绍就是一个使用 <code>Vue.js</code> 开发所有前端应用的框架，开发者完成一套编码，可以发布到 <code>iOS</code>、<code>Android</code>、<code>H5</code> 以及各种小程序（微信 / 支付宝）等多个平台。</p><p>即便不跨端，<code>uni-app</code> 也是更好的小程序开发框架。</p><ul><li>为什么要学 <code>uni-app</code> ？</li></ul><p>对于开发者而言，很大程度了减少了学习成本，因为 <code>uni-app</code> 最大的优点，一套编码实现多端适配；于公司而言，也降低了开发成本。</p><h2 id="uni-app-项目文件结构"><a href="#uni-app-项目文件结构" class="headerlink" title="uni-app 项目文件结构"></a><code>uni-app</code> 项目文件结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- App.vue// 根组件，也是页面入口，可以调用应用的生命周期函数</span><br><span class="line">|-- index.html</span><br><span class="line">|-- main.js// 项目入口文件，主要作用的初始化 vue 实例并使用需要的插件</span><br><span class="line">|-- manifest.json// 应用配置文件，用于指定应用的名称、图标、权限等</span><br><span class="line">|-- pages// 所有页面存放的目录</span><br><span class="line">|-- pages.json// 用来对 uni-app 进行全局配置，决定页面的路径、窗口样式、原生的导航栏、底部原生的tabbar等</span><br><span class="line">|-- static// 静态资源目录</span><br><span class="line">|-- uni.scss// 为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置</span><br><span class="line">`-- unpackage// 打包目录</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> uni-app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浅学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试 - Vue篇</title>
      <link href="/2022/06/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-Vue%E7%AF%87/"/>
      <url>/2022/06/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95-Vue%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="谈谈对Vue生命周期的理解"><a href="#谈谈对Vue生命周期的理解" class="headerlink" title="谈谈对Vue生命周期的理解"></a>谈谈对Vue生命周期的理解</h2><blockquote><p>Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂载DOM、渲染-更新-渲染、卸载等一系列过程，称之为Vue实例的生命周期，钩子就是在某个阶段提供给你一个处理的机会。</p></blockquote><p><img src="https://s2.loli.net/2022/06/10/HROAMYkLgDcZas1.webp" alt="vue生命周期.png"></p><blockquote><h3 id="beforecreate"><a href="#beforecreate" class="headerlink" title="beforecreate"></a>beforecreate</h3><p>在实例初始化之后，数据监听和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods、data、computed等方法和数据。</p><h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><p>实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据监听、属性和方法的运算，watch/event事件回调，完成了data数据的初始化（el 没有）。然而，挂载阶段还没有开始，$el 属性目前还不可见，这是一个常用的生命周期钩子，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，获取computed中的计算属性</p><p>等，通常我们可以在这里对实例进行预处理，也有一些盆友喜欢在这里发ajax请求，值得关注的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此加入有数据需要获取才允许进入页面，并不适合在这个钩子中发请求，建议在组件路由钩子beforeRouteEnter中完成。</p><h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><p>挂载开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置：编译模板，把data中的数据和模板生成html，完成了el 和data 初始化，注意此时还没有挂载html到页面上。</p><h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><p>挂载完成，也就是模板中的html渲染的html页面中，此时可以做一些ajax操作，mounted只会执行一次。</p><h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><p>在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>在由于数据更改导致的虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务端渲染期间不被调用</p><h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><p>在实例销毁前，实例仍然完全可用</p><ol><li><p>这一步还可以用this来获取实例</p></li><li><p>一般在这一步做一些重置操作，比如清除掉组件中的定时器和监听的DOM事件</p></li></ol><h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><p>在实例销毁之后调用，调用后，所有的事件监听器会被移除，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用。</p></blockquote><p>🍵 第一次页面渲染会触发 <code>beforeCreate</code>, <code>created</code>, <code>beforeMount</code>,  <code>mounted</code> 这几个钩子函数</p><h3 id="created-和-mounted-的区别"><a href="#created-和-mounted-的区别" class="headerlink" title="created 和 mounted 的区别"></a>created 和 mounted 的区别</h3><p><code>created</code>：在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</p><p><code>mounted</code>：在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</p><h3 id="数据请求在created和mouted的区别"><a href="#数据请求在created和mouted的区别" class="headerlink" title="数据请求在created和mouted的区别"></a>数据请求在created和mouted的区别</h3><p><code>created</code>是在组件实例一旦创建完成的时候立刻调用，这时候页面<code>dom</code>节点并未生成<code>mounted</code>是在页面<code>dom</code>节点渲染完毕之后就立刻执行的触发时机上<code>created</code>是比<code>mounted</code>要更早的两者相同点：都能拿到实例对象的属性和方法讨论这个问题本质就是触发的时机，放在<code>mounted</code>请求有可能导致页面闪动（页面<code>dom</code>结构已经生成），但如果在页面加载前完成则不会出现此情况建议：放在<code>create</code>生命周期当中。</p><hr><h2 id="Vue-prototype、Vue-use-和Vue-compoent-的区别"><a href="#Vue-prototype、Vue-use-和Vue-compoent-的区别" class="headerlink" title="Vue.prototype、Vue.use 和Vue.compoent 的区别"></a>Vue.prototype、Vue.use 和Vue.compoent 的区别</h2><h3 id="Vue-prototype"><a href="#Vue-prototype" class="headerlink" title="Vue.prototype"></a>Vue.prototype</h3><p>通过在Vue原型上定意它们使其在每个Vue的实例中可用</p><p><code>$</code> 是在Vue所有实例中都可用的prototype 的一个简单约定。这样做会避免和已被定意的数据、方法、计算属性产生冲突</p><blockquote><p><strong>常用于方法和变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pinyin from &#x27;js-pinyin&#x27;</span><br><span class="line">Vue,prorotype.$pinyin = pinyin</span><br></pre></td></tr></table></figure></blockquote><h3 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h3><p><strong>注册全局插件</strong></p><p>会自动阻止多次注册相同插件，届时即使多次调用也只会注册一次该插件</p><p>插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue构造器，第二个参数是一个可选的选项对象</p><blockquote><p><strong>常用于注册第三方插件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import VueContextMenu from &#x27;vue-contextmenu&#x27;</span><br><span class="line">Vue.use(VueContextMenu)</span><br></pre></td></tr></table></figure></blockquote><h3 id="Vue-component"><a href="#Vue-component" class="headerlink" title="Vue.component"></a>Vue.component</h3><p><strong>注册全局组件</strong></p><p>第一个参数是调用组件时写的组件名</p><p>第二个参数是引入组件时写的标签名称</p><blockquote><p><strong>常用于注册自定义组件</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import JsTree from &#x27;@/components/JsTree&#x27;</span><br><span class="line">Vue.component(&#x27;JsTree&#x27;, JsTree)</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="route-和-router的区别"><a href="#route-和-router的区别" class="headerlink" title="$route 和 $router的区别"></a>$route 和 $router的区别</h2><p>**$router **是 <code>VueRouter</code> 的一个对象，通过 <code>Vue.use(VueRouter)</code> 和 <code>VueRouter</code> 构造函数，得到一个router 的实例对象，是一个全局对象，它包含了所有的路由和许多关键的对象和属性。</p><p>路由实例方法：</p><blockquote><ol><li>push</li><li>go</li><li>replace</li><li></li></ol></blockquote><p><strong>$route</strong> 是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部对象，可以获取对应的name、path、params、query等，我们可以从 <code>vue dectools</code> 中看到每个路由对象的不同。</p><p><strong>常用例子</strong></p><blockquote><p><strong>$router操作  路由跳转</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$router.push(&#123;name: &#x27;hello&#x27;, params: &#123;name: &#x27;word&#x27;, age: &#x27;11&#x27;&#125;&#125;);</span><br></pre></td></tr></table></figure><p><strong>$route 读取 路由参数接收</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = this.$route.params.name</span><br></pre></td></tr></table></figure></blockquote><hr><h2 id="Vue-中使用-v-html-会造成的影响"><a href="#Vue-中使用-v-html-会造成的影响" class="headerlink" title="Vue 中使用 v-html 会造成的影响"></a>Vue 中使用 v-html 会造成的影响</h2><ol><li>可能会导致 <a href="https://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065">xss 攻击</a>；</li><li><strong>v-html 更新的是元素的 innerHTML。</strong> 内容按普通HTML插入，不会作为 Vue 模板进行编译。但是有的时候我们需要渲染的html片段中有插值表达式，或者按照Vue 模板语法给DOM 元素绑定了事件；</li><li>使用 v-html 需要注意的第二个问题是：在但文件组里，scoped 的样式不会应用在 v-html 内部，因为那部分HTML 没有被Vue的模板编译器处理。如果你希望针对 v-html 的内容设置带作用域的 CSS，你可以替换为CSS Modules  或用一个额外的全局<code>&lt;style&gt;</code> 元素手动设置类似BEM的作用域策略；</li><li>后台返回的是 HTML 片段、CSS 样式和Js，但是返回的js是不执行的，因为浏览器在渲染的时候并没有将Js 渲染，这时要在$nextTIck中动态创建script标签并插入。</li></ol><hr><h2 id="Vue-的响应式数据原理"><a href="#Vue-的响应式数据原理" class="headerlink" title="Vue 的响应式数据原理"></a>Vue 的响应式数据原理</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>响应式</strong> 指的是组件data 的数据一旦变化，立刻触发试图的更新。它是实现数据驱动视图的第一步。</p><h3 id="监听data-变化的核心-API"><a href="#监听data-变化的核心-API" class="headerlink" title="监听data 变化的核心 API"></a>监听data 变化的核心 API</h3><p>Vue 实现响应式的一个核心API 是 <code>object.definePrototype</code>。该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><p>基本用法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;biile&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>)</span><br><span class="line">    name = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="built_in">console</span>.log(data.name) <span class="comment">// get biile</span></span><br><span class="line">data.name = <span class="string">&#x27;lisi&#x27;</span>     <span class="comment">// set</span></span><br></pre></td></tr></table></figure><p>利用 <code>object.definPrototype</code> 重写 <code>get</code> 和 <code>set</code>，将对属性的赋值和获取变成函数，我们可以实现一个简单的双向绑定。</p><h3 id="如何监听data-变化"><a href="#如何监听data-变化" class="headerlink" title="如何监听data 变化"></a>如何监听data 变化</h3><p>共定义了三个函数：</p><ul><li><strong>updateView：</strong>模拟 Vue 更新视图的入口函数。</li><li><strong>defineReactive：</strong>对数据进行监听的具体实现。</li><li><strong>observer：</strong>调用该函数后，可对目标对象进行监听，将目标对象变成响应式的。</li></ul><p>执行逻辑为：</p><p>定义一个对象 <code>data</code> ==&gt; 调用 <code>observer(data)</code> 将对象变成响应式的 ==&gt; 修改对象内的属性 ==&gt; 更新视图</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触发更新视图</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateView</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;视图更新&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新定义属性，监听起来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 核心 API</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">        <span class="comment">// 设置新值</span></span><br><span class="line">        <span class="comment">// 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值</span></span><br><span class="line">        value = newValue</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发更新视图</span></span><br><span class="line">        updateView()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听对象属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || target === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 监听的不是对象或数组时，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新定义各个属性（for in 也可以遍历数组）</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    defineReactive(target, key, target[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数据</span></span><br><span class="line">observer(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">data.name = <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line">data.age = <span class="number">21</span></span><br></pre></td></tr></table></figure><h3 id="如何深度监听data-变化"><a href="#如何深度监听data-变化" class="headerlink" title="如何深度监听data 变化"></a>如何深度监听data 变化</h3><p>对于嵌套属性的数据，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 准备数据</span></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;biile&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&#x27;北京&#x27;</span> <span class="comment">// 需要深度监听</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想监听到 <code>info.address</code> 的变化，则需要深度监听，修改 defineReactive 方法即可：</p><ul><li>在刚进入 <code>defineReactive</code> 函数的时候，先调用 <code>observer</code> 对传进来的值进行判断即可，由于 <code>info</code> 是个对象，所以会对<code>info</code> 遍历后再执行 <code>defineReactive</code> ；而其他基本类型的值在 <code>observer</code>中被直接返回。</li><li>在设置新值时也要对新值进行深度监听，原因是新值也可能是个对象，需要监听到它里面的属性。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新定义属性，监听起来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">target, key, value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 深度监听</span></span><br><span class="line">  observer(value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 核心 API</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">        <span class="comment">// 深度监听</span></span><br><span class="line">        observer(newValue)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置新值</span></span><br><span class="line">        <span class="comment">// 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值</span></span><br><span class="line">        value = newValue</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发更新视图</span></span><br><span class="line">        updateView()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-的diff-算法核心原理"><a href="#Vue-的diff-算法核心原理" class="headerlink" title="Vue 的diff 算法核心原理"></a>Vue 的diff 算法核心原理</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><code>diff</code> 算法是一种通过同层的树节点进行比较的高效算法</p><p>其有两个特点：</p><ul><li>比较只会在同层级进行，不会跨层级比较</li><li>在diss 比较的过程中，循环从两边向中间比较</li></ul><p><code>diff</code> 算法在很多场景下都有应用，在vue中，作用域虚拟DOM 渲染成真实 DOM 的新旧VNode 节点比较</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ul><li><p>当数据发生改变时，订阅者 <code>watcher</code> 就会调用 <code>patch</code> 给真实的 <code>DOM</code> 打补丁</p></li><li><p>通过 <code>isSameVnode</code> 进行判断，相同则调用 <code>patchVnode</code> 方法</p></li><li><p><code>patchVnode</code> 做了以下操作：</p><ul><li>找到对应的真实的 <code>DOM</code>， 称之为 <code>el</code></li><li>如果都有文本节点且不相等，将 <code>el</code>  文本节点设置为<code>Vnode</code> 的文本节点</li><li>如果<code>oldVnode</code> 有子节点而 <code>VNode</code> 没有，则删除 <code>el</code> 子节点</li><li>如果<code>oldVnode</code> 有子节点而 <code>VNode</code> 有，则将 <code>VNode</code> 的子节点真实化后添加到<code> el</code></li><li>如果两者都有子节点，则执行 <code>updateChildren</code> 函数比较子节点</li></ul></li><li><p><code>updateChildren</code> 主要做了以下操作：</p><ul><li>设置新旧<code>VNode</code> 的头尾指针</li><li>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用 <code>patchVnode</code> 进行 <code>patch</code> 重复流程、调用 <code>createElem</code>创建一个新节点，从哈希表寻找 key 一致的<code>VNode</code> 节点在分情况操作</li></ul></li></ul><hr><h2 id="Vue-与-Angular-以及-React的区别"><a href="#Vue-与-Angular-以及-React的区别" class="headerlink" title="Vue 与 Angular 以及 React的区别"></a>Vue 与 Angular 以及 React的区别</h2><h3 id="与-Angular-的区别"><a href="#与-Angular-的区别" class="headerlink" title="与 Angular 的区别"></a>与 Angular 的区别</h3><p><strong>相同点：</strong></p><ul><li>都支持指令：内置指令和自定义指令</li><li>都支持过滤器：内置过滤器和自定义过滤器</li><li>都支持双向数据绑定</li><li>都不支持低端浏览器</li></ul><p><strong>不同点：</strong></p><ul><li>AngularJS的学习成本高，比如增加了Dependency Injection特性，而 Vue.js 本身提供的API都比较简单、直观</li><li>在性能上，AngularJS 依赖对数据做脏检查，所以 Watcher 越多越慢<ul><li>Vue.js 使用基于依赖追踪的观察并且使用异步队列更新。</li><li>所有的数据都是独立触发。</li><li>对于庞大的应用来说，这个优化查阿姨还是比较明显的。</li></ul></li></ul><h3 id="与-React-的区别"><a href="#与-React-的区别" class="headerlink" title="与 React 的区别"></a>与 React 的区别</h3><p><strong>相同点：</strong></p><ul><li>React 采用特殊的 JSX 语法，Vue.js 在组件开发中也推崇编写.vue 特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用。</li><li>中心思想相同：一切都是组件，组件实例之间可以嵌套。</li><li>都提供合理的钩子函数，可以让开发者定制化的去处理需求。</li><li>都不内置AJAX，Route 等功能到核心包，而是以插件的方式加载。</li><li>在组件开发中都支持 mixins 的特性</li></ul><p><strong>不同点：</strong></p><ul><li>React 依赖 Virtual DOM，而Vue.js 使用的是DOM 模板。React 采用的 Virtual DOM 会对渲染出来的结果做脏检查。</li><li>Vue.js 在模板中提供了指令、过滤器等，可以非常方便，快捷地操作DOM。</li></ul><hr><h2 id="谈谈对-Vue-中-Nuxt-js-的理解"><a href="#谈谈对-Vue-中-Nuxt-js-的理解" class="headerlink" title="谈谈对 Vue 中 Nuxt.js 的理解"></a>谈谈对 Vue 中 Nuxt.js 的理解</h2><blockquote><p><strong>Nuxt.js</strong> 是一个基于 Vue.js 的通用应用框架</p><p>通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染</p><p>我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js</p><p>Nuxt.js 预设了利用 Vue.js 开发服务端渲染的应用所需要的各种配置</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>浏览器(客户端) 发送 http 请求到 Node.js 服务端</li><li>部署 Node.js 的应用 Nuxt.js 接收到浏览器请求，它会去请求后台服务端</li><li>后台接口服务端回响应 JSON 数据，Nuxt.js 获取数据后进行服务端渲染成html</li><li>然后 Nuxt.js 将 html 页面响应给浏览器</li><li>浏览器直接将接收到的html 页面进行展示</li></ol><p><img src="https://s2.loli.net/2022/06/14/svEFfPItVrnANT5.png" alt="image.png"></p><hr><h2 id="Vue-中-v-show-和-v-if-怎么理解"><a href="#Vue-中-v-show-和-v-if-怎么理解" class="headerlink" title="Vue 中 v-show 和 v-if 怎么理解"></a>Vue 中 v-show 和 v-if 怎么理解</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li><p>作用效果相同，都能够控制元素在页面是否展示</p></li><li><p>用法上相同</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Module v-show=&quot;isShow&quot;/&gt;</span><br><span class="line">&lt;Module v-if=&quot;isShow&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li>当表达式为 <code>true</code> 的时候，都会占据页面的位置</li><li>当表达式为 <code>false</code> 的时候，都不会占据页面位置</li></ul></li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>控制手段不同<ul><li> <code>v-show</code> 隐藏则是为该元素添加 <code>css -- display:none</code>， <code>dom</code> 元素依旧还在。 <code>v-if</code> 显示隐藏是将 <code>dom</code> 元素整个添加或删除</li></ul></li><li>编译过程不同<ul><li><code>v-if</code> 切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；<code>v-show</code> 只是简单的基于css 切换</li></ul></li><li>编译条件不同<ul><li><code>v-if</code> 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器个子组件适当的被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染。</li></ul></li><li><code>v-show</code> 由 <code>false</code> 变为<code>true</code> 的时候不会触发组件的生命周期</li><li><code>v-if</code> 由 <code>false</code> 变为<code>true</code> 的时候，触发组建的 <code>beforeCreate</code>、<code>create</code>、<code>beforeMount</code>、<code>mounted</code> 钩子，由 <code>true </code>变为<code>false </code>的时候触发组件的 <code>beforeDestory</code>、<code>destoryed </code>方法</li></ul><p>性能消耗： <code>v-if</code> 由更高的切换消耗； <code>v-show</code> 有更高的初始渲染消耗。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p><code>v-if</code> 与 <code>v-show</code> 都能控制 <code>dom</code> 元素在页面的展示</p><p><code>v-if</code> 相比 <code>v-show</code> 开销更大（直接操作 <code>dom</code> 节点增加与删除）</p><p>如果需要非常频繁地切换，则使用 <code>v-show</code> 较好</p><p>如果在运行时条件很少改变，则使用 <code>v-if</code> 较好</p><hr><h2 id="计算属性-computed-和-监听属性-watch-的区别"><a href="#计算属性-computed-和-监听属性-watch-的区别" class="headerlink" title="计算属性(computed) 和 监听属性(watch) 的区别"></a>计算属性(computed) 和 监听属性(watch) 的区别</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><ol><li><b style="color:'red'">支持缓存</b>，只有<b style="color:'red'">依赖数据发生改变</b>，才会重新进行计算</li><li><b style="color:'red'">不支持异步</b>，当 <code>computed</code> 内有异步操作时无效，无法监听数据的变化</li><li><code>computed</code> 属性值会<b style="color:'red'">默认缓存</b>，计算属性是基于它们 的响应式依赖进行缓存的，也就是<b style="color:'red'">基于data 中</b>声明过或者<b style="color:'red'">父组件传递的props中的数据</b> 通过计算得到的值</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用<code>computed</code></li><li>如果<code>computed</code> 属性的属性值为函数，那么默认会走get 方法；函数的 <b style="color:'red'">返回值就是属性的属性值</b>；在 <code>computed</code> 中的属性都有一个get方法和一个<code>set</code>方法，当数据变化时，调用 <code>set</code> 方法</li></ol><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>表现为同步处理数据，带有计算性质的，都可以优先考虑 <code>computed</code></p><p>不需要关注点击事件或者其他数据，只要将计算规则写在属性里，就能实时获取对应的数据</p><p><strong>例如：</strong></p><blockquote><p>电商领域得购物车统计，一个数据依赖于一个或多个数据</p><p>当购物车数量和产品变化时，自动计算出价格*数量得总和</p><p>如果有优惠券或者折扣，自动减去优惠和计算折扣金额即可，同上实时计算</p><p>只要购买数量、购买价格、优惠券、折扣券等任意一个发生变化，总价都会自动跟踪变化</p></blockquote><h3 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h3><ol><li><b style="color:'red'">不支持缓存，数据会发生改变，会直接触发相应的操作</b></li><li><code>watch</code> <b style="color:'red'">支持异步</b></li><li>监听的函数接收 <b style="color:'red'">两个参数，第一个参数是最新的值，第二个参数是输入之前的值</b></li><li>当一个属性发生变化时。需要执行对应的操作；<b style="color:'red'">一对多</b></li><li>监听数据必须是 <b style="color:'red'">data 中声明过</b> 或者父组件传递过来的<b style="color:'red'">props中的数据</b>，当数据变化时，触发其他操作，函数有两个参数<ol><li><code>immediate</code> ：组件加载立即触发回调函数执行</li><li><code>deep</code>：深度监听，为了发现<strong>对象内部值</strong>得变化，复杂类型得数据时使用，例如数组中得对象内容得改变，注意监听数组得变动不需要这么做。⚠️ 注意：<code>deep</code> 无法监听到数组得变动和对象的新增，参考 Vue 数组变异，只有以响应式得方式触发才会被监听到。</li></ol></li></ol><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>​    主要适用于与事件和交互有关的场景，数据变化为条件，适用于一个数据同时触发多个事物</p><p><strong>例如：</strong>当借款额度大于可借额度时，弹出toast 提示，并将当前借款额度调整到最大额度</p><blockquote><p>🔗 当需要在数据变化时执行异步或开销比较大得操作时，这个方式是最有用的。这是和computed最大的区别。</p></blockquote><hr><h2 id="谈谈对箭头函数的理解"><a href="#谈谈对箭头函数的理解" class="headerlink" title="谈谈对箭头函数的理解"></a>谈谈对箭头函数的理解</h2><h3 id="相比普通函数，箭头函数有更简洁的语法"><a href="#相比普通函数，箭头函数有更简洁的语法" class="headerlink" title="相比普通函数，箭头函数有更简洁的语法"></a>相比普通函数，箭头函数有更简洁的语法</h3><blockquote><p><strong>普通函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num + <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>箭头函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">num</span> =&gt;</span> num + <span class="number">10</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="箭头函数不绑定-this，会捕获其所在上下文的this，作为自己的this"><a href="#箭头函数不绑定-this，会捕获其所在上下文的this，作为自己的this" class="headerlink" title="箭头函数不绑定 this，会捕获其所在上下文的this，作为自己的this"></a>箭头函数不绑定 this，会捕获其所在上下文的this，作为自己的this</h3><blockquote><p>这里需要注意的是，箭头函数的外层如果有普通函数，那么箭头函数的this 就是这个外层的普通函数的 this，箭头函数的外层如果没有普通函数，那么箭头函数的 this 就是全局变量</p></blockquote><h3 id="箭头函数是匿名函数，不能作为构造函数，不可以使用new-命令，否则后抛出错误"><a href="#箭头函数是匿名函数，不能作为构造函数，不可以使用new-命令，否则后抛出错误" class="headerlink" title="箭头函数是匿名函数，不能作为构造函数，不可以使用new 命令，否则后抛出错误"></a>箭头函数是匿名函数，不能作为构造函数，不可以使用new 命令，否则后抛出错误</h3><h3 id="箭头函数不绑定-arguments，取而代之用rest-参数解决，同时灭有super-和-new-target"><a href="#箭头函数不绑定-arguments，取而代之用rest-参数解决，同时灭有super-和-new-target" class="headerlink" title="箭头函数不绑定 arguments，取而代之用rest 参数解决，同时灭有super 和 new.target"></a>箭头函数不绑定 arguments，取而代之用rest 参数解决，同时灭有super 和 new.target</h3><p>箭头函数没有 arguments、super、new.target 的绑定，这些值由外围最近一层非箭头函数决定。</p><h3 id="使用call-、apply、bind-并不会改变箭头函数中的this-指向"><a href="#使用call-、apply、bind-并不会改变箭头函数中的this-指向" class="headerlink" title="使用call 、apply、bind 并不会改变箭头函数中的this 指向"></a>使用call 、apply、bind 并不会改变箭头函数中的this 指向</h3><ul><li>当对箭头函数使用call 或 apply方法时，只会传入参数并调用函数，并不会改变箭头函数中this的指向</li><li>当对箭头函数使用bind 方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的this 指向</li></ul><h3 id="箭头函数没有原型对象-prototype-这个属性"><a href="#箭头函数没有原型对象-prototype-这个属性" class="headerlink" title="箭头函数没有原型对象 prototype 这个属性"></a>箭头函数没有原型对象 prototype 这个属性</h3><p>由于不可以通过 new 关键字调用，所以没有构建原型的需求，所以箭头函数没有prototype 这个属性</p><hr><h2 id="axios-的请求"><a href="#axios-的请求" class="headerlink" title="axios 的请求"></a>axios 的请求</h2><h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p>Vue.js 没有直接处理 ajax 组件，但可以使用 axios 或vue-resource组件实现对异步请求的操作。</p><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><p><code>axios</code>  是一个基于 promise 的http 库，可以用在浏览器和 node.js 中。</p><p>axios 的github 地址为 <code>https://github.com/axios/axios</code></p><p>如果使用 npm 可以如下安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>或者也可以直接使用公用CDN 服务：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境，包含了用帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="axios-的作用"><a href="#axios-的作用" class="headerlink" title="axios 的作用"></a>axios 的作用</h5><ol><li><strong>发送异步请求获取数据</strong></li><li>常见方法：<ol><li>get、post</li><li>在发送的时候可以指定参数（地址、请求方式和请求头部信息）</li><li>返回数据结构（data / status / status Text / headers / config）</li></ol></li></ol><h5 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h5><p><strong>config 请求配置</strong></p><p>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 个体 方法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> // url 是用于请求的服务器 URL</span><br><span class="line"> url: &#x27;/user&#x27;,</span><br><span class="line"> </span><br><span class="line"> // method 是创建请求时使用的方法</span><br><span class="line"> method: &#x27;get&#x27;,</span><br><span class="line"> </span><br><span class="line"> // baseURL 将自动加在 url前面，除非 url 是一个绝对 URL</span><br><span class="line"> // 它可以通过设置一个 baseURL 便于为 axios 实例的方法传递相对 URL</span><br><span class="line"> baseURL: &#x27;https: any-domin.com/api&#x27;，</span><br><span class="line"> </span><br><span class="line"> // transformRequest 允许在向服务器发送前，修改请求数据</span><br><span class="line"> // 只能用在 &#x27;put&#x27;，&#x27;post&#x27; 和 &#x27;patch&#x27; 这几个请求方法</span><br><span class="line"> // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或stream</span><br><span class="line"> transformRequest: [function (data) &#123;</span><br><span class="line">  // 对 data 进行任意转换处理</span><br><span class="line">  return data;</span><br><span class="line"> &#125;],</span><br><span class="line"> </span><br><span class="line"> // transformResponse 在传递给 then /catch 前，允许修改响应数据</span><br><span class="line"> transformReponse: [function (data) &#123;</span><br><span class="line">  // 对 data 进行任意转换处理</span><br><span class="line">  return data;</span><br><span class="line"> &#125;],</span><br><span class="line"> </span><br><span class="line"> // headers 是即将被发送的自定义请求头</span><br><span class="line"> headers: &#123;</span><br><span class="line">  &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;,</span><br><span class="line">  &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> // params 是即将与请求一起发送的 URl 参数</span><br><span class="line"> // 必须是一个五个师对象(plain object) 或 URLSearchParams 对象</span><br><span class="line"> params: &#123;</span><br><span class="line">  ID: 12345</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> // data 是作为请求主体被发送的数据</span><br><span class="line"> </span><br><span class="line"> // 只适用于这些请求方法： get、post、patch</span><br><span class="line"> </span><br><span class="line"> // 在没有设置 transformRequest 时，必须是以下类型之一：</span><br><span class="line"> // - string， plain object， ArrayBuffer， ArrayBufferView， URLSearchParams</span><br><span class="line"> // - 浏览器专属：FormData，File，Blob</span><br><span class="line"> // - Node 专属： Stream</span><br><span class="line"> data: &#123;</span><br><span class="line">  firstName: &#x27;Fred&#x27;</span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> // timeout 指定请求超时的毫秒数（0  表示无超时时间）</span><br><span class="line"> // 如果请求耗时超过了 timeout 的事件，请求将被中断</span><br><span class="line"> timeout: 1000,</span><br><span class="line"> </span><br><span class="line"> // withCredentials 表示跨域请求时是否需要使用凭证</span><br><span class="line"> withCredentials: false, // 默认的</span><br><span class="line"> </span><br><span class="line"> // </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题之Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python创建、退出虚拟环境(virtualenv)</title>
      <link href="/2022/05/28/Python%E5%88%9B%E5%BB%BA%E3%80%81%E9%80%80%E5%87%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83-virtualenv/"/>
      <url>/2022/05/28/Python%E5%88%9B%E5%BB%BA%E3%80%81%E9%80%80%E5%87%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83-virtualenv/</url>
      
        <content type="html"><![CDATA[<h2 id="Python虚拟环境-–-virtualenv"><a href="#Python虚拟环境-–-virtualenv" class="headerlink" title="Python虚拟环境 – virtualenv"></a>Python虚拟环境 – virtualenv</h2><p>virtualenv 是一个创建隔绝的Python 环境的工具。virtualenv 创建一个包含所有必要的可执行文件的文件夹，用来使用Python 工程所需的包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>1.为一个工程创建一个虚拟环境：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir my_project_dir　　#创建文件夹</span><br><span class="line">$ cd my_project_dir</span><br><span class="line">$ virtualenv venv　　#venv为虚拟环境目录名，目录名自定义</span><br></pre></td></tr></table></figure><p><code>　virtualenv venv</code> 将会在当前的目录中创建一个文件夹，包含了Python可执行文件，以及 <code>pip</code> 库的一份拷贝，这样就能安装其他包了。虚拟环境的名字（此例中是 <code>venv</code> ）可以是任意的；若省略名字将会把文件均放在当前目录。</p><p>在任何你运行命令的目录中，这会创建Python的拷贝，并将之放在叫做 <code>venv</code> 的文件中。</p><p>你可以选择使用一个Python解释器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ virtualenv -p /usr/<span class="built_in">bin</span>/python2<span class="number">.7</span> venv　　　　<span class="comment"># -p参数指定Python解释器程序路径</span></span><br></pre></td></tr></table></figure><p>2.要使用虚拟环境要将其激活：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ source venv/<span class="built_in">bin</span>/activate　　</span><br></pre></td></tr></table></figure><p>在此使用的pip安装包将会放在 <code>venv</code> 文件夹中，与全局安装的Python隔绝开。</p><p>3.如果在虚拟环境中暂时完成了工作，则可以停用它：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ . venv/<span class="built_in">bin</span>/deactivate</span><br></pre></td></tr></table></figure><p>这将会回到系统默认的Python解释器，包括已安装的库也会回到默认的。</p><p>要删除一个虚拟环境，只需删除它的文件夹。（执行 <code>rm -rf venv</code> ）。</p><p>这里virtualenv 有些不便，因为virtual的启动、停止脚本都在特定文件夹，可能一段时间后，你可能会有很多个虚拟环境散落在系统各处，你可能忘记它们的名字或者位置。</p>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题集</title>
      <link href="/2022/05/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/"/>
      <url>/2022/05/10/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML-篇"><a href="#HTML-篇" class="headerlink" title="HTML 篇"></a>HTML 篇</h2><h3 id="1-简述一下对-HTML-语义化的解释"><a href="#1-简述一下对-HTML-语义化的解释" class="headerlink" title="1.简述一下对 HTML 语义化的解释"></a>1.简述一下对 HTML 语义化的解释</h3><blockquote><p>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p></blockquote><h3 id="2-标签上-title-和-alt-属性的区别是什么？"><a href="#2-标签上-title-和-alt-属性的区别是什么？" class="headerlink" title="2.标签上 title 和 alt 属性的区别是什么？"></a>2.标签上 title 和 alt 属性的区别是什么？</h3><blockquote><p>alt 是给搜索引擎识别，在图像无法显示时的替代文本；<br>title 是关于元素的注释信息，主要是给用户解读。<br>当鼠标放到文字或是图片上时有 title 文字显示。（因为 IE 不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。<br>在定义 img 对象时，将 alt 和 title 属性写全，可以保证在各种浏览器中都能正常使用。</p></blockquote><h3 id="3-iframe-的优缺点"><a href="#3-iframe-的优缺点" class="headerlink" title="3.iframe 的优缺点"></a>3.iframe 的优缺点</h3><blockquote><p>优点：</p><ul><li>解决加载缓慢的第三方内容如图标和广告等的加载问题</li><li>Security sandbox</li><li>并行加载脚本</li></ul><p>缺点：</p><ul><li>iframe 会阻塞主页面的 Onload 事件</li><li>即时内容为空，加载也需要时间</li><li>没有语意</li></ul></blockquote><h2 id="CSS-篇"><a href="#CSS-篇" class="headerlink" title="CSS 篇"></a>CSS 篇</h2><h3 id="1-介绍一下-CSS-的盒子模型"><a href="#1-介绍一下-CSS-的盒子模型" class="headerlink" title="1.介绍一下 CSS 的盒子模型"></a>1.介绍一下 CSS 的盒子模型</h3><blockquote><p>有两种， IE 盒子模型、W3C 盒子模型；<br>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>区 别： IE 的 content 部分把 border 和 padding 计算了进去;</p></blockquote><h3 id="2-垂直居中的几种方式"><a href="#2-垂直居中的几种方式" class="headerlink" title="2.垂直居中的几种方式"></a>2.垂直居中的几种方式</h3><blockquote><p>单行文本: line-height = height<br>图片: vertical-align: middle;<br>absolute 定位: top: 50%;left: 50%;transform: translate(-50%, -50%);<br>flex: display:flex;margin:auto</p></blockquote><h3 id="3-rgba-和-opacity-的透明效果有什么不同？"><a href="#3-rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="3.rgba 和 opacity 的透明效果有什么不同？"></a>3.rgba 和 opacity 的透明效果有什么不同？</h3><blockquote><p>opacity 会继承父元素的 opacity 属性，而 RGBA 设置的元素的后代元素不会继承不透明属性。</p></blockquote><h3 id="4-position-的值，relative-和-absolute-分别是相对于谁进行定位"><a href="#4-position-的值，relative-和-absolute-分别是相对于谁进行定位" class="headerlink" title="4.position 的值，relative 和 absolute 分别是相对于谁进行定位"></a>4.position 的值，relative 和 absolute 分别是相对于谁进行定位</h3><blockquote><p>relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。<br>absolute:生成绝对定位，相对于最近一级定位不为 static 的父元素进行定位。<br>fixed: （老版本 IE 不支持）生成绝对定位，相对于浏览器窗口或者 frame 进行定位。<br>static:默认值，没有定位，元素出现在正常的文档流中。<br>sticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。</p></blockquote><h2 id="HTML-CSS-混合篇"><a href="#HTML-CSS-混合篇" class="headerlink" title="HTML / CSS 混合篇"></a>HTML / CSS 混合篇</h2><h3 id="1-HTML5、CSS-里面都新增了那些特性？"><a href="#1-HTML5、CSS-里面都新增了那些特性？" class="headerlink" title="1.HTML5、CSS 里面都新增了那些特性？"></a>1.HTML5、CSS 里面都新增了那些特性？</h3><blockquote><p>HTML5</p><ul><li>新的语义标签</li><li>article 独立的内容。</li><li>aside 侧边栏。</li><li>header 头部。</li><li>nav 导航。</li><li>section 文档中的节。</li><li>footer 页脚。</li><li>画布(Canvas) API</li><li>地理(Geolocation) API</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>新的技术 webworker, websocket, Geolocation</li><li>拖拽释放(Drag and drop) API</li><li>音频、视频 API(audio,video)</li><li>表单控件，calendar、date、time、email、url、search</li></ul><p>CSS3</p><ul><li>2d，3d 变换</li><li>Transition, animation</li><li>媒体查询</li><li>新的单位（rem, vw，vh 等）</li><li>圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow），线性渐变（gradient），旋转（transform）transform:rotate(9deg) scale(0.85,0.90)transnslate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</li><li>rgba</li></ul></blockquote><h3 id="2-BFC-是什么？"><a href="#2-BFC-是什么？" class="headerlink" title="2.BFC 是什么？"></a>2.BFC 是什么？</h3><blockquote><p>BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于普通流，即：元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。<br>可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。<br>只要元素满足下面任一条件即可触发 BFC 特性</p><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul></blockquote><h3 id="3-常见兼容性问题"><a href="#3-常见兼容性问题" class="headerlink" title="3.常见兼容性问题"></a>3.常见兼容性问题</h3><blockquote><p>浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。<br>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p></blockquote><h2 id="JS-篇"><a href="#JS-篇" class="headerlink" title="JS 篇"></a>JS 篇</h2><h3 id="1-JS-数据类型？"><a href="#1-JS-数据类型？" class="headerlink" title="1.JS 数据类型？"></a>1.JS 数据类型？</h3><blockquote><p>数据类型主要包括两部分：</p><ul><li>基本数据类型： Undefined、Null、Boolean、Number 和 String</li><li>引用数据类型： Object (包括 Object 、Array 、Function)</li><li>ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</li></ul></blockquote><h3 id="2-判断一个值是什么类型有哪些方法？"><a href="#2-判断一个值是什么类型有哪些方法？" class="headerlink" title="2.判断一个值是什么类型有哪些方法？"></a>2.判断一个值是什么类型有哪些方法？</h3><blockquote><ul><li>typeof 运算符</li><li>instanceof 运算符</li><li>Object.prototype.toString 方法</li></ul></blockquote><h3 id="3-null-和-undefined-的区别"><a href="#3-null-和-undefined-的区别" class="headerlink" title="3.null 和 undefined 的区别"></a>3.null 和 undefined 的区别</h3><blockquote><p>null 表示一个对象被定义了，值为“空值”；undefined 表示不存在这个值。<br>（1）变量被声明了，但没有赋值时，就等于 undefined。<br>（2) 调用函数时，应该提供的参数没有提供，该参数等于 undefined。<br>（3）对象没有赋值的属性，该属性的值为 undefined。<br>（4）函数没有返回值时，默认返回 undefined。</p></blockquote><h3 id="4-怎么判断一个变量-arr-的话是否为数组（此题用-typeof-不行）？"><a href="#4-怎么判断一个变量-arr-的话是否为数组（此题用-typeof-不行）？" class="headerlink" title="4.怎么判断一个变量 arr 的话是否为数组（此题用 typeof 不行）？"></a>4.怎么判断一个变量 arr 的话是否为数组（此题用 typeof 不行）？</h3><blockquote><ul><li>arr instanceof Array</li><li>arr.constructor == Array</li><li>Object.protype.toString.call(arr) == ‘[Object Array]’</li></ul></blockquote><h3 id="5-箭头函数有哪些特点？"><a href="#5-箭头函数有哪些特点？" class="headerlink" title="5.箭头函数有哪些特点？"></a>5.箭头函数有哪些特点？</h3><blockquote><ul><li>不需要 function 关键字来创建函数</li><li>省略 return 关键字</li><li>改变 this 指向</li></ul></blockquote><h3 id="6-new-操作符具体干了什么呢？"><a href="#6-new-操作符具体干了什么呢？" class="headerlink" title="6.new 操作符具体干了什么呢？"></a>6.new 操作符具体干了什么呢？</h3><blockquote><ol><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li><li>属性和方法被加入到 this 引用的对象中。</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li></ol></blockquote><h3 id="7-documen-write"><a href="#7-documen-write" class="headerlink" title="7.documen.write"></a>7.documen.write</h3><blockquote><ul><li>document.write 只能重绘整个页面</li><li>innerHTML 可以重绘页面的一部分</li></ul></blockquote><h3 id="8-ajax-过程"><a href="#8-ajax-过程" class="headerlink" title="8.ajax 过程"></a>8.ajax 过程</h3><blockquote><p>(1)创建 XMLHttpRequest 对象,也就是创建一个异步调用对象.</p><p>(2)创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息.</p><p>(3)设置响应 HTTP 请求状态变化的函数.</p><p>(4)发送 HTTP 请求.</p><p>(5)获取异步调用返回的数据.</p><p>(6)使用 JavaScript 和 DOM 实现局部刷新.</p></blockquote><h3 id="9-请解释一下-JavaScript-的同源策略？"><a href="#9-请解释一下-JavaScript-的同源策略？" class="headerlink" title="9.请解释一下 JavaScript 的同源策略？"></a>9.请解释一下 JavaScript 的同源策略？</h3><blockquote><p>概念:同源策略是客户端脚本（尤其是 Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。</p></blockquote><h3 id="10-介绍一下闭包和闭包常用场景"><a href="#10-介绍一下闭包和闭包常用场景" class="headerlink" title="10.介绍一下闭包和闭包常用场景"></a>10.介绍一下闭包和闭包常用场景</h3><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包常见方式，就是在一个函数的内部创建另一个函数<br>使用闭包主要为了设计私有的方法和变量，闭包的优点是可以避免变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在 js 中，函数即闭包，只有函数才会产生作用域的概念。<br>闭包有三个特性：</p><ul><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收<br>应用场景，设置私有变量的方法<br>不适用场景：返回闭包的函数是个非常大的函数<br>闭包的缺点就是常驻内存，会增大内存使用量，使用不当会造成内存泄漏</li></ul></blockquote><h3 id="11-JavaScript-的内存（垃圾）回收机制？"><a href="#11-JavaScript-的内存（垃圾）回收机制？" class="headerlink" title="11.JavaScript 的内存（垃圾）回收机制？"></a>11.JavaScript 的内存（垃圾）回收机制？</h3><blockquote><ul><li>垃圾回收器会每隔一段时间找出那些不再使用的内存，然后为其释放内存</li><li>一般使用标记清除方法(mark and sweep), 当变量进入环境标记为进入环境，离开环境标记为离开环境垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li><li>还有引用计数方法(reference counting), 在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。</li><li>在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过引用计数回收垃圾的， 也就是说只要涉及 BOM 及 DOM 就会出现循环引用问题。</li></ul></blockquote><h2 id="Vue-篇"><a href="#Vue-篇" class="headerlink" title="Vue 篇"></a>Vue 篇</h2><h3 id="1-谈谈对-MVVM-开发模式的理解"><a href="#1-谈谈对-MVVM-开发模式的理解" class="headerlink" title="1.谈谈对 MVVM 开发模式的理解"></a>1.谈谈对 MVVM 开发模式的理解</h3><blockquote><ul><li>MVVM 分为 Model、View、ViewModel 三者。</li><li>Model 代表数据模型，数据和业务逻辑都在 Model 层中定义；</li><li>View 代表 UI 视图，负责数据的展示；</li><li>ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；</li><li>Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。</li><li>这种模式实现了 Model 和 View 的数据自动</li></ul></blockquote><h3 id="2-v-if-和-v-show-有什么区别？"><a href="#2-v-if-和-v-show-有什么区别？" class="headerlink" title="2.v-if 和 v-show 有什么区别？"></a>2.v-if 和 v-show 有什么区别？</h3><blockquote><ul><li>v-if 是真正的条件渲染，会控制这个 DOM 节点的存在与否。因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li><li>v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。当我们需要经常切换某个元素的显示/隐藏时，使用 v-show 会更加节省性能上的开销；当只需要一次显示或隐藏时，使用 v-if 更加合理。</li></ul></blockquote><h3 id="3-使用过-VueX-吗？"><a href="#3-使用过-VueX-吗？" class="headerlink" title="3.使用过 VueX 吗？"></a>3.使用过 VueX 吗？</h3><blockquote><ul><li><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p></li><li><p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p></li><li><p>（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p></li></ul><p>主要包括以下几个模块：</p><ul><li>State =&gt; 基本数据，定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter =&gt; 从基本数据派生的数据，允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation =&gt; 是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action =&gt; 像一个装饰器，包裹 mutations，使之可以异步。用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module =&gt; 模块化 Vuex，允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul></blockquote><h3 id="4-说说对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#4-说说对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="4.说说对 SPA 单页面的理解，它的优缺点分别是什么？"></a>4.说说对 SPA 单页面的理解，它的优缺点分别是什么？</h3><blockquote><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页&gt; 面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 &gt; HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p><p>优点：</p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p>缺点：</p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统&gt;&gt; 加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所&gt;&gt;有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul></blockquote><h3 id="5-Class-于-Style-如何动态绑定？"><a href="#5-Class-于-Style-如何动态绑定？" class="headerlink" title="5.Class 于 Style 如何动态绑定？"></a>5.Class 于 Style 如何动态绑定？</h3><blockquote><p>Class 可以通过对象语法和数组语法进行动态绑定：</p><p>对象语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: &#x27;active&#x27;,</span><br><span class="line">  errorClass: &#x27;text-danger&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Style 也可以通过对象语法和数组语法进行动态绑定：</p><p>对象语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: &#x27;red&#x27;,</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:style=&quot;[styleColor, styleSize]&quot;&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">      color: &#x27;red&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">      ontSize:&#x27;23px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-怎样理解-Vue-的单向数据流？"><a href="#6-怎样理解-Vue-的单向数据流？" class="headerlink" title="6.怎样理解 Vue 的单向数据流？"></a>6.怎样理解 Vue 的单向数据流？</h3><blockquote><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。<br>这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p></blockquote><h3 id="7-computed-和-watch-的区别和运用场景？"><a href="#7-computed-和-watch-的区别和运用场景？" class="headerlink" title="7.computed 和 watch 的区别和运用场景？"></a>7.computed 和 watch 的区别和运用场景？</h3><blockquote><p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；<br>运用场景：</p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul></blockquote><h3 id="8-直接给一个数组赋值，Vue-能检测到变化吗？"><a href="#8-直接给一个数组赋值，Vue-能检测到变化吗？" class="headerlink" title="8.直接给一个数组赋值，Vue 能检测到变化吗？"></a>8.直接给一个数组赋值，Vue 能检测到变化吗？</h3><blockquote><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ul><p>为了解决第一个问题，Vue 提供了以下操作方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Vue.set</span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line">// vm.$set，Vue.set的一个别名</span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二个问题，Vue 提供了以下操作方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure></blockquote><h3 id="9-谈谈对生命周期的理解"><a href="#9-谈谈对生命周期的理解" class="headerlink" title="9.谈谈对生命周期的理解"></a>9.谈谈对生命周期的理解</h3><blockquote><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p></blockquote><p><strong><em>各个生命周期的作用</em></strong><br>|生命周期 |描述|<br>|—————–|——————-|<br>| beforeCreate |组件实例被创建之初，组件的属性生效之前|<br>| created |组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用|<br>| beforeMount     |在挂载开始之前被调用：相关的 render 函数首次被调用|<br>| mounted         |el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子|<br>| beforeUpdate |组件数据更新之前调用，发生在虚拟 DOM 打补丁之前|<br>| updated |组件数据更新之后|<br>| activited |keep-alive 专属，组件被激活时调用|<br>| deadctivated |keep-alive 专属，组件被销毁时调用|<br>| beforeDestory |组件销毁前调用|<br>| destoryed |组件销毁后调用|</p><h3 id="10-Vue-的父组件和子组件生命周期钩子函数执行顺序"><a href="#10-Vue-的父组件和子组件生命周期钩子函数执行顺序" class="headerlink" title="10.Vue 的父组件和子组件生命周期钩子函数执行顺序"></a>10.Vue 的父组件和子组件生命周期钩子函数执行顺序</h3><blockquote><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p><p>加载渲染过程 :<br>· 父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted<br>子组件更新过程 :<br>· 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated<br>父组件更新过程 :<br>· 父 beforeUpdate -&gt; 父 updated<br>销毁过程 :<br>· 父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p></blockquote><h3 id="11-父组件可以监听到子组件的生命周期吗"><a href="#11-父组件可以监听到子组件的生命周期吗" class="headerlink" title="11.父组件可以监听到子组件的生命周期吗"></a>11.父组件可以监听到子组件的生命周期吗</h3><blockquote><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Parent.vue</span><br><span class="line">&lt;Child @mounted=&quot;doSomething&quot;/&gt;</span><br><span class="line"></span><br><span class="line">// Child.vue</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.$emit(&quot;mounted&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  Parent.vue</span><br><span class="line">&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;</span><br><span class="line"></span><br><span class="line">doSomething() &#123;</span><br><span class="line">   console.log(&#x27;父组件监听到 mounted 钩子函数 ...&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//  Child.vue</span><br><span class="line">mounted()&#123;</span><br><span class="line">   console.log(&#x27;子组件触发 mounted 钩子函数 ...&#x27;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>// 以上输出顺序为：<br>// 子组件触发 mounted 钩子函数<br>// 父组件监听到 mounted 钩子函数<br>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p></blockquote><p>33.Vue 框架怎么实现对象和数组的监听</p><p>34.Vue 是如何实现数据双向绑定的</p><p>35.Vue 怎么用 vm.$set()解决对象新增属性不能响应的问题</p><p>36.虚拟 DOM 的优缺点？</p><blockquote><p>优点：</p><ul><li>保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li><li>无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li><li>跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ul><p>缺点:</p><ul><li>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</li></ul></blockquote><p>37.虚拟 DOM 实现原理？</p><blockquote><p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p><ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul></blockquote><p>38.Vue 中的 key 有什么作用?</p><blockquote><p><strong><em>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。</em></strong><br>Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有 4 种比较方式：newStartIndex 和 oldStartIndex 、newEndIndex 和 oldEndIndex 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了 key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx &gt; EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。<br>所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速!</p><ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createKeyToOldIdx (children, beginIdx, endIdx) &#123;</span><br><span class="line">let i, key</span><br><span class="line">const map = &#123;&#125;</span><br><span class="line">for (i = beginIdx; i &lt;= endIdx; ++i) &#123;</span><br><span class="line">  key = children[i].key</span><br><span class="line">  if (isDef(key)) map[key] = i</span><br><span class="line">&#125;</span><br><span class="line">return map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>39.你有对 Vue 项目进行那些优化</p><blockquote><p>(1) 代码层面的优化</p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch 区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li></ul><hr><p>(2) Webpack 层面的优化</p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li></ul><hr><p>(3) 基础的 Web 技术的优化</p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul></blockquote><p>40.对于 vue3.0 特性有什么了解的吗</p><blockquote><p><strong>Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</strong></p><p><strong>（1）监测机制的改变</strong><br>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p><ul><li>只能监测属性，不能监测对象</li><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。<br>新的 observer 还提供了以下特性：</li><li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li><li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li><li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li><li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li><li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ul><p><strong>（2）模板</strong><br>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。<br>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p><p><strong>（3）对象式的组件声明方式</strong><br>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。<br>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。<br>此外，vue 的源码也改用了 TypeScript 来写。其实当代码的功能复杂之后，必须有一个静态类型系统来做一些辅助管理。<br>现在 vue3.0 也全面改用 TypeScript 来重写了，更是使得对外暴露的 api 更容易结合 TypeScript。静态类型系统对于复杂代码的维护确实很有必要。</p><p><strong>（4）其它方面的更改</strong><br>vue3.0 的改变是全面的，上面只涉及到主要的 3 个方面，还有一些其他的更改：</p><ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 treeshaking 优化，提供了更多的内置功能。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>export 和export default的区别</title>
      <link href="/2022/03/07/export-%E5%92%8Cexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/03/07/export-%E5%92%8Cexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="export-的使用"><a href="#export-的使用" class="headerlink" title="export 的使用"></a>export 的使用</h2><p>export 可以直接到处或者先定义后到处。<br><br>例：</p><p>直接导出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export let i = &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">export function myFun()&#123;&#125;;</span><br></pre></td></tr></table></figure><br>先定义后导出：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let i = &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">function myFun()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">export &#123;i, myFun&#125;</span><br></pre></td></tr></table></figure><h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><ul><li>export default 是模块的默认对外接口，只有一个，所以只能出现一次。</li><li>export default 只能直接输出，不能先定义后导出。</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>通过两者导出的对象，导入时也存在写法上的差别。</p><p>1、export 导出的对象，导入时写法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;i, myFun&#125;</span><br></pre></td></tr></table></figure><p>2、export default 导出的对象，导入时写法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import 变量名 from ‘模块’</span><br><span class="line"></span><br><span class="line">模块只有一个默认的导出的接口</span><br><span class="line"></span><br><span class="line">所以只有一个对象被导出</span><br><span class="line"></span><br><span class="line">导出的对象可以自定义一个变量名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> export </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css实现垂直居中</title>
      <link href="/2021/12/19/css%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/2021/12/19/css%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="设置垂直居中的-7-种方案"><a href="#设置垂直居中的-7-种方案" class="headerlink" title="设置垂直居中的 7 种方案"></a>设置垂直居中的 7 种方案</h2><h3 id="设定行高（line-height）"><a href="#设定行高（line-height）" class="headerlink" title="设定行高（line-height）"></a>设定行高（line-height）</h3><p>设定行高是垂直居中最简单的方案，适用于”单行”的”行内元素”（inline、inline-block），例如单行的标题，或是已经设为 inline-block 属性的 div，若将 inline-height 设成和高度一样的数值，则内容的行内元素就会被垂直居中。\</p><blockquote><p>为什么必须要单行的行内元素呢?<br>因为多行元素时，两行之间的行间距会过大，就不会如期望所示。</p></blockquote><h3 id="添加伪元素-beford、-after"><a href="#添加伪元素-beford、-after" class="headerlink" title="添加伪元素(::beford、::after)"></a>添加伪元素(::beford、::after)</h3><p>css 中的 vertical-align 属性，这个属性是实现垂直居中，到那时是指内部元素相对之间的垂直居中，并不是相对于父元素高度的垂直居中。<br>如果其中有一个元素的高度为 100%，那么其余元素就会相对于父元素实现垂直居中。<br>因此我们用到伪元素::before 和::after 添加到 div 中，使”伪”div 高度为 100%，div 的 display 属性为 inlink-block，因为 vertical-align:middle；这个属性是针对与行内元素的。div 本身使 block，所以作出一些修改。\</p><h3 id="clac-动态计算"><a href="#clac-动态计算" class="headerlink" title="clac 动态计算"></a>clac 动态计算</h3><h3 id="使用表格或假装表格"><a href="#使用表格或假装表格" class="headerlink" title="使用表格或假装表格"></a>使用表格或假装表格</h3><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><h3 id="使用弹性盒子（flex）"><a href="#使用弹性盒子（flex）" class="headerlink" title="使用弹性盒子（flex）"></a>使用弹性盒子（flex）</h3>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垂直居中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css实现垂直水平居中的常用方法</title>
      <link href="/2021/12/11/css%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/"/>
      <url>/2021/12/11/css%E5%AE%9E%E7%8E%B0%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>CSS实现垂直水平居中，这是之前面试时遇到的问题，也是开发时经常遇到的。总结一下常用方法</p><p>开始前先准备一些元素：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span> html + css <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了便于观察效果，加上一些样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>: <span class="number">#76b852</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line"> <span class="attribute">background-color</span>: <span class="number">#34C2A9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="垂直水平居中"><a href="#垂直水平居中" class="headerlink" title="垂直水平居中"></a>垂直水平居中</h2><ol><li>flex 方案</li><li>grid 方案</li><li>absolute + transform</li><li>absolute + calc</li><li>absolute + 负 margin</li><li>absolute + margin: auto</li><li>writing-mode</li></ol><h3 id="flex-方案"><a href="#flex-方案" class="headerlink" title="flex 方案"></a>flex 方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里引用复用代码  */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line"> <span class="attribute">display</span>: flex;</span><br><span class="line"> <span class="attribute">justify-content</span>: center;    <span class="comment">/* 水平居中 */</span></span><br><span class="line"> <span class="attribute">align-items</span>: center;        <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种用法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里引用复用代码  */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span>&#123;</span><br><span class="line">   <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">   <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：不需要固定居中元素的宽高</p><p>兼容性：</p><ul><li>IE10+，Chrome4+，Firefox2+</li><li>Android 2.3+，ios6+</li></ul><h3 id="grid-方案"><a href="#grid-方案" class="headerlink" title="grid 方案"></a>grid 方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里引用复用代码  */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span>&#123;</span><br><span class="line">   <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">   justify-self: center;   <span class="comment">/*  水平居中  */</span></span><br><span class="line">   <span class="attribute">align-self</span>: center;     <span class="comment">/*  垂直居中  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种用法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里引用复用代码  */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">   <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">   <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案的兼容性比 flex 差一点，同样的根据自己业务根据兼容情况选择使用。</p><p>优点：不需要固定居中元素的宽高。</p><p>兼容性：</p><ul><li>IE10+，Chrome57+，Firefox52+</li><li>Android6+，ios10.3+</li></ul><h3 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h3><p>css3中新增的 <code>transform</code> ，其 <code>translate</code> 属性是根据元素自身计算的。例如：设置 <code>transform：translateX(-50%);</code>， 元素会向左偏移自身宽度的一半。根据这一特性，很容易实现元素的居中：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里引用复用代码  */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">          <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">          <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：不需要固定居中元素的宽高</p><p>兼容性：</p><ul><li>IE9+，Chrome4+，Firefox3.5+</li><li>Android3+，ios6+</li></ul><h3 id="absolute-负-margin"><a href="#absolute-负-margin" class="headerlink" title="absolute + 负 margin"></a>absolute + 负 margin</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里引用复用代码  */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">   <span class="comment">/* margin-top = 1/2 自身高度</span></span><br><span class="line"><span class="comment">     margin-left = 1/2 自身宽度 */</span></span><br><span class="line">   <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">   <span class="attribute">margin-top</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点： 需要知道固定居中元素的宽高</p><p>兼容性：</p><ul><li>IE6+，Chrome4+，Firefox2+</li><li>Android2.3+，iOS6+</li></ul><h3 id="absolute-margin-auto"><a href="#absolute-margin-auto" class="headerlink" title="absolute + margin: auto"></a>absolute + margin: auto</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这里引用复用代码  */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">   <span class="attribute">position</span>: absolute;</span><br><span class="line">   <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方案的原理是：使用了 css 中的定位属性(auto, fixed等)，如果 <code>left</code> 设置了具体值，没有设置 <code>right</code>  和 <code>width</code> ，那么就会自动计算，把剩余的空间分配给 <code>right</code> 和 <code>width</code>。 如果<code>left</code> 、<code>right</code> 和 <code>width </code>都设置了具体值，并且没有沾满横向空间，那么剩余空间会处于待分配状态，此时设置 <code>margin: auto; </code> 意味着把剩余的空间分配给了 <code>margin</code> ，并且左右均分，所以实现水平居中，垂直方向同理。</p><p>但是要知道该方法的副作用：</p><ul><li><code>left: 0;  right: 0;</code> 相当于 <code>width: 100%;</code></li><li><code>top: 0; bottom: 0;</code> 相当于 <code>height: 100%;</code></li></ul><p>缺点：需要固定居中元素的宽高，否则其宽高会被设为 <code>100% </code> (副作用)。</p><p>兼容性：</p><ul><li>IE6+，Chrome4+，Firefox2+</li><li>Android2.3+，iOS6+</li></ul>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垂直水平居中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中document.write和innerHTML区别</title>
      <link href="/2021/12/09/js%E4%B8%ADdocument-write%E5%92%8CinnerHTML%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/12/09/js%E4%B8%ADdocument-write%E5%92%8CinnerHTML%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>document.write</strong>是直接写入到页面的内容流，如果在写之前没有调用document.open，浏览器会自动open。每次写完关闭之后重新调用该函数，<strong>会导致页面被重写</strong>。</p><p><strong>innerHTML</strong>是DOM页面元素的属性，代表该元素的html内容。你可以精确到某一个具体的元素来进行更改。如果想修改document的内容，则需要修改document.documentElement.innerElement。 innerHTML将内容写入某个DOM节点，<strong>不会导致页面全部重绘</strong>。</p><hr><p>💠 innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。</p><hr><h2 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h2><ol><li><p>document.write 是DOM方法，向文档写入HTML表达式或JavaScript代码，可列出多个参数，参数被顺序添加到文档中 ；</p><p>innerHTML 是DOM属性，设置或返回调用元素开始结束标签之间的HTML元素。</p></li><li><p>两者都可向页面输出内容，innerHTML 比 document.write 更灵活。<br>当文档加载时调用document.write 直接向页面输出内容，文档加载结束后调用document.write 输出内容会重写整个页面。</p><p>通常按照两种的方式使用 document.write() 方法：</p><p>​    一是在使用该方在文档中输出 HTML，</p><p>​    二是在调用该方法的的窗口之外的窗口、框架中产生新文档（务必使用close关闭文档）。<br>在读模式下，innerHTML 属性返回与调用元素的所有子节点对应的HTML标记，在写模式下，innerHTML 会根据指定的值创建新的DOM树替换调用元素原先的所有子节点。</p></li><li><p>两者都可动态包含外部资源如JavaScript文件<br>通过 document.write 插入 script 元素会自动执行其中的脚本；<br>大多数浏览器中，通过 innerHTML 插入 script 元素并不会执行其中的脚本。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引用豆瓣图片资源无效</title>
      <link href="/2021/11/05/%E5%BC%95%E7%94%A8%E8%B1%86%E7%93%A3%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%97%A0%E6%95%88/"/>
      <url>/2021/11/05/%E5%BC%95%E7%94%A8%E8%B1%86%E7%93%A3%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E6%97%A0%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>引用豆瓣影视中的封面图片时经常显示资源不可用</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>豆瓣API请求是有限制要求的，约为每分钟40次，超过了限定次数后则限制为每分钟10次。所以，若网页上引用了大量的豆瓣图片，那么可能会加载不完全，尤其是刷新后，确定为同一源头发起的请求，大量图片都无法请求。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用图片缓存方法，使用 <code>https://images.weserv.nl/?url=</code> 在加上原来豆瓣图片的地址，即可访问。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//原来</span><br><span class="line">https://img9.doubanio.com/view/photo/m/public/p2677520025.webp</span><br><span class="line">//修改后</span><br><span class="line">https://images.weserv.nl/?url=img9.doubanio.com/view/photo/m/public/p2677520025.webp</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 引用资源无效 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3-grid</title>
      <link href="/2021/10/25/css3-grid/"/>
      <url>/2021/10/25/css3-grid/</url>
      
        <content type="html"><![CDATA[<p>如果说 ‘flex’ 布局是<strong>一维布局</strong>，那么 ‘grid’ 布局就是<strong>二维布局</strong>。 <code>flex</code> 布局一次只能处理一个维度的元素布局，一行或一列。<code>grid</code> 布局时将容器划分为了 “行” 和“ 列”，产生了一个个的网格，我们可以将王铬元素放在这些行和列相关的位置上，从而达到布局的目的。</p><h2 id="一、例："><a href="#一、例：" class="headerlink" title="一、例："></a>一、例：</h2><p>使用<em>grid-template-rows</em> 属性定义第一行高度为 200px，第二行高度为 400px。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item1&quot;</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item3&quot;</span>&gt;</span>three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item4&quot;</span>&gt;</span>four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item5&quot;</span>&gt;</span>five<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item6&quot;</span>&gt;</span>six<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item7&quot;</span>&gt;</span>seven<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item8&quot;</span>&gt;</span>eight<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> .container &#123;</span><br><span class="line">        margin: 100px;</span><br><span class="line">        display: grid;</span><br><span class="line">        grid-template-columns: repeat(4,200px);</span><br><span class="line">        grid-gap: 40px;</span><br><span class="line">        grid-auto-rows: 200px 400px;</span><br><span class="line">   &#125;</span><br><span class="line">    .item1 &#123;</span><br><span class="line">        background: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line">    .item2 &#123;</span><br><span class="line">        background: #FF6699;</span><br><span class="line">    &#125;</span><br><span class="line">    .item3 &#123;</span><br><span class="line">        background: darkseagreen;</span><br><span class="line">    &#125;</span><br><span class="line">    .item4 &#123;</span><br><span class="line">        background: orchid;</span><br><span class="line">    &#125;</span><br><span class="line">    .item5 &#123;</span><br><span class="line">        background: blanchedalmond;</span><br><span class="line">    &#125;</span><br><span class="line">    .item6 &#123;</span><br><span class="line">        background: aquamarine;</span><br><span class="line">    &#125;</span><br><span class="line">    .item7 &#123;</span><br><span class="line">        background: sandybrown;</span><br><span class="line">    &#125;</span><br><span class="line">    .item8 &#123;</span><br><span class="line">        background: lightslategrey;</span><br><span class="line">    &#125;</span><br><span class="line">    .container div&#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">        font-size: 200%;</span><br><span class="line">        color: #FFFFFF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/25/zAbTo6UYeZFlXLD.png" alt="image.png"></p><p>容器和项目：我们通过在元素上声明 <code>display：grid</code> 或 <code>display：inline-grid</code> 来创建一个网格容器。一旦我们这样做，这个元素的所有直系子元素将成为网格项目。比如上面的例子中 <code>.container</code> 所在的元素为一个网格容器，其直系子元素将成为网格项目。</p><p>网格轨道：<code>grid-template-columns</code> 和 <code>grid-template-rows</code> 属性来定义网格中的行和列。容器内部的水平区域称为行，垂直区域称为列。上图中 <code>one</code>、<code>two</code>、<code>three</code>、<code>four</code> 组成了一行，<code>one</code>、<code>five</code> 则是一列</p><p><img src="https://i.loli.net/2021/10/25/ZxG78XdFCS36W5b.png" alt="image.png"></p><p>网格单元：一个网格单元是在一个网格元素中最小的单位， 从概念上来讲其实它和表格的一个单元格很像。上图中 <code>One</code>、<code>Two</code>、<code>Three</code>、<code>Four</code>…都是一个个的网格单元</p><p>网格线：划分网格的线，称为”网格线”。应该注意的是，当我们定义网格时，我们定义的是网格轨道，而不是网格线。Grid 会为我们创建编号的网格线来让我们来定位每一个网格元素。m 列有 m + 1 根垂直的网格线，n 行有 n + 1 跟水平网格线。比如上图示例中就有 4 根垂直网格线。一般而言，是从左到右，从上到下，1，2，3 进行编号排序。当然也可以从右到左，从下到上，按照 -1，-2，-3…顺序进行编号排序</p><p><img src="https://i.loli.net/2021/10/25/l6NxdTtLDgAhiCW.png" alt="image.png"></p><h2 id="二、容器属性"><a href="#二、容器属性" class="headerlink" title="二、容器属性"></a>二、容器属性</h2><h3 id="1-display-属性"><a href="#1-display-属性" class="headerlink" title="1 display 属性"></a>1 display 属性</h3><p>通过在元素上声明 <code>display: grid;</code> 或 <code>display: inline-grid;</code> 来创建一个网格容器。声明 <code>display: grid</code> 则该容器是一个块级元素，设置成 <code>display: inline-grid</code> 则容器元素为行内元素。</p><h3 id="2-grid-template-columns-属性-和-grid-template-rows属性"><a href="#2-grid-template-columns-属性-和-grid-template-rows属性" class="headerlink" title="2 grid-template-columns 属性 和 grid-template-rows属性"></a>2 grid-template-columns 属性 和 grid-template-rows属性</h3><p><code>grid-template-columns</code> 属性设置列宽</p><p><code>grid-template-rows</code> 属性设置行高</p><p>这两个属性在 <code>Grid</code> 布局中尤为重要，它们的值是有多种多样的，而且它们的设置是比较相似的，下面针对 <code>grid-template-columns</code> 属性进行讲解</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="comment">/*  声明了三列，宽度分别为 200px 100px 300px */</span></span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">200px</span> <span class="number">100px</span> <span class="number">300px</span>;</span><br><span class="line">  grid-gap: <span class="number">5px</span>;</span><br><span class="line">  <span class="comment">/*  声明了两行，行高分别为 50px 50px  */</span></span><br><span class="line">  grid-template-rows: <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码表示列宽为200px 100px 300px，行高50px 50px</p><p><strong>repeat() 函数：</strong>可以简化重复的值。该函数接受两个参数，第一个参数是重复的次数，第二个参数是要重复的值。上述代码中行高是相同的，就可以通过repeat函数去实现。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="comment">/*  声明了三列，宽度分别为 200px 100px 300px */</span></span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">200px</span> <span class="number">100px</span> <span class="number">300px</span>;</span><br><span class="line">  grid-gap: <span class="number">5px</span>;</span><br><span class="line">  <span class="comment">/*  声明了两行，行高分别为 50px 50px  */</span></span><br><span class="line">  grid-template-rows: <span class="built_in">repeat</span>(<span class="number">2</span>,<span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>auto-fill 关键字：</strong>表示自动填充，让一行（或一列）中尽可能的容纳更多的单元格。<code>grid-template-columns: repeat(auto-fill, 200px)</code> 表示列宽是 200 px，但列的数量是不固定的，只要浏览器能够容纳得下，就可以放置元素，代码以及效果如下图所示：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(auto-fill, <span class="number">200px</span>);</span><br><span class="line">  grid-gap: <span class="number">5px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>fr 关键字：</strong><code>Grid</code> 布局还引入了一个另外的长度单位来帮助我们创建灵活的网格轨道。<code>fr</code> 单位代表网格容器中可用空间的一等份。<code>grid-template-columns: 200px 1fr 2fr</code> 表示第一个列宽设置为 200px，后面剩余的宽度分为两部分，宽度分别为剩余宽度的 1/3 和 2/3。代码以及效果如下图所示：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">200px</span> <span class="number">1</span>fr <span class="number">2</span>fr;</span><br><span class="line">  grid-gap: <span class="number">5px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>minmax() 函数：</strong>我们有时候想给网格元素一个最小和最大的尺寸，<code>minmax()</code> 函数产生一个长度范围，表示长度就在这个范围之中都可以应用到网格项目中。它接受两个参数，分别为最小值和最大值。<code>grid-template-columns: 1fr 1fr minmax(300px, 2fr)</code> 的意思是，第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。代码以及效果如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="built_in">minmax</span>(<span class="number">300px</span>, <span class="number">2</span>fr);</span><br><span class="line">  grid-gap: <span class="number">5px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>auto 关键字</strong>：由浏览器决定长度。通过 <code>auto</code> 关键字，我们可以轻易实现三列或者两列布局。<code>grid-template-columns: 100px auto 100px</code> 表示第一第三列为 100px，中间由浏览器决定长度，代码以及效果如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br><span class="line">  grid-gap: <span class="number">5px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-grid-row-gap-属性、grid-column-gap-属性以及-grid-gap-属性"><a href="#3-grid-row-gap-属性、grid-column-gap-属性以及-grid-gap-属性" class="headerlink" title="3 grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性"></a>3 <strong>grid-row-gap 属性、grid-column-gap 属性以及 grid-gap 属性</strong></h3><p><strong>grid-row-gap 属性</strong>、<strong>grid-column-gap 属性</strong>分别设置行间距和列间距。</p><p><strong>grid-gap 属性</strong>是两者的简写形式。</p><p><code>grid-row-gap: 10px</code> 表示行间距是 10px，<code>grid-column-gap: 20px</code> 表示列间距是 20px。</p><p><code>grid-gap: 10px 20px</code> 实现的效果是一样的</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br><span class="line">  grid-gap: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span><br><span class="line">  grid-<span class="attribute">auto</span>-rows: <span class="number">50px</span>;</span><br><span class="line">  grid-row-gap: <span class="number">10px</span>;</span><br><span class="line">  grid-column-rows: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两种写法效果相同。</p><h3 id="4-grid-template-areas-属性"><a href="#4-grid-template-areas-属性" class="headerlink" title="4 grid-template-areas 属性"></a>4 <a name="here"   style="text-decoration: none;color: #000">grid-template-areas 属性</a></h3><p><strong>grid-template-areas 属性</strong>用于定义区域，一个区域由一个或多个单元格组成。</p><p>一般这个属性跟网格元素的 <code>grid-area</code> 一起使用，我们在这里一起介绍。 <code>grid-area</code> 属性指定项目放在哪一个区域</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-gap: <span class="number">10px</span>;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="number">120px</span>  <span class="number">200px</span>  <span class="number">120px</span>;</span><br><span class="line">    grid-template-areas:</span><br><span class="line">        <span class="string">&quot;. header&quot;</span></span><br><span class="line">        <span class="string">&quot;sidebar content&quot;</span></span><br><span class="line">        <span class="string">&quot;. footer&quot;</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码表示划分出6个单元格，其中值得注意的是 <code>.</code> 表示空的单元格，即没有被用到的。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    grid-area: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    grid-area: content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">    grid-area: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">    grid-area: footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码表示将类 <code>.sidebar</code>、<code>.content</code>、<code>.header</code>、<code>.footer</code> 所在的元素放在 <code>grid-template-areas</code> 定义的 <code>sidebar</code>、<code>content</code>、<code>header</code>、<code>footer</code> 区域中。</p><p><img src="https://i.loli.net/2021/10/26/3iHgEnQK427AlOT.png" alt="image.png"></p><h3 id="5-grid-auto-flow-属性"><a href="#5-grid-auto-flow-属性" class="headerlink" title="5 grid-auto-flow 属性"></a>5 grid-auto-flow 属性</h3><p><strong>grid-auto-flow 属性</strong>控制着自动布局算法怎样运作，精确指定在网格中被自动布局的元素怎样排列。</p><ul><li>start - 对齐单元格的起始边缘</li><li>column - 通过填充每一列来放置项目</li><li>dense - 放置项目以填充网格中的任何孔。</li><li>row dense - 通过填充每一行来放置项目，并填充网格中的任何孔。</li><li>column dense - 通过填充每一列来放置项目，并填充网格中的任何孔。</li></ul><h3 id="6-justify-items-属性、align-items-属性以及-place-items-属性"><a href="#6-justify-items-属性、align-items-属性以及-place-items-属性" class="headerlink" title="6 justify-items 属性、align-items 属性以及 place-items 属性"></a>6 justify-items 属性、align-items 属性以及 place-items 属性</h3><p><strong>justify-items 属性</strong>设置单元格内容的水平位置（左中右）</p><p><strong>align-items 属性</strong>设置单元格的垂直位置（上中下）</p><p><strong>place-items 属性</strong>是 <code>justify-items</code>属性 和 <code>align-items</code>属性的简写，它 允许在相关布局中可以同时沿着块级和内联方向对齐元素。</p><p>下面以 justify-items 属性为例进行讲解，align-items 属性同理，只是方向为垂直方向。它们都有如下属性：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  justify-items: start | end | center | stretch;</span><br><span class="line">  <span class="attribute">align-items</span>: start | end | center | stretch;</span><br><span class="line">  place-items: start | end | center | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>start：对齐单元格的起始边缘</li><li>end：对齐单元格的结束边缘</li><li>center：单元格内部居中</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）</li></ul><h3 id="7-justify-content-属性、align-content-属性以及-place-content-属性"><a href="#7-justify-content-属性、align-content-属性以及-place-content-属性" class="headerlink" title="7 justify-content 属性、align-content 属性以及 place-content 属性"></a>7 justify-content 属性、align-content 属性以及 place-content 属性</h3><p><strong>justify-content 属性</strong>是整个内容区域在容器里面的水平位置（左中右）</p><p><strong>align-content 属性</strong>是整个内容区域的垂直位置（上中下）。</p><p>它们都有如下的属性值。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">  <span class="attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>start - 对齐容器的起始边框</li><li>end - 对齐容器的结束边框</li><li>center - 容器内部居中</li><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</li><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔</li><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</li><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器</li></ul><h3 id="8-grid-auto-columns-属性和-grid-auto-rows-属性"><a href="#8-grid-auto-columns-属性和-grid-auto-rows-属性" class="headerlink" title="8 grid-auto-columns 属性和 grid-auto-rows 属性"></a>8 grid-auto-columns 属性和 grid-auto-rows 属性</h3><p>在学习 <code>grid-auto-columns</code> 属性和 <code>grid-auto-rows</code> 属性之前，先了解一下隐式和显式网格的概念</p><p><strong>隐式和显式网格</strong>：显式网格包含了你在 <code>grid-template-columns</code> 和 <code>grid-template-rows</code> 属性中定义的行和列。如果你在网格定义之外又放了一些东西，或者因为内容的数量而需要的更多网格轨道的时候，网格将会在隐式网格中创建行和列</p><p>假如有多余的网格（也就是上面提到的隐式网格），那么它的行高和列宽可以根据 <code>grid-auto-columns</code> 属性和 <code>grid-auto-rows</code> 属性设置。它们的写法和<code>grid-template-columns</code> 和 <code>grid-template-rows</code> 完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">200px</span> <span class="number">100px</span>;</span><br><span class="line"><span class="comment">/*  只设置了两行，但实际的数量会超出两行，超出的行高会以 grid-auto-rows 算 */</span></span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-gap: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">  grid-<span class="attribute">auto</span>-rows: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-template-columns</code> 属性和 <code>grid-template-rows</code> 属性只是指定了两行两列，但实际有九个元素，就会产生隐式网格。通过 <code>grid-auto-rows</code> 可以指定隐式网格的行高为 50px</p><h2 id="三、项目属性"><a href="#三、项目属性" class="headerlink" title="三、项目属性"></a>三、项目属性</h2><h3 id="1-grid-column-start-属性、grid-column-end-属性、grid-row-start-属性以及grid-row-end-属性"><a href="#1-grid-column-start-属性、grid-column-end-属性、grid-row-start-属性以及grid-row-end-属性" class="headerlink" title="1 grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及grid-row-end 属性"></a>1 grid-column-start 属性、grid-column-end 属性、grid-row-start 属性以及grid-row-end 属性</h3><p>可以指定网格项目所在的四个边框，分别定位在哪根网格线，从而指定项目的位置</p><ul><li>grid-column-start 属性：左边框所在的垂直网格线</li><li>grid-column-end 属性：右边框所在的垂直网格线</li><li>grid-row-start 属性：上边框所在的水平网格线</li><li>grid-row-end 属性：下边框所在的水平网格线</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    grid-template-<span class="attribute">columns</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">1</span>fr);</span><br><span class="line">    grid-gap: <span class="number">20px</span>;</span><br><span class="line">    grid-<span class="attribute">auto</span>-rows: <span class="built_in">minmax</span>(<span class="number">100px</span>, auto);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">    grid-column-start: <span class="number">1</span>;</span><br><span class="line">    grid-column-end: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#8DC26F</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">    grid-column-start: <span class="number">2</span>;</span><br><span class="line">    grid-column-end: <span class="number">4</span>;</span><br><span class="line">    grid-row-start: <span class="number">1</span>;</span><br><span class="line">    grid-row-end: <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/*   如果有重叠，就使用 z-index */</span></span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#FF6699</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.three</span> &#123;</span><br><span class="line">    grid-column-start: <span class="number">3</span>;</span><br><span class="line">    grid-column-end: <span class="number">4</span>;</span><br><span class="line">    grid-row-start: <span class="number">2</span>;</span><br><span class="line">    grid-row-end: <span class="number">6</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.four</span> &#123;</span><br><span class="line">    grid-column-start: <span class="number">1</span>;</span><br><span class="line">    grid-column-end: <span class="number">2</span>;</span><br><span class="line">    grid-row-start: <span class="number">2</span>;</span><br><span class="line">    grid-row-end: <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightslategrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.five</span> &#123;</span><br><span class="line">    grid-column-start: <span class="number">2</span>;</span><br><span class="line">    grid-column-end: <span class="number">2</span>;</span><br><span class="line">    grid-row-start: <span class="number">2</span>;</span><br><span class="line">    grid-row-end: <span class="number">4</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.six</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: darkseagreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seven</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: aliceblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.eight</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: antiquewhite;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nine</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ten</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: lightseagreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#1a1a1a</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> dashed <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，类 <code>.two</code> 所在的垂直网格线是从2到4，水平网格线是从1到2。</p><p><img src="https://i.loli.net/2021/10/26/ckeWI2RKaOyQoVb.png"></p><h3 id="2-grid-area-属性"><a href="#2-grid-area-属性" class="headerlink" title="2 grid-area 属性"></a>2 grid-area 属性</h3><p><code>grid-area</code> 属性指定项目放在哪一个区域，在上面介绍 <a href="#here"   style="text-decoration: none; color: 8DC26F">grid-template-areas</a> 的时候有提到过.</p><h3 id="3-justify-self-属性、align-self-属性以及-place-self-属性"><a href="#3-justify-self-属性、align-self-属性以及-place-self-属性" class="headerlink" title="3 justify-self 属性、align-self 属性以及 place-self 属性"></a>3 justify-self 属性、align-self 属性以及 place-self 属性</h3><p><strong>justify-self 属性</strong>设置单元格内容的水平位置（左中右），跟 <code>justify-items</code> 属性的用法完全一致，但只作用于单个项目</p><p><strong>align-self 属性</strong>设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目</p><ul><li><p>start：对齐单元格的起始边缘</p></li><li><p>end：对齐单元格的结束边缘</p></li><li><p>center：单元格内部居中</p></li><li><p>stretch：拉伸，占满单元格的整个宽度（默认值）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网格布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css3-flex</title>
      <link href="/2021/10/25/css3-flex/"/>
      <url>/2021/10/25/css3-flex/</url>
      
        <content type="html"><![CDATA[<p><strong>网页布局</strong>（layout）是 css 的一个重点应用。<br>布局的传统解决方案，基于盒装模型，依赖 display 属性 + position 属性 + float 属性。但对于某些特殊布局来说非常不方便，比如，<code>垂直居中</code>就不易实现。于是在2009年，W3C提出了一种新的方案——Flex布局，可以完整、简便、响应式的实现各种页面布局。目前已经得到了所有浏览器的支持，也意味着可以很安全的使用这项功能。下面介绍一下flex布局的用法。</p><h2 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为 “弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任意一个容器都可以指定为flex 布局。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用Flex布局。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>​    设为 Flex布局后，子元素的float、clear和vertical-align属性将失效、</p></blockquote><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用Flex布局的元素，称为Flex容器，简称“容器”。它的所有子元素自动成为容器成员，称为 Flex项目（flex item），简称“项目”。</p><p><img src="https://i.loli.net/2021/10/25/J6dCsT3IEqRBfXo.png" alt="项目.png"></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴开始的位置（与边框的交叉点）叫做 main start，结束的位置叫做 main end；交叉轴的开始位置叫做 cross start，结束的位置叫做 cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴控件叫做 main size，占据的交叉轴空间叫做 cross size。</p><h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>flex 有以下 6 个属性设置在容器上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- flex-direction</span><br><span class="line">- flex-wrap</span><br><span class="line">- flex-flow</span><br><span class="line">- justify-content</span><br><span class="line">- align-items</span><br><span class="line">- align-content</span><br></pre></td></tr></table></figure><h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-direction: row | row-reverse | colum | colum-reverse;</span><br><span class="line"></span><br><span class="line">- row（默认值）：主轴为水平方向，起点在左端。</span><br><span class="line"></span><br><span class="line">- row-reverse：主轴为水平方向，起点在右端。</span><br><span class="line"></span><br><span class="line">- column：主轴为垂直方向，起点在上沿。</span><br><span class="line"></span><br><span class="line">- column-reverse：主轴为垂直方向，起点在下沿。</span><br></pre></td></tr></table></figure><h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line"></span><br><span class="line"> - nowrap（默认）：不换行。</span><br><span class="line"></span><br><span class="line"> - wrap：换行，第一行在上方。</span><br><span class="line"> </span><br><span class="line">  - wrap-reverse：换行，第一行在下方。</span><br></pre></td></tr></table></figure><h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure><h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p>justify-content属性定义了项目在主轴上的对齐方式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line"></span><br><span class="line"> - flex-start（默认值）：左对齐</span><br><span class="line"></span><br><span class="line"> - flex-end：右对齐</span><br><span class="line"></span><br><span class="line"> - center： 居中</span><br><span class="line"></span><br><span class="line"> - space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line"></span><br><span class="line"> - space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span><br></pre></td></tr></table></figure><h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p>align-items属性定义项目在交叉轴上如何对齐。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line"></span><br><span class="line"> - flex-start：交叉轴的起点对齐。</span><br><span class="line"></span><br><span class="line"> - flex-end：交叉轴的终点对齐。</span><br><span class="line"></span><br><span class="line"> - center：交叉轴的中点对齐。</span><br><span class="line"></span><br><span class="line"> - baseline: 项目的第一行文字的基线对齐。</span><br><span class="line"></span><br><span class="line"> - stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure><h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line"></span><br><span class="line"> - flex-start：与交叉轴的起点对齐。</span><br><span class="line"> </span><br><span class="line"> - flex-end：与交叉轴的终点对齐。</span><br><span class="line"></span><br><span class="line"> - center：与交叉轴的中点对齐。</span><br><span class="line"> </span><br><span class="line"> - space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span><br><span class="line"> </span><br><span class="line"> - space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span><br><span class="line"> </span><br><span class="line"> - stretch（默认值）：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure><h2 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h2><h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
      
      
      <categories>
          
          <category> css3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 弹性布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript异步编程</title>
      <link href="/2021/10/18/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/10/18/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="异步的概念"><a href="#异步的概念" class="headerlink" title="异步的概念"></a>异步的概念</h3><p>异步（Asynchronous，async）是与同步（Synchronous，sync）相对的概念。</p><p>在我们学习的传统单线程编程中，程序运行是同步的（同步不意味着所有步骤同时运行，而是指步骤在一个控制流序列中按顺序执行）。而异步的概念则是不保证同步的概念，也就是说，一个异步过程的执行将不再与原有的序列有顺序关系。</p><p>简单来讲就是：同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效率更高。</p><p>以上是关于异步的概念的解释，接下来我们通俗地解释一下异步：异步就是主线程发射一个子线程来完成任务。</p><p><img src="https://i.loli.net/2021/10/18/mGHLwZvysTUai3r.png" alt="异步编程.png"></p><h3 id="什么时候用异步编程"><a href="#什么时候用异步编程" class="headerlink" title="什么时候用异步编程"></a>什么时候用异步编程</h3><p>在前端编程中（后端也存在这种情况），我们处理一些简短、快捷的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。</p><p>现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下时整个页面将失去响应。</p><p>为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户觉察的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步人的处理结果。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数就是一个函数，它是在我们启动一个异步任务的时候告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，它会善始善终。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;Bile!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(print, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>这段程序中的 setTimeout 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 “print”，在命令行输出 “Time out”。</p><p>当然，JavaScript 语法十分友好，我们不必单独定义一个函数 print ，我们常常将上面的程序写成：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;Bile!&quot;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>既然 setTimeout 会在子线程中等待 3 秒，在 setTimeout 函数执行之后主线程并没有停止，所以：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo1&quot;</span>).innerHTML=<span class="string">&quot;Bile-1!&quot;</span>;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;demo2&quot;</span>).innerHTML=<span class="string">&quot;Bile-2!&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure><p>程序的执行结果是：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bile-1!</span><br><span class="line">Bile-2!</span><br></pre></td></tr></table></figure><hr><h3 id="异步-AJAX"><a href="#异步-AJAX" class="headerlink" title="异步 AJAX"></a>异步 AJAX</h3><p>除了 setTimeout 函数以外，异步回调广泛应用于 AJAX 编程。有关于 AJAX 详细请参见：<a href="https://www.runoob.com/ajax/ajax-tutorial.html">https://www.runoob.com/ajax/ajax-tutorial.html</a></p><p>XMLHttpRequest 常常用于请求来自远程服务器上的 XML 或 JSON 数据。一个标准的 XMLHttpRequest 对象往往包含多个回调：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"> </span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 输出接收到的文字数据</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=xhr.responseText;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML=<span class="string">&quot;请求出错&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 发送异步 GET 请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://www.runoob.com/try/ajax/ajax_info.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>XMLHttpRequest 的 onload 和 onerror 属性都是函数，分别在它请求成功和请求失败时被调用。如果你使用完整的 jQuery 库，也可以更加优雅的使用异步 AJAX：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.get(<span class="string">&quot;https://www.runoob.com/try/ajax/demo_test.php&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data,status</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;数据: &quot;</span> + data + <span class="string">&quot;\n状态: &quot;</span> + status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步编程 </tag>
            
            <tag> 异步ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript命名空间</title>
      <link href="/2021/10/13/JavaScript%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
      <url>/2021/10/13/JavaScript%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h4 id="1-命名空间是什么？"><a href="#1-命名空间是什么？" class="headerlink" title="1 命名空间是什么？"></a>1 命名空间是什么？</h4><p>命名空间指的是一种排序机制，以便在“空间”中只有一个相同的名称。</p><p>空间就像一种容器。</p><p>例如，名字“汤姆” 可能指的是多个人，但通过为每个姓氏创建命名空间，我们可以区分哪个“汤姆”。</p><p>事实上，你可以知道到命名空间“上官”中的“汤姆”和“欧阳”中的“汤姆”是不同的人。</p><h4 id="2-使用命名空间的好处"><a href="#2-使用命名空间的好处" class="headerlink" title="2 使用命名空间的好处"></a>2 使用命名空间的好处</h4><p>命名空间的主要目的是避免名称冲突</p><p>对于小规模程序，使用命名空间的好处可能不多，但是，某种大规模的程序可能与其他程序、服务器有关。</p><p>在这种情况下，使用命名空间可以减轻程序负担。</p><p>由于可以防止名称冲突引起的问题，我们可以消除不必要的处理。</p><h4 id="3-如何使用命名空间"><a href="#3-如何使用命名空间" class="headerlink" title="3 如何使用命名空间"></a>3 如何使用命名空间</h4><p>先看一个简单是命名空间实例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addition</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplication</span>(<span class="params">num1,num2</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num1*num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> operation = addition(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(operation)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行结果为 15</span><br></pre></td></tr></table></figure><p>上面的示例中，首先定义了一个加法函数 addtion 和一个乘法函数 mutiplication 。</p><p>然后添加结果存储在全局变量种，并显示在控制台。</p><p>传递函数所添加的参数市5和10，因此控制台上显示15.</p><p>上述示例中所有内容作为全局变量存在。</p><p>因此，如果全局范围种存在具有相同名称的函数和变量，则会导致冲突。</p><p>接下来引入命名空间的写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> MYFUNCTIONS = &#123;</span><br><span class="line"> <span class="attr">addition</span>: <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1+num2;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">multiplication</span>: <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1*num2;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> operation = MYFUNCTIONS.addition(<span class="number">5</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(operation)</span><br></pre></td></tr></table></figure><p>这里唯一定义的全局变量是一个大写的 MYFUNCTIONS 变量。</p><p>在MYFUNCTIONS种 ，我们定义了加法函数和乘法函数。</p><p>这样我们创建了一个命名空间，使用语法：MYFUNCTIONS.函数名。</p><p>通过 MYFUNCTIONS.addition(5,10); 来调用函数。</p><p>结果与上一实例相同。</p><h4 id="4-如何对命名空间进行分层"><a href="#4-如何对命名空间进行分层" class="headerlink" title="4 如何对命名空间进行分层"></a>4 如何对命名空间进行分层</h4><p><code>层次化</code> 命名空间可以分层管理更多函数和变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPPLICATION = &#123;</span><br><span class="line"> <span class="attr">OPERATIONS</span>: &#123;</span><br><span class="line">  <span class="attr">addition</span>: <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1+num2;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="attr">multiplication</span>: <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> num1*num2;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> <span class="attr">OTHER</span>: &#123;</span><br><span class="line">  <span class="attr">show</span>: <span class="function"><span class="keyword">function</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;Your numbers are &quot;</span> + num1 + <span class="string">&quot; and &quot;</span> + num2);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYAPPLICATION.OTHER.show(<span class="number">5</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行结果为 Your numbers are 5 and 10</span><br></pre></td></tr></table></figure><p>上述实例中，我们将唯一的全局变量 MYAPPLICATION 分成多个空间</p><p>在 OPERATIONS 空间添加了 addtion 函数和 multiplication 函数，在OTHER空间中包含了新的show。</p><p>在空间中创建控件使得分层和生成简洁代码变得更容易。</p>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分层管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript自执行函数</title>
      <link href="/2021/10/13/JavaScript%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2021/10/13/JavaScript%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-自执行函数是什么"><a href="#1-自执行函数是什么" class="headerlink" title="1 自执行函数是什么"></a>1 自执行函数是什么</h2><p>自执行函数也是<strong>立执行函数</strong></p><p>是将函数的声明和调用合并在一起</p><h2 id="2-自执行函数存在的意义"><a href="#2-自执行函数存在的意义" class="headerlink" title="2 自执行函数存在的意义"></a>2 自执行函数存在的意义</h2><p>自执行函数是为了封装</p><p>不需要将普通的函数刻意的封装为自执行函数</p><h3 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h3><p>目的：</p><p>​    通过命名空间（本质是一个普通对象）或自执行函数实现程序的基本封装，提升程序的可维护度</p><blockquote><p>大型项目中设计的代码量是惊人的，然而代码并非一成不变，随时会面临升级或者 bug 修复，因此需要良好的代码组织管理的方式，才能保证将来维护代码时更加的高效</p></blockquote><h3 id="2-2-命名空间-namespace"><a href="#2-2-命名空间-namespace" class="headerlink" title="2.2 命名空间(namespace)"></a>2.2 命名空间(namespace)</h3><p>了解命名空间走这里 👉🏻<a href="../JavaScript%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">JavaScript命名空间</a>👈🏻</p><h2 id="3-自执行函数的常见写法"><a href="#3-自执行函数的常见写法" class="headerlink" title="3 自执行函数的常见写法"></a>3 自执行函数的常见写法</h2><p>两种写法不同于第二个括号的位置</p><h3 id="3-1-写法一"><a href="#3-1-写法一" class="headerlink" title="3.1 写法一"></a>3.1 写法一</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 代码块</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line">第一步 </span><br><span class="line">   先写两个():</span><br><span class="line">   ()()</span><br><span class="line">   第一个()可以这样理解</span><br><span class="line">   例如：<span class="number">1</span> + <span class="number">1</span> * <span class="number">3</span>  我想先执行 <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">   (<span class="number">1</span> + <span class="number">1</span>) * <span class="number">3</span> 这样就实现了先执行()内的，改变了执行顺序</span><br><span class="line">   把函数放进()去</span><br><span class="line">   (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">第二步</span><br><span class="line">   (functon () &#123;&#125;) ()</span><br><span class="line">   第一个()可以看作一个函数声明 后面这个()则是函数的调用</span><br></pre></td></tr></table></figure><h3 id="3-2-写法二"><a href="#3-2-写法二" class="headerlink" title="3.2 写法二"></a>3.2 写法二</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 代码块</span></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="comment">//解释</span></span><br><span class="line">  第一步 将函数放在()内</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line">  第二部 在函数的&#123;&#125; 后面加一个() 表示调用</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; ())</span><br></pre></td></tr></table></figure><h2 id="4-自执行函数的传参"><a href="#4-自执行函数的传参" class="headerlink" title="4 自执行函数的传参"></a>4 自执行函数的传参</h2><h3 id="4-1-写法一"><a href="#4-1-写法一" class="headerlink" title="4.1 写法一"></a>4.1 写法一</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形参在function旁边的()  与普通函数一样</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y</span><br><span class="line"> <span class="comment">// 实参在最后的()中 </span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-写法二"><a href="#4-2-写法二" class="headerlink" title="4.2 写法二"></a>4.2 写法二</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形参在function旁边的()  与普通函数一样</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x + y</span><br><span class="line"> <span class="comment">// 实参在最后的()中   </span></span><br><span class="line">&#125;(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>​    两种写法的括号位置是不一样的</p></blockquote><h2 id="5-自执行函数的总结"><a href="#5-自执行函数的总结" class="headerlink" title="5 自执行函数的总结"></a>5 自执行函数的总结</h2><ol><li>自执行函数与普通函数无本质区别，只是简化了普通函数的步骤</li><li>自执行函数与普通函数一样，同样具有形参与实参</li><li>自执行函数实际是函数表达式，属于高阶函数</li><li>自执行函数一般使用匿名函数（因为函数名外面无法获取）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样写已经自执行了</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;我是fn函数&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在外面去调用自执行函数fn()</span></span><br><span class="line">fn()  <span class="comment">// 控制台打印 fn is not defined  未定义就是没有找到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在函数内部调用具名的自执行函数</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;我是fn函数&#x27;</span>)</span><br><span class="line">  fn()  <span class="comment">// 这样的后果是持续执行  </span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json文件结构</title>
      <link href="/2021/10/10/package-json%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2021/10/10/package-json%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>如果使用 JavaScript、或者曾经与 JavaScript 项目、Node.js 或前端项目进行过交互，则肯定会遇到过 <code>package.json</code> 文件。</p><p>它有什么用途？应该了解它的什么，可以使用它完成哪些有趣的事情？</p><p><code>package.json</code> 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 <code>npm</code> 和 <code>yarn</code> 存储所有已安装软件包的名称和版本的地方。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>这是一个示例的 package.json 文件：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>它是空的！ 对于应用程序，<code>package.json</code> 文件中的内容没有固定的要求。 唯一的要求是必须遵守 JSON 格式，否则，尝试以编程的方式访问其属性的程序则无法读取它。</p><p>如果要构建要在 <code>npm</code> 上分发的 Node.js 软件包，则必须具有一组可帮助其他人使用它的属性。 稍后会详细介绍。</p><p>这是另一个 package.json：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;nodejs_cn&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它定义了 <code>name</code> 属性，用于告知应用程序或软件包的名称。</p><p>这是一个更复杂的示例，该示例是从 Vue.js 应用程序示例中提取的：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;A Vue.js project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;src/main.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;jest --config test/unit/jest.conf.js --coverage&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;npm run unit&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js,.vue src test/unit&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.5.2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;autoprefixer&quot;</span>: <span class="string">&quot;^7.1.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-core&quot;</span>: <span class="string">&quot;^6.22.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-eslint&quot;</span>: <span class="string">&quot;^8.2.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-helper-vue-jsx-merge-props&quot;</span>: <span class="string">&quot;^2.0.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-jest&quot;</span>: <span class="string">&quot;^21.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span>: <span class="string">&quot;^7.1.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-plugin-dynamic-import-node&quot;</span>: <span class="string">&quot;^1.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-plugin-syntax-jsx&quot;</span>: <span class="string">&quot;^6.18.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-plugin-transform-es2015-modules-commonjs&quot;</span>: <span class="string">&quot;^6.26.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-plugin-transform-runtime&quot;</span>: <span class="string">&quot;^6.22.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-plugin-transform-vue-jsx&quot;</span>: <span class="string">&quot;^3.5.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-preset-env&quot;</span>: <span class="string">&quot;^1.3.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-preset-stage-2&quot;</span>: <span class="string">&quot;^6.22.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;chalk&quot;</span>: <span class="string">&quot;^2.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;copy-webpack-plugin&quot;</span>: <span class="string">&quot;^4.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;css-loader&quot;</span>: <span class="string">&quot;^0.28.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span>: <span class="string">&quot;^4.15.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-config-airbnb-base&quot;</span>: <span class="string">&quot;^11.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;eslint-friendly-formatter&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;eslint-import-resolver-webpack&quot;</span>: <span class="string">&quot;^0.8.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;eslint-loader&quot;</span>: <span class="string">&quot;^1.7.1&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;eslint-plugin-import&quot;</span>: <span class="string">&quot;^2.7.0&quot;</span>,</span><br><span class="line"> <span class="attr">&quot;eslint-plugin-vue&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;extract-text-webpack-plugin&quot;</span>: <span class="string">&quot;^3.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;file-loader&quot;</span>: <span class="string">&quot;^1.1.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;friendly-errors-webpack-plugin&quot;</span>: <span class="string">&quot;^1.6.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span>: <span class="string">&quot;^2.30.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jest&quot;</span>: <span class="string">&quot;^22.0.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;jest-serializer-vue&quot;</span>: <span class="string">&quot;^0.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;node-notifier&quot;</span>: <span class="string">&quot;^5.1.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;optimize-css-assets-webpack-plugin&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;ora&quot;</span>: <span class="string">&quot;^1.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;portfinder&quot;</span>: <span class="string">&quot;^1.0.13&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postcss-import&quot;</span>: <span class="string">&quot;^11.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postcss-loader&quot;</span>: <span class="string">&quot;^2.0.8&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postcss-url&quot;</span>: <span class="string">&quot;^7.2.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;rimraf&quot;</span>: <span class="string">&quot;^2.6.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;semver&quot;</span>: <span class="string">&quot;^5.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;shelljs&quot;</span>: <span class="string">&quot;^0.7.6&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;uglifyjs-webpack-plugin&quot;</span>: <span class="string">&quot;^1.1.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url-loader&quot;</span>: <span class="string">&quot;^0.5.8&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-jest&quot;</span>: <span class="string">&quot;^1.0.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-loader&quot;</span>: <span class="string">&quot;^13.3.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-style-loader&quot;</span>: <span class="string">&quot;^3.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.5.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^3.6.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-bundle-analyzer&quot;</span>: <span class="string">&quot;^2.9.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^2.9.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-merge&quot;</span>: <span class="string">&quot;^4.1.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;engines&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;node&quot;</span>: <span class="string">&quot;&gt;= 6.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;npm&quot;</span>: <span class="string">&quot;&gt;= 3.0.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;browserslist&quot;</span>: [<span class="string">&quot;&gt; 1%&quot;</span>, <span class="string">&quot;last 2 versions&quot;</span>, <span class="string">&quot;not ie &lt;= 8&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有很多东西：</p><ul><li><code>name</code> 设置了应用程序/软件包的名称。</li><li><code>version</code> 表明了当前的版本。</li><li><code>description</code> 是应用程序/软件包的简短描述。</li><li><code>main</code> 设置了应用程序的入口点。</li><li><code>private</code> 如果设置为 <code>true</code>，则可以防止应用程序/软件包被意外地发布到 <code>npm</code>。</li><li><code>scripts</code> 定义了一组可以运行的 node 脚本。</li><li><code>dependencies</code> 设置了作为依赖安装的 <code>npm</code> 软件包的列表。</li><li><code>devDependencies</code> 设置了作为开发依赖安装的 <code>npm</code> 软件包的列表。</li><li><code>engines</code> 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。</li><li><code>browserslist</code> 用于告知要支持哪些浏览器（及其版本）。</li></ul><p>以上所有的这些属性都可被 <code>npm</code> 或其他工具使用。</p><h2 id="属性分类"><a href="#属性分类" class="headerlink" title="属性分类"></a>属性分类</h2><p>本节详细介绍了可以使用的属性。</p><p>其中大多数属性仅可用于 <a href="https://www.npmjs.com/%EF%BC%8C%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7%E5%88%99%E5%8F%AF%E8%A2%AB%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92%E7%9A%84%E8%84%9A%E6%9C%AC%EF%BC%88%E4%BE%8B%E5%A6%82">https://www.npmjs.com/，其他属性则可被与代码交互的脚本（例如</a> <code>npm</code> 或其他工具）使用。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><p>设置软件包的名称。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;name&quot;: &quot;nodejs_cn&quot;</span><br></pre></td></tr></table></figure><p>名称必须少于 214 个字符，且不能包含空格，只能包含小写字母、连字符（<code>-</code>）或下划线（<code>_</code>）。</p><p>这是因为当软件包在 <code>npm</code> 上发布时，它会基于此属性获得自己的 URL。</p><p>如果在 GitHub 上公开地发布此软件包，则 GitHub 仓库的名称是作为此属性的不错选择。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="author"><a href="#author" class="headerlink" title="author"></a>author</h3><p>列出软件包的作者名称。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;NodeJS中文网 &lt;mail@nodejs.cn&gt; (http://nodejs.cn)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用以下格式：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;NodeJS中文网&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;mail@nodejs.cn&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://nodejs.cn&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="contributors"><a href="#contributors" class="headerlink" title="contributors"></a>contributors</h3><p>除作者外，该项目可以有一个或多个贡献者。 此属性是列出他们的数组。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;contributors&quot;</span>: [<span class="string">&quot;NodeJS中文网 &lt;mail@nodejs.cn&gt; (http://nodejs.cn))&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用以下格式：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;contributors&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;NodeJS中文网&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;mail@nodejs.cn&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://nodejs.cn&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h3><p>链接到软件包的问题跟踪器，最常用的是 GitHub 的 issues 页面。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;bugs&quot;</span>: <span class="string">&quot;https://github.com/nodejscn/node-api-cn/issues&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="homepage"><a href="#homepage" class="headerlink" title="homepage"></a>homepage</h3><p>设置软件包的主页。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span>: <span class="string">&quot;http://nodejs.cn&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>指定软件包的当前版本。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;version&quot;: &quot;1.0.0&quot;</span><br></pre></td></tr></table></figure><p>此属性遵循版本的语义版本控制记法，这意味着版本始终以 3 个数字表示：<code>x.x.x</code>。</p><p>第一个数字是主版本号，第二个数字是次版本号，第三个数字是补丁版本号。</p><p>这些数字中的含义是：仅修复缺陷的版本是补丁版本，引入向后兼容的更改的版本是次版本，具有重大更改的是主版本。</p><h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="license"><a href="#license" class="headerlink" title="license"></a>license</h3><p>指定软件包的许可证。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;license&quot;: &quot;MIT&quot;</span><br></pre></td></tr></table></figure><h3 id="-7"><a href="#-7" class="headerlink" title=""></a></h3><h3 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h3><p>此属性包含与软件包功能相关的关键字数组。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;keywords&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;email&quot;</span>,</span><br><span class="line">  <span class="string">&quot;machine learning&quot;</span>,</span><br><span class="line">  <span class="string">&quot;ai&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这有助于人们在浏览相似的软件包或浏览 <a href="https://www.npmjs.com/">https://www.npmjs.com/</a> 网站时找到你的软件包。</p><h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>此属性包含了对软件包的简短描述。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;description&quot;: &quot;NodeJS中文网入门教程&quot;</span><br></pre></td></tr></table></figure><p>如果要将软件包发布到 <code>npm</code>，则这个属性特别有用，人们可以知道该软件包是干啥用的。</p><h3 id="-9"><a href="#-9" class="headerlink" title=""></a></h3><h3 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h3><p>此属性指定了此程序包仓库所在的位置。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;repository&quot;: &quot;github:nodejscn/node-api-cn&quot;,</span><br></pre></td></tr></table></figure><p>注意 <code>github</code> 前缀。 其他流行的服务商还包括：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;repository&quot;: &quot;gitlab:nodejscn/node-api-cn&quot;,</span><br><span class="line">&quot;repository&quot;: &quot;bitbucket:nodejscn/node-api-cn&quot;,</span><br></pre></td></tr></table></figure><p>可以显式地设置版本控制系统：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;repository&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/nodejscn/node-api-cn.git&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用其他的版本控制系统：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;repository&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;svn&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;...&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>设置软件包的入口点。</p><p>当在应用程序中导入此软件包时，应用程序会在该位置搜索模块的导出。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;main&quot;: &quot;src/main.js&quot;</span><br></pre></td></tr></table></figure><h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>如果设置为 <code>true</code>，则可以防止应用程序/软件包被意外发布到 <code>npm</code> 上。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;private&quot;: true</span><br></pre></td></tr></table></figure><h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>可以定义一组可以运行的 node 脚本。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;npm run dev&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;jest --config test/unit/jest.conf.js --coverage&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;npm run unit&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint --ext .js,.vue src test/unit&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;node build/build.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些脚本是命令行应用程序。 可以通过调用 <code>npm run XXXX</code> 或 <code>yarn XXXX</code> 来运行它们，其中 <code>XXXX</code> 是命令的名称。 例如：<code>npm run dev</code>。</p><p>可以为命令使用任何的名称，脚本也可以是任何操作。</p><h3 id="-13"><a href="#-13" class="headerlink" title=""></a></h3><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h3><p>设置作为依赖安装的 <code>npm</code> 软件包的列表。</p><p>当使用 npm 或 yarn 安装软件包时：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">npm install &lt;PACKAGENAME&gt;</span><br><span class="line"></span><br><span class="line">yarn add &lt;PACKAGENAME&gt;</span><br></pre></td></tr></table></figure><p>该软件包会被自动地插入此列表中。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.5.2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-14"><a href="#-14" class="headerlink" title=""></a></h3><h3 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h3><p>设置作为开发依赖安装的 <code>npm</code> 软件包的列表。</p><p>它们不同于 <code>dependencies</code>，因为它们只需安装在开发机器上，而无需在生产环境中运行代码。</p><p>当使用 npm 或 yarn 安装软件包时：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --dev &lt;PACKAGENAME&gt;</span><br><span class="line"></span><br><span class="line">yarn add --dev &lt;PACKAGENAME&gt;</span><br></pre></td></tr></table></figure><p>该软件包会被自动地插入此列表中。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;autoprefixer&quot;</span>: <span class="string">&quot;^7.1.2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;babel-core&quot;</span>: <span class="string">&quot;^6.22.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><h3 id="engines"><a href="#engines" class="headerlink" title="engines"></a>engines</h3><p>设置此软件包/应用程序要运行的 Node.js 或其他命令的版本。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;engines&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;node&quot;</span>: <span class="string">&quot;&gt;= 6.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;npm&quot;</span>: <span class="string">&quot;&gt;= 3.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;yarn&quot;</span>: <span class="string">&quot;^0.13.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><h3 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h3><p>用于告知要支持哪些浏览器（及其版本）。 Babel、Autoprefixer 和其他工具会用到它，以将所需的 polyfill 和 fallback 添加到目标浏览器。</p><p>示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;browserslist&quot;</span>: [</span><br><span class="line">  <span class="string">&quot;&gt; 1%&quot;</span>,</span><br><span class="line">  <span class="string">&quot;last 2 versions&quot;</span>,</span><br><span class="line">  <span class="string">&quot;not ie &lt;= 8&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>此配置意味着需要支持使用率超过 1％（来自 <a href="https://caniuse.com/">CanIUse.com</a> 的统计信息）的所有浏览器的最新的 2 个主版本，但不含 IE8 及更低的版本。</p><p>(<a href="https://www.npmjs.com/package/browserslist">查看更多</a>)</p><h3 id="-17"><a href="#-17" class="headerlink" title=""></a></h3><h2 id="命令特有的属性"><a href="#命令特有的属性" class="headerlink" title="命令特有的属性"></a>命令特有的属性</h2><p><code>package.json</code> 文件还可以承载命令特有的配置，例如 Babel、ESLint 等。</p><p>每个都有特有的属性，例如 <code>eslintConfig</code>、<code>babel</code> 等。 它们是命令特有的，可以在相应的命令/项目文档中找到如何使用它们。</p><h2 id="软件包版本"><a href="#软件包版本" class="headerlink" title="软件包版本"></a>软件包版本</h2><p>在上面的描述中，已经看到类似以下的版本号：<code>〜3.0.0</code> 或 <code>^0.13.0</code>。 它们是什么意思，还可以使用哪些其他的版本说明符？</p><p>该符号指定了软件包能从该依赖接受的更新。</p><p>鉴于使用了 semver（语义版本控制），所有的版本都有 3 个数字，第一个是主版本，第二个是次版本，第三个是补丁版本，具有以下规则：</p><ul><li><code>~</code>: 如果写入的是 <code>〜0.13.0</code>，则只更新补丁版本：即 <code>0.13.1</code> 可以，但 <code>0.14.0</code> 不可以。</li><li><code>^</code>: 如果写入的是 <code>^0.13.0</code>，则要更新补丁版本和次版本：即 <code>0.13.1</code>、<code>0.14.0</code>、依此类推。</li><li><code>*</code>: 如果写入的是 <code>*</code>，则表示接受所有的更新，包括主版本升级。</li><li><code>&gt;</code>: 接受高于指定版本的任何版本。</li><li><code>&gt;=</code>: 接受等于或高于指定版本的任何版本。</li><li><code>&lt;=</code>: 接受等于或低于指定版本的任何版本。</li><li><code>&lt;</code>: 接受低于指定版本的任何版本。</li></ul><p>还有其他的规则：</p><ul><li>无符号: 仅接受指定的特定版本。</li><li><code>latest</code>: 使用可用的最新版本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件结构简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn和npm区别</title>
      <link href="/2021/10/04/yarn-%E5%92%8C-npm-%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/10/04/yarn-%E5%92%8C-npm-%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="Yarn的优点？"><a href="#Yarn的优点？" class="headerlink" title="Yarn的优点？"></a>Yarn的优点？</h3><ul><li>速度快 。速度快主要来自以下两个方面：</li></ul><ol><li>并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。</li><li>离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。</li></ol><ul><li>安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。</li><li>更简洁的输出：npm 的输出信息比较冗长。在执行 npm install <package> 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</li><li>多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。</li><li>更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。</li></ul><h3 id="Yarn和npm命令对比"><a href="#Yarn和npm命令对比" class="headerlink" title="Yarn和npm命令对比"></a>Yarn和npm命令对比</h3><table><thead><tr><th>npm</th><th>yarn</th></tr></thead><tbody><tr><td>npm install</td><td>yarn</td></tr><tr><td>npm install react –save</td><td>yarn add react</td></tr><tr><td>npm uninstall react –save</td><td>yarn remove react</td></tr><tr><td>npm install react –save-dev</td><td>yarn add react –dev</td></tr><tr><td>npm update –save</td><td>yarn upgrade</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> yarn的优点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ngnix</title>
      <link href="/2021/09/28/Ngnix/"/>
      <url>/2021/09/28/Ngnix/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Nginx-介绍"><a href="#1-Nginx-介绍" class="headerlink" title="1 Nginx 介绍"></a>1 Nginx 介绍</h2><h3 id="1-1-什么是-Nginx？"><a href="#1-1-什么是-Nginx？" class="headerlink" title="1.1 什么是 Nginx？"></a>1.1 什么是 Nginx？</h3><p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><p><img src="https://i.loli.net/2021/09/28/iwZa1Nx7lVU3djT.png" alt="架构图.png"></p><p>上图基本上说明了当下流行的技术架构，其中Nginx有点入口网关的味道。</p><h3 id="1-2-代理服务器？"><a href="#1-2-代理服务器？" class="headerlink" title="1.2 代理服务器？"></a>1.2 代理服务器？</h3><h4 id="1-2-1-正向代理"><a href="#1-2-1-正向代理" class="headerlink" title="1.2.1 正向代理"></a>1.2.1 正向代理</h4><p>我理解的正向代理像是一个中间跳板，代理访问外网资源。</p><p><img src="https://i.loli.net/2021/09/28/IVDHGXPocSJWL4N.png" alt="正向代理.png"></p><p>举个例子：</p><p>我使用的客户端，无法访问某个网站，但是我的客户端可以访问某一个代理服务器，这个代理服务器可以访问我无法访问的网站，于是我先连接代理服务器，告诉它我无法访问的网站内容，代理服务器去取回来返回给我。</p><p>从网站的角度来说，只在代理服务器取内容时有过一次记录，由于隐藏了客户的资料，有时候并不知道是用户的请求，这取决于代理告不告诉网站。</p><p>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</p><p>总的来说，<strong>正向代理</strong> 是一个位于客户端和原始服务器（origin server）之间的服务器，为了从原始服务器取得的内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转交请求并将得到的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p><p><strong>正向代理的用途：</strong></p><pre><code>1. 访问原来无法访问的资源，如 google2. 可以做缓存，加速访问资源3. 对客户端访问授权，上网进行认证4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</code></pre><h4 id="1-2-2-反向代理（Reverse-Proxy）"><a href="#1-2-2-反向代理（Reverse-Proxy）" class="headerlink" title="1.2.2 反向代理（Reverse Proxy）"></a>1.2.2 反向代理（Reverse Proxy）</h4><p>实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的记过返回给internet上请求连接客户端，此时代理服务器对边表现就是一个服务器。</p><p><strong>反向代理的作用：</strong></p><ol><li><p>保证内网的安全，可以使用反向代理提供WAF功能，组织web攻击。</p><p>大型网站通常将反向代理作为公网访问地址，Web服务器时内网。</p><p><img src="https://i.loli.net/2021/09/28/NiMTjmPR6K3WQtw.png" alt="反向代理.png"></p></li><li><p>负载均衡，通过反向代理服务器来优化网站的负载</p></li></ol><p><img src="https://i.loli.net/2021/09/28/muh3qF6zwr4c52B.png" alt="反向代理-负载均衡.png"></p><h2 id="2-Nginx-常用命令"><a href="#2-Nginx-常用命令" class="headerlink" title="2 Nginx 常用命令"></a>2 Nginx 常用命令</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务</span></span><br><span class="line"><span class="attribute">nginx</span> -s stop</span><br><span class="line"><span class="comment"># 平稳关闭Nginx，保存相关信息，有安排的结束web服务</span></span><br><span class="line">nginx -s quit</span><br><span class="line"><span class="comment"># 因改变了Nginx相关配置，需要重新加载配置而重载</span></span><br><span class="line">nginx -s reload</span><br><span class="line"><span class="comment"># 重新打开日志文件</span></span><br><span class="line">nginx -s reopen</span><br><span class="line"><span class="comment"># 为 Nginx 指定一个配置文件，来代替缺省的</span></span><br><span class="line">nginx -c filename</span><br><span class="line"><span class="comment"># 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="comment">#  显示 nginx 的版本</span></span><br><span class="line">nginx -v</span><br><span class="line"><span class="comment"># 显示 nginx 的版本，编译器版本和配置参数</span></span><br><span class="line">nginx -V</span><br><span class="line"><span class="comment"># 格式换显示 nginx 配置参数</span></span><br><span class="line"><span class="number">2</span>&gt;&amp;<span class="number">1</span> nginx -V | xargs -n1</span><br><span class="line"><span class="number">2</span>&gt;&amp;<span class="number">1</span> nginx -V | xargs -n1 | grep lua</span><br></pre></td></tr></table></figure><h2 id="3-Nginx-配置"><a href="#3-Nginx-配置" class="headerlink" title="3 Nginx 配置"></a>3 Nginx 配置</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开主配置文件，若你是用lnmp环境安装</span></span><br><span class="line"><span class="attribute">vim</span> /usr/local/nginx/conf/nginx.conf</span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">user                    <span class="comment">#设置nginx服务的系统使用用户</span></span><br><span class="line">worker_processes        <span class="comment">#工作进程数 一般情况与CPU核数保持一致</span></span><br><span class="line">error_log               <span class="comment">#nginx的错误日志</span></span><br><span class="line">pid                     <span class="comment">#nginx启动时的pid</span></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>    <span class="comment">#每个进程允许最大连接数</span></span><br><span class="line">    use                   <span class="comment">#nginx使用的内核模型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 nginx 的 http 服务，在配置文件 nginx.conf 中的 http 区域内，配置无数个 server ，每一个 server 对应这一个虚拟主机或者域名。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    ... ...        <span class="comment">#后面再详细介绍 http 配置项目</span></span><br><span class="line">    </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>                          <span class="comment">#监听端口;</span></span><br><span class="line">        server_name localhost              <span class="comment">#地址</span></span><br><span class="line">        </span><br><span class="line">        location / &#123;                       <span class="comment">#访问首页路径</span></span><br><span class="line">            <span class="attribute">root</span> /xxx/xxx/index.html       <span class="comment">#默认目录</span></span><br><span class="line">            index index.html index.htm     <span class="comment">#默认文件</span></span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        error_page  <span class="number">500</span> <span class="number">504</span>   /50x.html    <span class="comment">#当出现以上状态码时从新定义到50x.html</span></span><br><span class="line">        location = /50x.html &#123;             <span class="comment">#当访问50x.html时</span></span><br><span class="line">            <span class="attribute">root</span> /xxx/xxx/html             <span class="comment">#50x.html 页面所在位置</span></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        ... ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 server 可以出现多个 location ，我们对不同的访问路径进行不同情况的配置。</p><p>我们再来看看 http 的配置详情</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">sendfile</span>  <span class="literal">on</span>                  <span class="comment">#高效传输文件的模式 一定要开启</span></span><br><span class="line">    keepalive_timeout   <span class="number">65</span>        <span class="comment">#客户端服务端请求超时时间</span></span><br><span class="line">    log_format  main   XXX        <span class="comment">#定义日志格式 代号为main</span></span><br><span class="line">    access_log  /usr/local/access.log  main     <span class="comment">#日志保存地址 格式代码 main</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 nginx 一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。</p><table><thead><tr><th>变量</th><th>功能</th></tr></thead><tbody><tr><td>$host</td><td>请求信息中的post，如果请求中没有 Host行，则等于设置的服务器名</td></tr><tr><td>$request_method</td><td>客户端请求类型，如 GET、POST</td></tr><tr><td>$remote_addr</td><td>客户端的 IP 地址</td></tr><tr><td>$args</td><td>请求中的参数</td></tr><tr><td>$content_length</td><td>请求头中的Cotent-length字段</td></tr><tr><td>$http_user_agent</td><td>客户端 agent 信息</td></tr><tr><td>$http_cookie</td><td>客户端 cookie 信息</td></tr><tr><td>$remote_addr</td><td>客户端的IP地址</td></tr><tr><td>$remote_port</td><td>客户端的端口</td></tr><tr><td>$server_protocol</td><td>请求使用的协议，如HTTP/1.0、HTTP/1.1\</td></tr><tr><td>$server_addr</td><td>服务器地址</td></tr><tr><td>$server_name</td><td>服务器名称</td></tr><tr><td>$server_port</td><td>服务器的端口号</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ngnix 安装及配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="/2021/09/24/Ajax/"/>
      <url>/2021/09/24/Ajax/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-初识-Ajax"><a href="#第1章-初识-Ajax" class="headerlink" title="第1章 初识 Ajax"></a>第1章 初识 Ajax</h2><h3 id="1-1-Ajax-的作用"><a href="#1-1-Ajax-的作用" class="headerlink" title="1.1 Ajax 的作用"></a>1.1 Ajax 的作用</h3><p>获取给服务器的数据s</p><h3 id="1-2-Ajax-的效果"><a href="#1-2-Ajax-的效果" class="headerlink" title="1.2 Ajax 的效果"></a>1.2 Ajax 的效果</h3><p>如果仔细观察一个Form的提交，你就会发现，一旦用户点击“Submit”按钮，表单开始提交，浏览器就会刷新页面，然后在新页面里告诉你操作是成功了还是失败了。如果不幸由于网络太慢或者其他原因，就会得到一个404页面</p><p>在不刷新整个页面的情况下，通过一个 url 地址获取服务器，然后进行页面的局部刷新</p><h3 id="1-3-Ajax-的使用"><a href="#1-3-Ajax-的使用" class="headerlink" title="1.3 Ajax 的使用"></a>1.3 Ajax 的使用</h3><p>Ajax 简单来说，就是一个异步的 javascript 请求，用来获取后台服务端的数据，而并不是整个页面的跳转。</p><p>在元素 JS 中来实现 Ajax 主要的类就是 XMLHttpRequest，它的使用一般有 4 个步骤：</p><ol><li>创建 XMLHttpRequest 对象</li><li>准备发送网络请求</li><li>开始发送网络请求</li><li>指定回调函数</li></ol><h3 id="1-4-常用场景"><a href="#1-4-常用场景" class="headerlink" title="1.4 常用场景"></a>1.4 常用场景</h3><p>a. 评论加载系统</p><p>b. 用户验证界面</p><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>六字：局部    异步    刷新</p><p>Ajax 的全称：Asynchronous Javascript And XML，就是使用 JS 代码获取服务器数据</p><h2 id="第2章-XMLHttpRequest"><a href="#第2章-XMLHttpRequest" class="headerlink" title="第2章 XMLHttpRequest"></a>第2章 XMLHttpRequest</h2><h3 id="2-1-XHR-创建对象"><a href="#2-1-XHR-创建对象" class="headerlink" title="2.1 XHR  - 创建对象"></a>2.1 XHR  - 创建对象</h3><p>XMLHttpRequest 是 AJAX 的基础。</p><h4 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h4><p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。</p><p>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><h4 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h4><p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p><p>创建 XMLHttpRequest 对象的语法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">variable = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure><p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">variable = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br></pre></td></tr></table></figure><p>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span></span><br><span class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// IE6, IE5 浏览器执行代码</span></span><br><span class="line">    xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><h3 id="2-2-XHR-向服务器发送请求"><a href="#2-2-XHR-向服务器发送请求" class="headerlink" title="2.2 XHR - 向服务器发送请求"></a>2.2 XHR - 向服务器发送请求</h3><p>XMLHttpRequest 对象用于和服务器交换数据。</p><h4 id="向服务器发送请求"><a href="#向服务器发送请求" class="headerlink" title="向服务器发送请求"></a>向服务器发送请求</h4><p>如需将请求发送到服务器，我们使用 <strong>XMLHttpRequest</strong> 对象的 <strong>open()</strong> 和 <strong>send()</strong> 方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>open(method,async)</td><td>规定请求的类型、URL 以及是否异步处理请求。<br /> method：请求的类型；GET 或 POST<br /> url：文件再服务器上的位置<br /> async：true （异步） 或 false （同步）</td></tr><tr><td>send(string)</td><td>将请求发送到服务器。<br /> string：仅用于 POST 请求</td></tr></tbody></table><p>GET 还是 POST ？</p><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>然而，在以下情况中，请使用 POST 请求：</p><p>无法使用缓存文件（更新服务器上的文件或数据库）</p><p>向服务器发送大量数据（POST 没有数据量限制）</p><p>发送包含未知字符的用户输入时，POST 比 GET 更稳定页更可靠。</p><p><img src="https://i.loli.net/2021/09/26/2y6IYh93qvXm1GV.png" alt="get or post.png"></p><hr><h4 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h4><p>一个简单的请求：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/demo_get.php&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p>在上面的例子中，您可能得到的是缓存的结果。</p><p>为了避免这种情况，请向 URL 添加一个唯一的 ID：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/demo_get.php?t=&quot;</span> + <span class="built_in">Math</span>.random(),<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p>如果希望通过 GET 方法发送消息，请向 URL 添加信息：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/demo_get2.php?fname=Henry&amp;lname=Ford&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><hr><h4 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h4><p>一个简单的请求：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/try/ajax/demo_post.php&quot;</span>,<span class="literal">true</span>);xmlhttp.send();</span><br></pre></td></tr></table></figure><p>如果要向 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定你希望发送的数据：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;/try/ajax/demo_post2.php&quot;</span>,<span class="literal">true</span>);xmlhttp.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);xmlhttp.send(<span class="string">&quot;fname=Henry&amp;lname=Ford&quot;</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>setRequestHeader(<em>header,value</em>)</td><td>向请求添加 HTTP 头。<br />header：规定头的名称<br />value：规定头的值</td></tr></tbody></table><hr><h4 id="url-服务器上的文件"><a href="#url-服务器上的文件" class="headerlink" title="url - 服务器上的文件"></a>url - 服务器上的文件</h4><p>open() 方法 url 参数是服务器上文件的地址：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;ajax_test.html&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>该文件可以是任何类型的文件，比如 .txt 和 .xml 或者服务器脚本文件，比如 .asp 和 .php（在传回相应之前，能够在服务器上执行任务）。</p><hr><h4 id="异步-True-或-False-？"><a href="#异步-True-或-False-？" class="headerlink" title="异步 - True 或 False ？"></a>异步 - True 或 False ？</h4><p>Ajax 指的是异步 JavaScript 和 XML （Async JavaScript and XML）。</p><p>XMLHttpRequest 对象如果要用 Ajax 的话，其 open() 方法的 async 参数必须设置为 true：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;ajax_test.html&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>对应 Web 开发人员来说，发送异步请求是一个巨大而进步。很多在服务器执行的任务都相当费时。Ajax 出现之前，这可能引起应用程序挂起或停止。</p><p>通过Ajax，JavaScript 无需等待服务器的相应，而是：</p><ul><li>在等待服务器响应时应执行其他脚本</li><li>当响应就绪后对应进行处理</li></ul><hr><h4 id="Async-true"><a href="#Async-true" class="headerlink" title="Async = true"></a>Async = true</h4><p>当使用 async = true时，请规定在响应处于 onreadystatecheange 事件中的就绪状态执行的函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)    &#123;        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;    &#125;&#125;xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);xmlhttp.send();</span><br></pre></td></tr></table></figure><hr><h4 id="Async-false"><a href="#Async-false" class="headerlink" title="Async = false"></a>Async = false</h4><p>如需使用 async=false，请将 open() 方法中的第三个的参数改为 false：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;test1.txt&quot;</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>不推荐使用 async=false ，但是对于一些小请求，也是可以的。</p><p>请记住，JavaScript 会等到服务器响应就绪才执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。</p><p><strong>注意：</strong>当你使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">false</span>);xmlhttp.send();<span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure><h3 id="2-3-XHR-服务器响应"><a href="#2-3-XHR-服务器响应" class="headerlink" title="2.3 XHR - 服务器响应"></a>2.3 XHR - 服务器响应</h3><h4 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h4><p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>reponseText</td><td>获得字符串形式的响应数据</td></tr><tr><td>reponseXML</td><td>获得 XML 形式的响应数据</td></tr></tbody></table><hr><h4 id="reponseText-属性"><a href="#reponseText-属性" class="headerlink" title="reponseText 属性"></a>reponseText 属性</h4><p>如果来自服务器的响应并非XML，请使用 reponseText 属性。</p><p>reponseText 属性返回字符串形式的响应，因此可以这样使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br></pre></td></tr></table></figure><hr><h4 id="reponseXML-属性"><a href="#reponseXML-属性" class="headerlink" title="reponseXML 属性"></a>reponseXML 属性</h4><p>如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 reponseXML 属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlDoc=xmlhttp.responseXML;txt=<span class="string">&quot;&quot;</span>;x=xmlDoc.getElementsByTagName(<span class="string">&quot;ARTIST&quot;</span>);<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;x.length;i++)&#123;    txt=txt + x[i].childNodes[<span class="number">0</span>].nodeValue + <span class="string">&quot;&lt;br&gt;&quot;</span>;&#125;<span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=txt;</span><br></pre></td></tr></table></figure><h3 id="2-4-XHR-onreadystate"><a href="#2-4-XHR-onreadystate" class="headerlink" title="2.4 XHR - onreadystate"></a>2.4 XHR - onreadystate</h3><h4 id="onreadystatechange-事件"><a href="#onreadystatechange-事件" class="headerlink" title="onreadystatechange 事件"></a>onreadystatechange 事件</h4><p>当请求被发送到服务器时，我们需要执行一些基于相应的任务。</p><p>每当 readystate 改变时，就会触发 onreadystatechange 事件。</p><p>readystate 属性存有 XMLHttpRequest 的状态信息。</p><p>下面是 XMLHttpRequest 对象的三个重要信息：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>存储函数（或函数名），每当 readystate 属性改变时，就会调用该函数。</td></tr><tr><td>readystate</td><td>存有 XMLHttpRequest 的状态。从 0 到 4发生变化。<br />0：请求未初始化<br />1：服务器连接已建立<br />2：请求已接收<br />3：请求处理中<br />4：请求已完成，且响应已就绪</td></tr><tr><td>status</td><td>200：“OK”<br />404：未找到页面</td></tr></tbody></table><p><strong>xmlhttp.status的值及解释：</strong></p><p>100——客户必须继续发出请求</p><p>101——客户要求服务器根据请求转换HTTP协议版本</p><p>200——交易成功</p><p>201——提示知道新文件的URL</p><p>202——接受和处理、但处理未完成</p><p>203——返回信息不确定或不完整</p><p>204——请求收到，但返回信息为空</p><p>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p><p>206——服务器已经完成了部分用户的GET请求</p><p>300——请求的资源可在多处得到</p><p>301——删除请求数据</p><p>302——在其他地址发现了请求数据</p><p>303——建议客户访问其他URL或访问方式</p><p>304——客户端已经执行了GET，但文件未变化</p><p>305——请求的资源必须从服务器指定的地址得到</p><p>306——前一版本HTTP中使用的代码，现行版本中不再使用</p><p>307——申明请求的资源临时性删除</p><p>400——错误请求，如语法错误</p><p>401——请求授权失败</p><p>402——保留有效ChargeTo头响应</p><p>403——请求不允许</p><p>404——没有发现文件、查询或URl</p><p>405——用户在Request-Line字段定义的方法不允许</p><p>406——根据用户发送的Accept拖，请求资源不可访问</p><p>407——类似401，用户必须首先在代理服务器上得到授权</p><p>408——客户端没有在用户指定的饿时间内完成请求</p><p>409——对当前资源状态，请求不能完成</p><p>410——服务器上不再有此资源且无进一步的参考地址</p><p>411——服务器拒绝用户定义的Content-Length属性请求</p><p>412——一个或多个请求头字段在当前请求中错误</p><p>413——请求的资源大于服务器允许的大小</p><p>414——请求的资源URL长于服务器允许的长度</p><p>415——请求资源不支持请求项目格式</p><p>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</p><p>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</p><p><strong>合起来</strong></p><p>500——服务器产生内部错误</p><p>501——服务器不支持请求的函数</p><p>502——服务器暂时不可用，有时是为了防止发生系统过载</p><p>503——服务器过载或暂停维修</p><p>504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</p><p>505——服务器不支持或拒绝支请求头中指定的HTTP版本</p><p>1xx:信息响应类，表示接收到请求并且继续处理</p><p>2xx:处理成功响应类，表示动作被成功接收、理解和接受</p><p>3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理</p><p>4xx:客户端错误，客户请求包含语法错误或者是不能正确执行</p><p>5xx:服务端错误，服务器不能正确执行一个正确的请求</p><hr><p>在onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。</p><p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    <span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>)    &#123;        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>onreadystatechange 事件被触发 4 4次（0 - 4），分别是0-1、1-2、2-3、3-4，对应着readyState 的每个变化。</p><hr><h4 id="使用回调函数"><a href="#使用回调函数" class="headerlink" title="使用回调函数"></a>使用回调函数</h4><p>回调函数是一种一参数形式传递给另一个函数的函数。</p><p>如果你的网站上存在多个 Ajax 认为，那么你应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 Ajax 任务调用该函数。</p><p>该函数调用应该包含 URL 以及 发生 onreadystatechange 事件时执行的任务（每次调用可能不尽相同）：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">function myFunction()&#123;    loadXMLDoc(<span class="attr">&quot;/try/ajax/ajax_info.txt&quot;</span>,function()    &#123;        if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)        &#123;            document.getElementById(<span class="attr">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;        &#125;    &#125;);&#125;</span><br></pre></td></tr></table></figure><h2 id="第3章-数据格式"><a href="#第3章-数据格式" class="headerlink" title="第3章 数据格式"></a>第3章 数据格式</h2><h3 id="3-1-什么是数据格式"><a href="#3-1-什么是数据格式" class="headerlink" title="3.1 什么是数据格式"></a>3.1 什么是数据格式</h3><p>将数据通过一定的规范组织起来，叫做数据格式，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">张三%19%男-李四%23%男-王五%30%女</span><br></pre></td></tr></table></figure><h3 id="3-2-xml-数据格式"><a href="#3-2-xml-数据格式" class="headerlink" title="3.2 xml 数据格式"></a>3.2 xml 数据格式</h3><p>xml数据格式是将数据以标签的方式进行组装，必须以 &lt;?xml version=”1.0” encoding=”utf-8” ?&gt; 开头，标签必须成对出现，也就是有开始标签就一定要有结束标签。xml 是一个通用的标准，任何人都知道该如何解析它。例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span><span class="tag">&lt;<span class="name">students</span>&gt;</span><span class="tag">&lt;<span class="name">student</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">age</span>&gt;</span>19<span class="tag">&lt;/<span class="name">age</span>&gt;</span><span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span><span class="tag">&lt;/<span class="name">student</span>&gt;</span><span class="tag">&lt;<span class="name">student</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">age</span>&gt;</span>23<span class="tag">&lt;/<span class="name">age</span>&gt;</span><span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span><span class="tag">&lt;/<span class="name">student</span>&gt;</span><span class="tag">&lt;<span class="name">student</span>&gt;</span><span class="tag">&lt;<span class="name">name</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">name</span>&gt;</span><span class="tag">&lt;<span class="name">age</span>&gt;</span>30<span class="tag">&lt;/<span class="name">age</span>&gt;</span><span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span><span class="tag">&lt;/<span class="name">student</span>&gt;</span><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>缺点：</strong></p><p>体积太大，传输慢，元数据太多，解析不方便，目前使用的很少。</p></blockquote><h3 id="3-3-Json-数据格式"><a href="#3-3-Json-数据格式" class="headerlink" title="3.3 Json 数据格式"></a>3.3 Json 数据格式</h3><p>Json 数据格式类似于 js 中的对象方式，通过 key-value 的形式组装，是一个通用的标准，任何人都知道如何解析它。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;student&quot;</span>:&#123;&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="string">&quot;19&quot;</span>,<span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;李四&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="string">&quot;23&quot;</span>,<span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;男&quot;</span>&#125;,&#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="attr">&quot;age&quot;</span>:<span class="string">&quot;30&quot;</span>,<span class="attr">&quot;sex&quot;</span>:<span class="string">&quot;女&quot;</span>&#125;,&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>优点：</strong></p><p>体积小，传输快，解析方便。</p></blockquote><h2 id="第4章-Ajax-的封装"><a href="#第4章-Ajax-的封装" class="headerlink" title="第4章 Ajax 的封装"></a>第4章 Ajax 的封装</h2><p>对于封装方法，我们主要考虑几个方面：</p><ol><li>哪些东西是变的。</li><li>哪些东西时不变的。</li><li>如何将结果通知调用者。</li><li>如何调用方便。</li></ol><p>不同场景的 Ajax 调用，调用方法 get 还是 post 这个是有可能发生的，调用 url 地址也是会变得，请求参数也是会变的，返回数据的类型也是会变的。对于发生改变的东西可以通过参数传递的方式实现。</p><p>基础代码例如创建 XMLHttpRequest 对象，准备发送、执行发送，响应回调中有些代码也是固定不变的。</p><p>将结果通知调用者也可以通过调用时传入一个方法就可以实现。</p><p>综上所述，代码可以封装成以下形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax01</span>(<span class="params">method, url, params, dataType, callback, <span class="keyword">async</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建 XMLHttpRequest 对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Mirrosoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// null --&gt; ?null</span></span><br><span class="line">    <span class="keyword">if</span> (method == <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params &amp;&amp; params != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            url += <span class="string">&quot;?&quot;</span> + params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 准备发送网络请求</span></span><br><span class="line">    xhr.open(method, url, <span class="literal">true</span>); <span class="comment">// 异步请求</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 开始发送网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (method == <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">        xhr.send(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method == <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">        xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">        xhr.send(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 指定回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">async</span>) &#123;</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dataType == <span class="string">&#x27;json&#x27;</span>) &#123; <span class="comment">//&#x27;JSON&#x27;数据格式</span></span><br><span class="line">                        result = xhr.reponseText;</span><br><span class="line">                        result = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType == <span class="string">&#x27;xml&#x27;</span>) &#123; <span class="comment">//&#x27;XML&#x27;数据格式</span></span><br><span class="line">                        result = xhr.reponsXML;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 除上述两种之外都是text格式</span></span><br><span class="line">                        result = xhr.reponseText;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">                        callback(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (dataType == <span class="string">&#x27;json&#x27;</span>) &#123; <span class="comment">//&#x27;JSON&#x27;数据格式</span></span><br><span class="line">                    result = xhr.reponseText;</span><br><span class="line">                    result = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataType == <span class="string">&#x27;xml&#x27;</span>) &#123; <span class="comment">//&#x27;XML&#x27;数据格式</span></span><br><span class="line">                    result = xhr.reponsXML;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 除上述两种之外都是text格式</span></span><br><span class="line">                    result = xhr.reponseText;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">                    callback(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第5章-跨域"><a href="#第5章-跨域" class="headerlink" title="第5章 跨域"></a>第5章 跨域</h2><h3 id="5-1-跨域的概念"><a href="#5-1-跨域的概念" class="headerlink" title="5.1 跨域的概念"></a>5.1 跨域的概念</h3><p>跨域的概念源于<strong>同源策略</strong>。</p><p>同源策略是浏览器上为安全性考虑实施的非常重要的安全机制。Ajax 默认是能够获取到同源的数据，对于非同源的数据，ajax 默认是获取不到的。</p><p>下面举一个例子，加深对<strong>同源</strong>的理解。</p><p>比如有一个网页，他的地址为 <code>http://www.example.com/dir/index.html</code> ，在这个网址中，要去获取服务器的数据，获取数据的地址如下所示，在下面的地址中，有的是同源，有的是非同源。</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><a href="https://www.example.com/dir/page.html">https://www.example.com/dir/page.html</a></td><td>不同源</td><td>协议不同，http 与 https</td></tr><tr><td><a href="http://en.example.xyz/dir/page.html">http://en.example.xyz/dir/page.html</a></td><td>不同源</td><td>域名不同</td></tr><tr><td><a href="http://www.example.com:81/dir/page.html">http://www.example.com:81/dir/page.html</a></td><td>不同源</td><td>端口不同</td></tr><tr><td><a href="http://www.example.com/dir/tags.html">http://www.example.com/dir/tags.html</a></td><td>同源</td><td>协议、域名、端口都相同</td></tr><tr><td><a href="http://www.example.com/dir2/page.html">http://www.example.com/dir2/page.html</a></td><td>同源</td><td>协议、域名、端口都相同</td></tr></tbody></table><p>所谓的同源就是协议、端口、域名三者都完全一样，如果我们使用 ajax 来请求非同源路径下的数据，那么将会报如下错误：</p><p><img src="https://i.loli.net/2021/09/26/KTIxfBY6Jw3Runm.png" alt="error.png"></p><p>在之前的案例中，我们能够成功的获取到服务器的数据，那是因为服务器的接口地址和前端界面都处于同源状态下。</p><p>那么需要处理获取非同源数据获取的情况吗？答案是肯定的。因为前端界面访问非同源的服务器的这种需求是非常常见的，比如前端界面中获取天气数据，天气数据肯定是存在与别人的服务器上的，我们如果不能用 ajax 进行访问的话，那么该怎么办呢？ 这里就需要使用到跨域了。</p><p>所以，先把概念理解清楚。不管是 ajax 还是跨域，都是为了访问服务器数据。简单来说： <strong>Ajax 是为了访问自己的服务器的数据，跨域是为了访问别人服务器的数据。</strong></p><h3 id="5-2-CORS-请求原理"><a href="#5-2-CORS-请求原理" class="headerlink" title="5.2 CORS 请求原理"></a>5.2 CORS 请求原理</h3><p>CORS 是一个 W3C 标准，全称是“跨域资源共享”。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了Ajax 只能同源使用的限制。</p><p>基本上目前所有的浏览器都实现了CORS 标准，其实目前几乎所有的浏览器 Ajax 请求都是基于 CORS 机制的，只不过可能平时前端开发人员并不关心而已（所以说其实在 CORS 解决方案主要是考虑后台该如何实现的问题）。</p><p><img src="https://i.loli.net/2021/09/26/aGJrwL6RTEyjOti.jpg" alt="CORS原理.jpg"></p><h3 id="5-3-如何判断是否是简单请求？"><a href="#5-3-如何判断是否是简单请求？" class="headerlink" title="5.3 如何判断是否是简单请求？"></a>5.3 如何判断是否是简单请求？</h3><p>浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。</p><ul><li><p>请求方法方法是以下三者之一：HEAD、GET、POST</p></li><li><p>HTTP 的头信息不超过以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type（只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain）</li></ul></li></ul><blockquote><p>凡是不能同时满足上面两个条件，就属于非简单请求。</p></blockquote><h3 id="5-4-ajax-跨域的表现"><a href="#5-4-ajax-跨域的表现" class="headerlink" title="5.4 ajax 跨域的表现"></a>5.4 ajax 跨域的表现</h3><p>ajax 请求时，如果存在跨域现象，并且没有进行解决，会有如下表现：</p><p><strong>第一种现象：</strong>  <code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>，并且 <code>The response had HTTP status code 404</code></p><p>出现这种情况的原因如下：</p><ul><li>本次 ajax 请求是“非简单请求”，所以请求前会发送一次预检请求（OPTIONS）</li><li>服务器端后台就扣没有允许OPTIONS 请求，导致无法找到对应接口地址</li></ul><p>解决方法：后端允许options 请求</p><p><strong>第二种现象：</strong>  <code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>，并且 <code>The response had HTTP status code 405</code></p><p>这种现象和第一种有区别，这种情况下，后台方法允许OPTIONS 请求，但是一些配置文件中（如<code>安全配置</code>），组织了OPTIONS请求，才会导致这个现象</p><p>解决方法：后端关闭对应的安全配置</p><p><strong>第三种现象：</strong>  <code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code>，并且<code>status 200</code></p><p>这种现象和第一种和第二种有区别,这种情况下，服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象</p><p>比如origin头部检查不匹配,比如少了一些头部的支持(如常见的X-Requested-With头部),然后服务端就会将response返回给前端,前端检测到这个后就触发XHR.onerror,导致前端控制台报错</p><p>解决方案: 后端增加对应的头部支持</p><p><strong>第四种现象：</strong>  <code>head contains multiple valus  &#39;*,*&#39;</code></p><p>表现现象是，后台响应的http头部信息有两个<code>Access-Control-Allow-Origin:*</code></p><p>说实话，这种问题出现的主要原因就是进行跨域配置的人不了解原理，导致了重复配置，如:</p><ul><li>常见于.net后台(一般在web.config中配置了一次origin,然后代码中又手动添加了一次origin(比如代码手动设置了返回*))</li><li>常见于.net后台(在IIS和项目的webconfig中同时设置Origin:*)</li></ul><p>解决方案(一一对应):</p><ul><li>建议删除代码中手动添加的*，只用项目配置中的即可</li><li>建议删除IIS下的配置*，只用项目配置中的即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对ajax的简单学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript入门</title>
      <link href="/2021/09/08/JavaScript%E5%85%A5%E9%97%A8/"/>
      <url>/2021/09/08/JavaScript%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章：JavaScripst简介"><a href="#第1章：JavaScripst简介" class="headerlink" title="第1章：JavaScripst简介"></a>第1章：JavaScripst简介</h2><h3 id="1-1-JavaScript编程语言"><a href="#1-1-JavaScript编程语言" class="headerlink" title="1.1 JavaScript编程语言"></a>1.1 JavaScript编程语言</h3><p>JavaScript-种轻量级的脚本语言，也是一种<strong>嵌入式</strong>(embedded) 语言，是一种 <strong>对象模型</strong>语言，简称<strong>JS</strong> ;<br>JavaScript的核心语法部分(语言本身)很精简，只包括两个部分:</p><p>1:基本的语法构造(比如操作符、控制结构、语句) ;</p><p>2:标准库(就是一系列具有各种功能的对象比如Array、Date、 Math等) 。</p><p>想要实现其他复杂的操作和效果，都要依靠<strong>宿主环境</strong>提供API,目前，已经嵌入JavaScript的宿主环境有多种，<br>最常见的环境就是<strong>浏览器</strong>，另外还有<strong>服务器环境</strong>(操作系统)</p><p><strong>JavaScript现在的意义(应用场景)</strong><br>JavaScript发展到现在几乎无所不能。</p><ol><li><strong>网页特效</strong>*</li><li>**服务端开发(Node.js) ***</li><li>命令行工具(Node.js)</li><li>桌面程序(Electron)</li><li>App(Cordova)</li><li>控制硬件~物联网(Ruff)</li><li>游戏开发(cocos2d-js)</li></ol><h3 id="1-2-ECMAScript与JavaScript"><a href="#1-2-ECMAScript与JavaScript" class="headerlink" title="1.2 ECMAScript与JavaScript"></a>1.2 ECMAScript与JavaScript</h3><p>ECMA欧洲计算机制造联合会;<br>ECMAScript是一套标准，定义了一种语言的标准，规定了基本语法、数据类型、关键字、具体API的设计规范<br>等，解析引擎设计的参考标准，但与具体实现无关;</p><h3 id="1-3-JavaScript和HTML、CSS"><a href="#1-3-JavaScript和HTML、CSS" class="headerlink" title="1.3 JavaScript和HTML、CSS"></a>1.3 JavaScript和HTML、CSS</h3><ol><li>HTML:提供网页的结构，提供网页中的内容</li><li>CSS:用来样式排版、美化网页</li><li>JavaScript:可以用来控制网页内容，给网页增加动态的效果</li></ol><h3 id="1-4-JS学习概况"><a href="#1-4-JS学习概况" class="headerlink" title="1.4 JS学习概况"></a>1.4 JS学习概况</h3><p>我们在学习JS时，需要学习的内容分为两部分，<strong>语言结构</strong>及宿主环境提供的API;</p><p>语言结构部分主要时语言规则及内置对象;</p><p>而宿主环境的API,根据宿主环境不同而不同，以浏览器为例，最常见的三个类型:<br>浏览器控制类、DOM操作类、网络控制类;</p><p><img src="https://i.loli.net/2021/09/09/QpIGVSyKFxN8d7l.png" alt="image-20210823181355011.png"></p><blockquote><p>总结:</p><p>JavaScript编程语言简称JS,是-种嵌入式的脚本语言，应用范围及其广泛，由布主登-艾奇开发，在20+年的<br>发展中历经沧桑，学习JS分为语言规则及宿主环境两部分;</p></blockquote><h2 id="第2章：入门"><a href="#第2章：入门" class="headerlink" title="第2章：入门"></a>第2章：入门</h2><h3 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 变量</h3><h4 id="2-1-1-什么是变量"><a href="#2-1-1-什么是变量" class="headerlink" title="2.1.1 什么是变量"></a>2.1.1 什么是变量</h4><ul><li><p>什么是变量</p><p>变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据</p></li><li><p>为什么要使用变量</p><p>使用变量可以方便的获取或者修改内存中数据</p></li></ul><p><strong>变量就是存储数据的容器；</strong></p><h4 id="2-1-2-如何使用变量"><a href="#2-1-2-如何使用变量" class="headerlink" title="2.1.2 如何使用变量"></a>2.1.2 如何使用变量</h4><ul><li>var声明变量</li></ul><h3 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h3><h4 id="2-2-1-简单数据类型"><a href="#2-2-1-简单数据类型" class="headerlink" title="2.2.1 简单数据类型"></a>2.2.1 简单数据类型</h4><p>Number, String. Boolean、 Undefined、 Null</p><p><strong>获取变量的类型</strong></p><p>检验数据类型：typeof</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>. log(<span class="keyword">typeof</span> age); <span class="comment">// &#x27; number &#x27;</span></span><br></pre></td></tr></table></figure><h5 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h5><ul><li><p>数值字面量:数值的固定值的表示法</p><p>1101024 60.5</p></li><li><p>浮点数</p><ul><li>浮点数的精度问题</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">浮点数</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">5e-324</span>;<span class="comment">//科学计数法 5乘以10的-324次方</span></span><br><span class="line">浮点数值的最高精度是  <span class="number">17</span>  位小数，但在进行算术计算时其精确度远远不如整数</span><br><span class="line"> <span class="keyword">var</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;<span class="comment">//结果不是0.3, 而是: 0. 3000000000000004</span></span><br><span class="line"> <span class="built_in">console</span>.1og(<span class="number">0.07</span>会<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ul><h5 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h5><p>字符串是存储字符的变量。</p><p>字符串可以是引号中的任意文本。</p><p>’aa‘，”aaa”</p><ul><li><p>字符串字面量</p><pre><code>程序猿&#39;，程序媛，“黑马程序猿&quot;</code></pre></li><li><p>转义符</p></li></ul><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>制表</td></tr><tr><td>\b</td><td>空格</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\f</td><td>走纸换页</td></tr><tr><td>\ \</td><td>斜杠</td></tr><tr><td>\ ‘</td><td>单引号（’），在用单引号表示的字符串中使用。例如：’It&#39;s alright’</td></tr><tr><td>\ “</td><td>双引号（”），在用双引号表示的字符串中使用。例如：var answer2=”He is called &quot;Johnny&quot;“</td></tr><tr><td>\xnn</td><td>以十六进制代码nn表示的一个字符（其中n为0 ~ F）。例如：\x62表示”b“</td></tr><tr><td>\unnn</td><td>以十六进制代码nnnn表示的一个Unicode字符（其中n为0 ~ F）。其中：\u602表示希腊字符“ᘂ”</td></tr></tbody></table><ul><li><p>字符串长度<br>length属性用来获取字符串的长度</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;程序猿HelloIworld&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>. log(str . length);</span><br></pre></td></tr></table></figure></li><li><p>字符串拼接<br>字符串拼接使用+连接</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.1og(<span class="number">11</span> + <span class="number">11</span>);</span><br><span class="line"><span class="built_in">console</span>. log(<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27; world&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>. log(<span class="string">&#x27;100&#x27;</span> + <span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.1log(<span class="string">&#x27;11&#x27;</span> + <span class="number">11</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;male:&#x27;</span> + <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>1.两边只要有一个是字符串，那么 + 就是字符串拼接功能</p><p>2.两边如果都是数字，那么就是算术功能。</p></li></ul><h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><ul><li><p>Boolean字面量: truefOfalse, 区分大小写</p></li><li><p>计算机内部存储: true为1, false为0</p></li></ul><h5 id="Undefined和Null"><a href="#Undefined和Null" class="headerlink" title="Undefined和Null"></a>Undefined和Null</h5><p>undefined表示一个声明了没有赋值的变量， 变量只声明的时候值默认是undefined</p><p>null表示个空，变量的值如果想为null,必须手动设置</p><blockquote><p>注:关于undefined和null是一个面试中很容易被问到的问题，后面的高级部分详解;</p></blockquote><h4 id="2-2-2-复杂数据类型"><a href="#2-2-2-复杂数据类型" class="headerlink" title="2.2.2 复杂数据类型"></a>2.2.2 复杂数据类型</h4><pre><code>Object</code></pre><p>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">firstname</span>:<span class="string">&quot;John&quot;</span>, <span class="attr">lastname</span>:<span class="string">&quot;Doe&quot;</span>, <span class="attr">id</span>:<span class="number">5566</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-3-代码注释"><a href="#2-3-代码注释" class="headerlink" title="2.3 代码注释"></a>2.3 代码注释</h3><p>JavaScript 注释可用于提高代码的可读性。</p><p><strong>单行注释</strong></p><p>以 <strong>//</strong> 开头。</p><p>本例用单行注释来解释代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Lpy&quot;</span></span><br></pre></td></tr></table></figure><p><strong>多行注释</strong></p><p>释以 <strong>/*</strong> 开始，以 ***/** 结尾。</p><p>下面的例子使用多行注释来解释代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*下面的这些代码会输出一个标题和一个段落并将代表主页的开始*/</span><span class="built_in">document</span>.getElementById(<span class="string">&quot;myH1&quot;</span>).innerHTML=<span class="string">&quot;欢迎来到我的主页&quot;</span>;<span class="built_in">document</span>.getElementById(<span class="string">&quot;myP&quot;</span>).innerHTML=<span class="string">&quot;这是我的第一个段落。&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>用代码来组织执行</strong></p><p>在下面的例子中，注释用于阻止其中一条代码行的执行（可用于调试）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// document.getElementById(&quot;myH1&quot;).innerHTML=&quot;欢迎来到我的主页&quot;;document.getElementById(&quot;myP&quot;).innerHTML=&quot;这是我的第一个段落。&quot;;</span></span><br></pre></td></tr></table></figure><p>在下面的例子中，注释用于阻止代码块的执行（可用于调试）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*document.getElementById(&quot;myH1&quot;).innerHTML=&quot;欢迎来到我的主页&quot;;document.getElementById(&quot;myP&quot;).innerHTML=&quot;这是我的第一个段落。&quot;;*/</span></span><br></pre></td></tr></table></figure><p><strong>在行末使用注释</strong></p><p>把注释放到代码行的结尾处：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;    <span class="comment">// 声明 x 并把 5 赋值给它var y = x + 2;  // 声明 y 并把 x+2 赋值给它</span></span><br></pre></td></tr></table></figure><h2 id="第3章：数据类型转换"><a href="#第3章：数据类型转换" class="headerlink" title="第3章：数据类型转换"></a>第3章：数据类型转换</h2><h3 id="3-1-转换成字符串类型"><a href="#3-1-转换成字符串类型" class="headerlink" title="3.1 转换成字符串类型"></a>3.1 转换成字符串类型</h3><ul><li><p>toString()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">5</span>;<span class="built_in">console</span>.1og(num. toString());</span><br></pre></td></tr></table></figure></li><li><p>String()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = nu11;<span class="built_in">console</span>.1og(s.toString());<span class="built_in">console</span>.1og(<span class="built_in">String</span>(s));<span class="comment">// String()函数存在的意义:有些值没有toString(),//这个时候可以使用String().比如: undefined和nu11</span></span><br></pre></td></tr></table></figure></li><li><p>拼接字符串方式</p><p>num + ‘’,当 + 两边一个操作符是字符串类型，一个操作符是其他类型时，会先把其他类型转换成字符串在进行字符串拼接，返回字符串。</p></li></ul><h3 id="3-2-转换成数值类型"><a href="#3-2-转换成数值类型" class="headerlink" title="3.2 转换成数值类型"></a>3.2 转换成数值类型</h3><ul><li><p>Number</p><p>全局方法 <strong>Number()</strong> 可以将字符串转换为数字。</p><p>字符串包含数字(如 “3.14”) 转换为数字 (如 3.14).</p><p>空字符串转换为 0。</p><p>其他的字符串会转换为 NaN (不是个数字)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&quot;3.14&quot;</span>)    <span class="comment">// 返回 3.14Number(&quot; &quot;)       // 返回 0Number(&quot;&quot;)        // 返回 0Number(&quot;99 88&quot;)   // 返回 NaN</span></span><br></pre></td></tr></table></figure><p>其它转换方法：</p></li></ul><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>parseFloat()</td><td>解析一个字符串，并返回一浮点数</td></tr><tr><td>parseInt()</td><td>解析一个字符串，并返回一个整数</td></tr></tbody></table><h3 id="3-3-转换成布尔类型"><a href="#3-3-转换成布尔类型" class="headerlink" title="3.3 转换成布尔类型"></a>3.3 转换成布尔类型</h3><p>Boolean()；</p><p>字符串类型中只要有内容转为布尔类型即为true。</p><h2 id="第4章：操作符"><a href="#第4章：操作符" class="headerlink" title="第4章：操作符"></a>第4章：操作符</h2><p>表达式：值和操作符，运算会产生结果；</p><p>同时，表达式中的每个数值及部分表达式，又称为<code>子表达式</code></p><h3 id="4-1-算术运算式"><a href="#4-1-算术运算式" class="headerlink" title="4.1 算术运算式"></a>4.1 算术运算式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ - * / %</span><br></pre></td></tr></table></figure><h3 id="4-2-一元运算符"><a href="#4-2-一元运算符" class="headerlink" title="4.2 一元运算符*"></a>4.2 一元运算符*</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">++  --  （对自身操作的加一或减一）</span><br></pre></td></tr></table></figure><p>先做自加/自减运算再做其他运算</p><h3 id="4-3-逻辑运算符"><a href="#4-3-逻辑运算符" class="headerlink" title="4.3 逻辑运算符"></a>4.3 逻辑运算符</h3><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>！     逻辑非运算符</td><td>获取相反的结果，true变false，false变true</td></tr><tr><td>&amp;&amp;   逻辑与运算符</td><td>参与运算的数据必须同时为真，结果为真</td></tr><tr><td>||     逻辑或运算符</td><td>参与运算的数据只要有一个为真，结果为真</td></tr></tbody></table><h3 id="4-4-比较运算符"><a href="#4-4-比较运算符" class="headerlink" title="4.4 比较运算符"></a>4.4 比较运算符</h3><p>比较运算符在逻辑语句中使用，以测定变量或值是否相等。</p><p>x=5，下面的表格解释了比较运算符：</p><table><thead><tr><th>运算符</th><th>描述</th><th>比较</th><th>返回值</th></tr></thead><tbody><tr><td>==</td><td>等于</td><td>x == 9<br />x == 5</td><td>false<br />true</td></tr><tr><td>===</td><td>绝对等于（值和类型都相等）</td><td>x === “5”<br />x === 5</td><td>false<br />true</td></tr><tr><td>!=</td><td>不等于</td><td>x != “5”<br />x != 5</td><td>true<br />false</td></tr><tr><td>!==</td><td>不绝对等于（值和类型有一个不相等，或两个都不相等）</td><td>x !== “5”<br />x !== 5</td><td>false<br />true</td></tr><tr><td>&gt;</td><td>x!==5大于</td><td>x &gt; 8</td><td>false</td></tr><tr><td>&lt;</td><td>小于</td><td>x &lt; 8</td><td>true</td></tr><tr><td>&gt;=</td><td>大于或等于</td><td>x &gt;= 8</td><td>false</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>x &lt;=8</td><td>true</td></tr></tbody></table><h3 id="4-5-赋值运算"><a href="#4-5-赋值运算" class="headerlink" title="4.5 赋值运算"></a>4.5 赋值运算</h3><p>赋值运算符用于给 JavaScript 变量赋值。</p><p>给定 <strong>x=10</strong> 和 <strong>y=5</strong>，下面的表格解释了赋值运算符：</p><table><thead><tr><th>运算符</th><th>例子</th><th>等同于</th><th>运算结果</th></tr></thead><tbody><tr><td>=</td><td>x = y</td><td></td><td>x = 5</td></tr><tr><td>+=</td><td>x += y</td><td>x = x + y</td><td>x = 15</td></tr><tr><td>-=</td><td>x -= y</td><td>x = x - y</td><td>x = 5</td></tr><tr><td>*=</td><td>x *= y</td><td>x = x * y</td><td>x = 50</td></tr><tr><td>/=</td><td>x /= y</td><td>x = x / y</td><td>x = 2</td></tr><tr><td>%=</td><td>x %= y</td><td>x = x % y</td><td>x = 0</td></tr></tbody></table><h3 id="4-6-运算符优先级"><a href="#4-6-运算符优先级" class="headerlink" title="4.6 运算符优先级*"></a>4.6 运算符优先级*</h3><p> JavaScript 运算符优先级，是描述在计算机运算计算表达式时执行运算的先后顺序。 先执行具有较高优先级的运算，然后执行较低优先级的运算。 例如，我们常说的先执行相乘和除，再执行加减运算。</p><table><thead><tr><th>优先级</th><th>运算符</th><th>说明</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>[]、. 、()</td><td>字段访问、数组索引、函数调用、表达式分组</td><td>从左往右</td></tr><tr><td>2</td><td>++、–、-、~、！、delete、new、typeof、void</td><td>一元运算符、返回数据类型、对象创建、未定的的值</td><td>从右往左</td></tr><tr><td>3</td><td>*、/、%</td><td>相乘、相除、求余数</td><td>从左往右</td></tr><tr><td>4</td><td>+、-</td><td>相加、相减、字符串串联</td><td>从左往右</td></tr><tr><td>5</td><td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td><td>左移位、右移位、无符号移位</td><td>从左往右</td></tr><tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td><td>小于、小于或等于、大于、大于或等于、是否为特定类的实例</td><td>从左往右</td></tr><tr><td>7</td><td>==、!=、===、!==</td><td>相等、不相等、全等、不全等</td><td>从左往右</td></tr><tr><td>8</td><td>&amp;</td><td>按位“与”</td><td>从左往右</td></tr><tr><td>9</td><td>^</td><td>按位“亦或“</td><td>从左往右</td></tr><tr><td>10</td><td>|</td><td>按位”或“</td><td>从左往右</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>短路与（逻辑”与“）</td><td>从左往右</td></tr><tr><td>12</td><td>||</td><td>短路或（”逻辑“或”）</td><td>从左往右</td></tr><tr><td>13</td><td>?、：</td><td>条件运算符</td><td>从右往左</td></tr><tr><td>14</td><td>=、+=、-=、*=、/=、%=、&amp;=、|=、^=、&lt;、&lt;=、&gt;、&gt;=、&gt;&gt;=</td><td>混合赋值运算符</td><td>从右往左</td></tr><tr><td>15</td><td>,</td><td>多个计算</td><td>按优先级计算，然后从右往左</td></tr></tbody></table><h2 id="第5章：流程控制"><a href="#第5章：流程控制" class="headerlink" title="第5章：流程控制"></a>第5章：流程控制</h2><p>程序的三种基本结构</p><p><strong>顺序结构</strong>：从上到下执行的代码就是顺序结构</p><p>程序默认就是由上到下顺序执行的;</p><p><strong>分支结构</strong>：根据不同的情况及判断,执行对应代码;</p><p>循环结构：重复执行一段代码;</p><h3 id="5-1-分支结构"><a href="#5-1-分支结构" class="headerlink" title="5.1 分支结构"></a>5.1 分支结构</h3><h4 id="5-1-1-if语句"><a href="#5-1-1-if语句" class="headerlink" title="5.1.1 if语句"></a>5.1.1 if语句</h4><p>条件语句用于基于不同的条件来执行不同的动作。</p><p><strong>if</strong>：只有当指定条件为 true 时，该语句才会执行代码。</p><p>语法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)&#123;   <span class="comment">// 当条件为 true 时执行的代码&#125;</span></span><br></pre></td></tr></table></figure><p><strong>if……else</strong>：在条件为 true 时执行代码，在条件为 false 时执行其他代码。</p><p>语法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)&#123;    <span class="comment">// 当条件为 true 时执行的代码&#125;else&#123;    // 当条件不为 true 时执行的代码&#125;</span></span><br></pre></td></tr></table></figure><p><strong>if…else if…else</strong> ：选择多个代码块之一来执行</p><p>语法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)&#123;    <span class="comment">// 当条件 1 为 true 时执行的代码&#125;else if (condition2)&#123;    // 当条件 2 为 true 时执行的代码&#125;else&#123;  // 当条件 1 和 条件 2 都不为 true 时执行的代码&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-1-2-switch-语句"><a href="#5-1-2-switch-语句" class="headerlink" title="5.1.2  switch 语句"></a>5.1.2  switch 语句</h4><p>switch 语句用于基于不同的条件来执行不同的动作。</p><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(n)&#123;    <span class="keyword">case</span> <span class="number">1</span>:        执行代码块 <span class="number">1</span>        <span class="keyword">break</span>;    <span class="keyword">case</span> <span class="number">2</span>:        执行代码块 <span class="number">2</span>        <span class="keyword">break</span>;    <span class="keyword">default</span>:        与 <span class="keyword">case</span> <span class="number">1</span> 和 <span class="keyword">case</span> <span class="number">2</span> 不同时执行的代码&#125;</span><br></pre></td></tr></table></figure><p><strong>default 关键词</strong></p><p>用 default 关键词来规定匹配不存在时做的事情：</p><h3 id="5-2-循环结构"><a href="#5-2-循环结构" class="headerlink" title="5.2 循环结构"></a>5.2 循环结构</h3><blockquote><p>在 JS 语言中，循环语句有三种，while、do……while、for循环。</p></blockquote><h4 id="5-2-1-while-语句"><a href="#5-2-1-while-语句" class="headerlink" title="5.2.1 while 语句"></a>5.2.1 while 语句</h4><p>while 循环会在指定条件为真时循环执行代码块。</p><p><strong>基本语法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件)&#123;    <span class="comment">// 需要执行的代码&#125;</span></span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量 i 小于5时结束循环while (i&lt;5)&#123;    x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;    i++;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-2-do……while-语句"><a href="#5-2-2-do……while-语句" class="headerlink" title="5.2.2 do……while 语句"></a>5.2.2 do……while 语句</h4><p>do/while 循环是 while 循环的变体。该循环会在检查条件是否为真之前执行一次代码块，然后如果条件为真的话，就会重复这个循环。</p><p><strong>语法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;    需要执行的代码&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该循环至少会执行一次，即使条件为 false 它也会执行一次，因为代码块会在条件被测试前执行do&#123;    x=x + &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;    i++;&#125; while (i&lt;5);</span></span><br></pre></td></tr></table></figure><h4 id="5-2-3-for语句"><a href="#5-2-3-for语句" class="headerlink" title="5.2.3 for语句*"></a>5.2.3 for语句*</h4><p><strong>不同类型的循环</strong></p><p>JavaScript 支持不同类型的循环：</p><ul><li><strong>for</strong> - 循环代码块一定的次数</li><li><strong>for/in</strong> - 循环遍历对象的属性</li></ul><p>for 循环可以将代码块执行指定的次数。</p><p><strong>基本语法</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句 <span class="number">1</span>; 语句 <span class="number">2</span>; 语句 <span class="number">3</span>)&#123;    <span class="comment">// 被执行的代码块&#125;</span></span><br></pre></td></tr></table></figure><p><strong>语句 1</strong> （代码块）开始前执行</p><p><strong>语句 2</strong> 定义运行循环（代码块）的条件</p><p><strong>语句 3</strong> 在循环（代码块）已被执行之后执行</p><p>for/in 语句循环遍历对象的属性：</p><p><strong>实例</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">fname</span>:<span class="string">&quot;Bill&quot;</span>,<span class="attr">lname</span>:<span class="string">&quot;Gates&quot;</span>,<span class="attr">age</span>:<span class="number">56</span>&#125;;  <span class="keyword">for</span> (x <span class="keyword">in</span> person)  <span class="comment">// x 为属性名&#123;    txt=txt + person[x];&#125;</span></span><br></pre></td></tr></table></figure><p>5.2.4 continue 和 break</p><blockquote><p>continue 用于跳过循环中的一个迭代。</p><p>break 语句用于跳出循环。</p></blockquote><p><strong>continue 语句</strong></p><p>continue语句中断循环中的迭代，如果出现了指定的条件，然后继续循环中的下一个迭代。 该例子跳过了值 3：</p><p>案例1：计算100以内 不能被7整除的数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;<span class="keyword">if</span>(i%<span class="number">7</span>==<span class="number">0</span>)&#123;<span class="keyword">continue</span>;&#125;num += i;&#125;</span><br></pre></td></tr></table></figure><p><strong>break 语句</strong></p><p>break 用于跳出 switch() 语句。</p><p>break 语句可用于跳出循环。</p><p>break 语句跳出循环后，会继续执行该循环之后的代码（如果有的话）：</p><p>案例2：打印200-300之间 第一个 能被7整除的数字</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">200</span>;i&lt;=<span class="number">300</span>;i++)&#123;<span class="keyword">if</span>(i%<span class="number">7</span> == <span class="number">0</span>)&#123;<span class="keyword">break</span>;&#125;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：</p><p>代码的执行流程分为顺序、分支和循环三种，顺序结构时默认的，判断结构主要有if-else和switch-case两种，循环结构右while、do-while和for三种，其中continue和break是跳出循环。</p></blockquote><h2 id="第6章：Js中特殊对象-数组"><a href="#第6章：Js中特殊对象-数组" class="headerlink" title="第6章：Js中特殊对象-数组"></a>第6章：Js中特殊对象-数组</h2><blockquote><p>所谓数组，就是将多个元素(通常是同一类型)按定顺序排列放到一 个集合中，那么这个集合我们就称之<br>为数组。</p></blockquote><blockquote><p>数组可以用一个变量名存储所有的值，并且可以用变量名访问任何一个值。</p><p>数组中的每个元素都有自己的的ID，以便它可以很容易地被访问到。</p></blockquote><h3 id="6-1-数组的创建"><a href="#6-1-数组的创建" class="headerlink" title="6.1 数组的创建"></a>6.1 数组的创建</h3><p>创建一个数组，有三种方法：</p><p>下面代码定义了一个userName的数组对象：</p><ol><li><p>常规方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> userName = <span class="keyword">new</span> <span class="built_in">Array</span>();userName[<span class="number">0</span>] = <span class="string">&quot;Lisa&quot;</span>;userName[<span class="number">1</span>] = <span class="string">&quot;Mria&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>简介方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var userName = new Array(&quot;Lisa&quot;,&quot;Mria&quot;);</span><br></pre></td></tr></table></figure></li><li><p>字面：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var userName = [&quot;Lisa&quot;,&quot;Mria&quot;];</span><br></pre></td></tr></table></figure></li></ol><p>数组里面可以有数组，将这样的情况称为 <strong>多维数组</strong></p><h3 id="6-2-获取数组"><a href="#6-2-获取数组" class="headerlink" title="6.2 获取数组"></a>6.2 获取数组</h3><p>数组内容称为下标</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;yellow&#x27;</span>];<span class="built_in">console</span>.log(str[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h3 id="6-3-循环遍历数组"><a href="#6-3-循环遍历数组" class="headerlink" title="6.3 循环遍历数组"></a>6.3 循环遍历数组</h3><p>案例1： 求数组元素的和</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>];<span class="keyword">var</span> sum = <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;sum += arr[i];&#125;<span class="built_in">console</span>.log(sum);</span><br></pre></td></tr></table></figure><p>案例2：打印出数组中最大的数值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>];<span class="keyword">var</span> nuMax = <span class="number">0</span>;<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;<span class="keyword">if</span>(nuMax&lt;arr[i])nuMax = arr[i];&#125;<span class="built_in">console</span>.log(nuMax);</span><br></pre></td></tr></table></figure><p>案例3：打印数组中所有的偶数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>];<span class="keyword">var</span> newArr = [];<span class="keyword">var</span> j = 0<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++</span>)</span>&#123;<span class="keyword">if</span>(arr[i]%<span class="number">2</span> == <span class="number">0</span>)&#123;newArr[j] = arr[i];j++;&#125;&#125;<span class="built_in">console</span>.log(newArr);</span><br></pre></td></tr></table></figure><p>案例4：求数组中的元素 以 | 分割为一个字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">67</span>,<span class="number">78</span>,<span class="number">89</span>,<span class="number">90</span>];<span class="keyword">var</span> str = <span class="string">&#x27;&#x27;</span>;<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;str += arr[i] + <span class="string">&#x27; | &#x27;</span>;&#125;<span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure><h2 id="第7章：函数"><a href="#第7章：函数" class="headerlink" title="第7章：函数"></a>第7章：函数</h2><blockquote><p>把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体， 就是函数，起个名字(函数名)，<br>在后续开发中可以反复调用</p><p>函数的作用就是封装一段代码， 将来可以重复使用</p></blockquote><h3 id="7-1-函数的声明及调用"><a href="#7-1-函数的声明及调用" class="headerlink" title="7.1 函数的声明及调用"></a>7.1 函数的声明及调用</h3><h4 id="7-1-1-声明"><a href="#7-1-1-声明" class="headerlink" title="7.1.1 声明"></a>7.1.1 声明</h4><ul><li><p>关键字声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;<span class="comment">// 函数体&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>表达式声明</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="title">funtion</span>(<span class="params"></span>)</span> &#123;<span class="comment">// 函数体&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="7-1-2-调用"><a href="#7-1-2-调用" class="headerlink" title="7.1.2 调用"></a>7.1.2 调用</h4><p>实例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&quot;Hello world!&quot;</span>);&#125;f();    <span class="comment">//返回&quot;Hello world!</span></span><br></pre></td></tr></table></figure><blockquote><p>总结：</p><p>函数声明后，函数体不会执行</p><p>函数中的代码想要执行，必须调用这个函数（不管什么情况，函数不调用就一定会执行）</p></blockquote><h3 id="7-2-形参和实参"><a href="#7-2-形参和实参" class="headerlink" title="7.2 形参和实参"></a>7.2 形参和实参</h3><ul><li>形参是一种形式上的参数，没有实际意义</li><li>形式参数：是在函数声明是写的，多个形参使用’，‘隔开，形参的值不固定，形参仅仅是一个占位；</li><li>与实参实际传入的值要一一对应</li></ul><ul><li>实际参数：在调用时，实际传入函数的值，多个值使用’，‘隔开；传入后，在函数中使用形参获取具体的值；</li></ul><p>语法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">形参<span class="number">1</span>，形参<span class="number">2</span>，形参<span class="number">3</span>……</span>)</span>&#123;<span class="comment">// 函数体&#125;fun(实参1，实参2，实参3……);</span></span><br></pre></td></tr></table></figure><p>案例：计算1 ~ n 的和</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;    <span class="keyword">var</span> sum = <span class="number">0</span>;    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;        sum += i;    &#125;<span class="built_in">console</span>.log(sum);&#125;fun(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>输出结果为：5050</p><h3 id="7-3-函数返回值"><a href="#7-3-函数返回值" class="headerlink" title="7.3 函数返回值"></a>7.3 函数返回值</h3><p>语法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">形参<span class="number">1</span>，形参<span class="number">2</span>，形参<span class="number">3</span>……</span>)</span>&#123;<span class="comment">// 函数体return 返回值;&#125;var f = fun(实参1，实参2，实参3……);</span></span><br></pre></td></tr></table></figure><p>案例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">var</span> n = a * b;    <span class="keyword">return</span> n;&#125;<span class="keyword">var</span> s = fun(<span class="number">4</span>,<span class="number">6</span>);<span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>若函数中没有return，那么函数调用后接到的返回值就是 undefined</p><p>若函数中没有return，但return 后面没有返回值，那么函数调用后接到的返回值就是 undefined</p></blockquote><h3 id="7-4-函数相关的其他事情"><a href="#7-4-函数相关的其他事情" class="headerlink" title="7.4 函数相关的其他事情"></a>7.4 函数相关的其他事情</h3><h4 id="7-4-1-匿名函数与自调用函数"><a href="#7-4-1-匿名函数与自调用函数" class="headerlink" title="7.4.1 匿名函数与自调用函数"></a>7.4.1 匿名函数与自调用函数</h4><blockquote><p>匿名函数：没有名字的函数</p></blockquote><p>匿名函数如何使用：</p><p>将匿名函数赋值给一个变量，这样就可以通过变量进行调用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="function"><span class="title">funtion</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;fun();</span><br></pre></td></tr></table></figure><blockquote><p>匿名函数如果没有任何变量来表示它，那么就不能直接调用来执行，因此可以通过匿名函数的自调方式来执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="title">funtion</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">123</span>);&#125;)();</span><br></pre></td></tr></table></figure><p>关于自执行函数（匿名函数的自调用）的作用：防止全局变量污染。</p><h4 id="7-4-2-函数本身也是值"><a href="#7-4-2-函数本身也是值" class="headerlink" title="7.4.2 函数本身也是值*"></a>7.4.2 函数本身也是值*</h4><blockquote><p>函数也是一种数据类型</p><p>function    数据类型 – &gt; 对象（数组、函数）</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">s</span>)</span>&#123;s();&#125;<span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">222</span>);&#125;<span class="comment">// f2函数会被当作值，传入f1内// 回调f1(f2);</span></span><br></pre></td></tr></table></figure><h3 id="7-5闭包"><a href="#7-5闭包" class="headerlink" title="7.5闭包"></a>7.5闭包</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;    <span class="keyword">var</span> counter = <span class="number">0</span>;    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> counter += <span class="number">1</span>;&#125;&#125;)(); add();add();add();</span><br></pre></td></tr></table></figure><p>变量 <strong>add</strong> 指定了函数自我调用的返回字值。</p><p>自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。</p><p>add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。</p><p>这个叫作 JavaScript <strong>闭包。</strong>它使得函数拥有私有变量变成可能。</p><p>计数器受匿名函数的作用域保护，只能通过 add 方法修改。</p><blockquote><p>闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。</p><p>直观的说就是形成一个不销毁的栈环境。</p></blockquote><h2 id="第8章：作用域与JS代码的运行"><a href="#第8章：作用域与JS代码的运行" class="headerlink" title="第8章：作用域与JS代码的运行*"></a>第8章：作用域与JS代码的运行*</h2><blockquote><p>作用域：变量可以起作用的范围和区域</p></blockquote><h3 id="8-1-全局变量和局部变量"><a href="#8-1-全局变量和局部变量" class="headerlink" title="8.1  全局变量和局部变量*"></a>8.1  全局变量和局部变量*</h3><ul><li><p>全局变量与全局作用域</p><p>在任何地方都可以访问到的变量就是 <strong>全局变量</strong> </p></li><li><p>局部变量</p><p>只在固定的代码片段内可访问到的变量，最常见的例如函数内部的变量，就是 <strong>局部变量</strong>。局部变量所在的区域就是 <strong>局部作用域</strong>（函数作用域）</p><blockquote><p>不使用var声明的变量时全局变量，不推荐使用</p><p>变量推出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁</p><p>函数内部可以访问外部的变量，但是函数外部不可以访问函数内部的变量</p><p>函数内部若有变量，就优先使用内部的变量，如果没有，才会使用函数外部变量</p></blockquote></li></ul><h3 id="8-2-变量提升及代码执行阶段"><a href="#8-2-变量提升及代码执行阶段" class="headerlink" title="8.2 变量提升及代码执行阶段"></a>8.2 变量提升及代码执行阶段</h3><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p><p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p><blockquote><p>JS 代码的运行分为两个阶段：</p><ol><li><p>解析（编译）阶段：语法检查，变量及函数进行声明</p></li><li><p>运行阶段：变量的赋值，代码流程的执行</p></li></ol></blockquote><p>如果函数与变量同名，那么函数声明会替换变量声明</p><h3 id="8-3作用域链"><a href="#8-3作用域链" class="headerlink" title="8.3作用域链 *"></a>8.3作用域链 *</h3><blockquote><p>只有函数可以制造作用域链，那么只要时代码，就至少有一个作用域，即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。</p><p>将这样的所有的作用域列出来，可以有一个就够：函数内指向函数外的链式结构。就称作作用域链。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(a);&#125;f3();&#125;f2();&#125;f1();</span><br></pre></td></tr></table></figure><blockquote><p>当函数中使用某个变量，优先在自己的作用域中查找</p><p>如果找不到，就会向上一层作用域查找</p><p>如果找不到继续往上一层查找，直到全局作用域</p><p>如果还找不到直接报错</p><p>这就是  <strong>作用域链</strong></p></blockquote><h2 id="第9章：对象（Object）"><a href="#第9章：对象（Object）" class="headerlink" title="第9章：对象（Object）"></a>第9章：对象（Object）</h2><h3 id="9-1-什么是对象"><a href="#9-1-什么是对象" class="headerlink" title="9.1 什么是对象"></a>9.1 什么是对象</h3><p><strong>万物就对象</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。举例：一部车，一个手机车是一类事物，门口停的那辆车才是对象特征：红色、四个轮子行为：驾驶、刹车</span><br></pre></td></tr></table></figure><h3 id="9-2-JavaScript-中的对象"><a href="#9-2-JavaScript-中的对象" class="headerlink" title="9.2 JavaScript 中的对象"></a>9.2 JavaScript 中的对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JavaScript 中的对象其实就是生活中对象的一个抽象JavaScript 的对象是无序属性的集台。其属性可以包含基本值、对象、数组或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。对象的行为和特征特征---属性行为---方法</span><br></pre></td></tr></table></figure><p><strong>事物的特征在对象中用属性来表示</strong></p><p><strong>事物的行为在对象中用方法来表示</strong></p><h3 id="9-3-如何得到一个对象"><a href="#9-3-如何得到一个对象" class="headerlink" title="9.3 如何得到一个对象"></a>9.3 如何得到一个对象</h3><ul><li><p>字面量方式创建对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj1 = &#123;&#125;;//得到一个空对象// 对象中的数据都是键值对存在的// 通常来说，值是函数则称为方法，其他类型的值都是属性。var obj2 = &#123;age:12,wei:90,name:&#x27;Lisa&#x27;,f:function()&#123;&#125;&#125;; </span><br></pre></td></tr></table></figure></li><li><p>实例化方式   声明对象（内置构造函数）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new Object();</span><br></pre></td></tr></table></figure></li><li><p>实例化自定义构造函数方式声明对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 自定义构造函数方式function fun()&#123;&#125;var f = new fun();</span><br></pre></td></tr></table></figure></li></ul><p>获取对象的属性或方法    </p><ul><li><p>对象.属性名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;    <span class="attr">age</span>:<span class="number">12</span>,    <span class="attr">wei</span>:<span class="number">90</span>,    <span class="attr">name</span>:<span class="string">&#x27;西岭雪山&#x27;</span>,    <span class="attr">fun</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;       <span class="built_in">console</span>.log(<span class="string">&#x27;这是一段自我介绍&#x27;</span>)    &#125;&#125;;<span class="keyword">var</span> obj = obj2.name;<span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure></li><li><p>对象.方法名</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;    <span class="attr">age</span>:<span class="number">12</span>,    <span class="attr">wei</span>:<span class="number">90</span>,    <span class="attr">name</span>:<span class="string">&#x27;西岭雪山&#x27;</span>,    <span class="attr">fun</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;       <span class="built_in">console</span>.log(<span class="string">&#x27;这是一段自我介绍&#x27;</span>)    &#125;&#125;;<span class="keyword">var</span> obj = obj2.fun();<span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-4-this-的指向"><a href="#9-4-this-的指向" class="headerlink" title="9.4 this 的指向"></a>9.4 this 的指向</h3><blockquote><p>JavaScript中的this指向问题，比较复杂，有时候会让人难以捉摸，随着学习的深入，我们会不断接触this,</p><p>在学习过程中，我们可以不断总结，最终搞清楚this在何种情况下指向..处….</p><p>目前，我们只需要记住以下两点就可以了:</p><pre><code> 1. 函数如果在某个对象下，this就指向这个对象2. 函数如果被直接调用，this指向window对象3. 在方法中的this指的就是这个方法所在的对象</code></pre></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;        <span class="attr">age</span>:<span class="number">12</span>,        <span class="attr">wei</span>:<span class="number">90</span>,        <span class="attr">name</span>:<span class="string">&#x27;西岭雪山&#x27;</span>,        <span class="attr">fun</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;            <span class="keyword">var</span> s = <span class="built_in">this</span>.age;            <span class="built_in">console</span>.log(s);        &#125;    &#125;;    obj2.fun();</span><br></pre></td></tr></table></figure><p>普通函数中也是有 this ，它指向全局对象（window）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;   <span class="built_in">console</span>.log(<span class="built_in">this</span>);&#125;f();</span><br></pre></td></tr></table></figure><p>this 永远指向一个对象</p><p>this 在什么情况下什么地方 指向那个对象？</p><blockquote><p>this 运行在哪个对象下，就指向哪个对象</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">k = <span class="string">&#x27;678&#x27;</span>;<span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> k = <span class="string">&#x27;89&#x27;</span>;<span class="built_in">console</span>.log(<span class="built_in">this</span>.k);&#125;<span class="keyword">var</span> o1 = &#123;<span class="attr">k</span>:<span class="string">&#x27;123&#x27;</span>,<span class="attr">f</span>:fun,&#125;<span class="keyword">var</span> o2 = &#123;<span class="attr">k</span>:<span class="string">&#x27;345&#x27;</span>,<span class="attr">f</span>:fun,&#125;o1.f();o2.f();</span><br></pre></td></tr></table></figure><h3 id="9-5-对象的遍历级删除"><a href="#9-5-对象的遍历级删除" class="headerlink" title="9.5 对象的遍历级删除"></a>9.5 对象的遍历级删除</h3><p>for(键 in 对象)</p><p>for…in  循环不仅可以循环变量还可以循环遍历数组</p><p>案例1：遍历对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>:<span class="string">&#x27;Lise&#x27;</span>,    <span class="attr">age</span>:<span class="number">16</span>,    <span class="attr">sex</span>:<span class="string">&#x27;female&#x27;</span>&#125;<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o1)&#123;    <span class="built_in">console</span>.log(o1[k]);&#125;</span><br></pre></td></tr></table></figure><p>案例2：遍历数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;    <span class="built_in">console</span>.log(arr[i]);&#125;</span><br></pre></td></tr></table></figure><p>案例3：删除</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;    <span class="attr">name</span>:<span class="string">&#x27;Lise&#x27;</span>,    <span class="attr">age</span>:<span class="number">16</span>,    <span class="attr">sex</span>:<span class="string">&#x27;female&#x27;</span>&#125;<span class="built_in">console</span>.log(o1);<span class="keyword">delete</span> o1.name;    <span class="built_in">console</span>.log(o1);</span><br></pre></td></tr></table></figure><h3 id="9-6-包装对象"><a href="#9-6-包装对象" class="headerlink" title="9.6 包装对象"></a>9.6 包装对象</h3><p>三种原始类型：数值、字符串、布尔</p><p>原始类型的数据在一定条件下可以自动转换为对象，这就是包装对象</p><p>原始值  可以自动当作对象来调用，可以调用各种属性及方法</p><p>如果包装对象使用完成，会自动立即销毁</p><h2 id="第10章：标准库对象-内置映射"><a href="#第10章：标准库对象-内置映射" class="headerlink" title="第10章：标准库对象(内置映射)"></a>第10章：标准库对象(内置映射)</h2><p>JavaScript 提供了很多个内置对象: Math/Array/Number/String/Boolean… </p><p>对象只是带有<strong>属性</strong>和<strong>方法</strong>的特殊数据类型。</p><p>遇到问题👉<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">火狐官方开发文档</a></p><pre><code>                 [微软官方开发文档](https://docs.microsoft.com/zh-cn/samples/browse/?languages=javascript&amp;skip=60)</code></pre><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul><li><p>缩进</p><p>空格和tab皆可，尽量保持一种，使用一种:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个空格和四个空格都可以，尽量保持一致就行，但是使用4个空格的居多</span><br></pre></td></tr></table></figure></li><li><p>分号</p><p>尽量不要忘记，每一行的结束都要加分号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 和 <span class="keyword">for</span> 循环后面不需要分号<span class="keyword">if</span>……<span class="keyword">else</span> 、<span class="keyword">switch</span>等分支语句后面不要加分号关键字声明函数，后面不要加分号表达式声明函数，函数后面不要加分号</span><br></pre></td></tr></table></figure></li><li><p>区块</p><p>两种写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="number">2.</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2021/09/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/09/08/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h2><h3 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h3><p>典型的搜索和替换要求你提供与预期的搜索结果匹配的确切文本。虽然这种技术对于静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得困难。</p><p>通过正则表达式，可以：</p><ul><li><p>测试字符串内的模式。</p><p>例如，可以测试输入字符串，已看出字符串内是否出现电话号码或信用卡号码模式。这称为<strong>数据验证</strong>。</p></li><li><p>替换文本。</p><p>可以使用正则表达式来识别文档中的特定文本，完全删除文本或者用其他文本来替换它。</p></li><li><p>基于模式匹配从字符串中提取子字符串。</p><p>可以查找文档或输入域内特定的文本。</p></li></ul><h2 id="第2章-语法"><a href="#第2章-语法" class="headerlink" title="第2章 语法"></a>第2章 语法</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式(pattern)，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p><p>例如：</p><ul><li><code>biile+b</code>，可以匹配biileeb、biileeeeb、biileeeeeeeeb等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</li><li><code>biile*b</code>，可以匹配biilb、biileeb、biileeeeeb等，* 号代表前面的字符可以不出现，也可以出现一次后者多次（0次、或1次、或多次）。</li><li>colou?r，可以匹配color或者color，？代表前面的字符最多只可以出现一次（0次、或1次）。</li></ul><p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符域运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p><p>正则表达式是由普通字符（例如字符a到z）以及特殊字符（称为“元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式域搜索的字符串进行匹配。</p><hr><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括某有显式指定为元字符的所有可打印和不可打印字符。这包括所有大小写字母、所有数字、所有标点符号和一些其他符号。</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>[ABC]</td><td>匹配<code>[...]</code>中的所有字符，例如<code>[aeiou]</code>匹配字符串”google biile bing”中除了a e i o u 字母<br /><img src="https://i.loli.net/2021/09/08/7UezuNw1oXak4SA.png" alt="[ABC].png"></td></tr><tr><td>[^ABC]</td><td>匹配除了<code>[...]</code>中字符的所有字符，例如<code>[^aeiou]</code>匹配字符串”google biile bing”中除了a e i o u字母的所有字母<br /><img src="https://i.loli.net/2021/09/08/OAx6eyKVcUoG9Xl.png" alt="[^ABC].png"></td></tr><tr><td>[A-Z]</td><td>[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母<br /><img src="https://i.loli.net/2021/09/08/47V3NsZgYufDWRA.png" alt="[A-Z].png"></td></tr><tr><td></td><td>匹配除换行符（\n、\r）之外的任何单个字符，相等于<code>[^\n\r]</code><br /><img src="https://i.loli.net/2021/09/08/IUaNk7JL2zvefYc.png" alt="[.].png"></td></tr><tr><td>[\s\S]</td><td>匹配所有。\s是匹配所有空白符，包括换行，\S非空白符，不包括换行<br /><img src="https://i.loli.net/2021/09/08/15Vv2uEzi8ALTp4.png" alt="sS.png"></td></tr><tr><td>\w</td><td>匹配字母、数字、下划线。等价于<code>[A-Za-z0-9]</code><br /><img src="https://i.loli.net/2021/09/08/UTokb7m3yGprSFP.png" alt="w.png"></td></tr></tbody></table><hr><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下表列出表示非打印字符的转义序列：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\cx</td><td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table><hr><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <code>biile*e</code>中的 <code>*</code>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 <code>*</code> 符号，则需要对 <code>*</code> 进行转义，即在其前加一个 <code>\</code>，<code>biile\*e</code> 匹配字符串 biile*e。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<code>\</code> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th>特别字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>匹配输入字符串的结尾位置。如果设置了 <code>RegExp</code> 对象的 <code>Multiline</code> 属性，则 <code>$</code> 也匹配 <code>&#39;\n&#39;</code> 或 <code>&#39;\r&#39;</code>。要匹配<code>$</code> 字符本身，请使用 <code>\$</code>。</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用<code>\(</code>和<code> \)</code>。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。要匹配 <code>*</code> 字符，请使用 <code>\*</code>。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。要匹配 <code>+</code> 字符，请使用<code> \+</code>。</td></tr><tr><td>·</td><td>匹配除换行符 \n 之外的任何单字符。要匹配 <code>.</code> ，请使用 <code>\.</code> 。</td></tr><tr><td>[</td><td>标记一个中括号表达式的开始。要匹配 <code>[</code>，请使用 <code>\[</code>。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 <code>?</code> 字符，请使用 <code>\?</code>。</td></tr><tr><td>\</td><td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code>  匹配字符 <code>n</code> 。 <code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>\</code> ，而 <code>\( </code>则匹配 <code>(</code>。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 <code>^</code> 字符本身，请使用 <code>\^</code>。</td></tr><tr><td>{</td><td>标记限定符表达式的开始。要匹配 <code>&#123;</code>，请使用<code> \&#123;</code>。</td></tr><tr><td>|</td><td>指明两项之间的一个选择。要匹配 `</td></tr></tbody></table><hr><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多次才能满足。由 <code>*</code> 或 <code>+</code> 或 <code>?</code> 或 <code>&#123;n&#125;</code> 或 <code>&#123;n,&#125;</code> 或<code>&#123;n,m&#125;</code> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>？</td><td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>以下正则表达式匹配一个正整数，<code>[1-9]</code> 设置第一个数字不是0，<code>[0-9]*</code> 表示任意多个数字。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/[1-9][0-9]*/</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/08/5IgqxZHwcfKOnFD.png" alt="1-9.png"></p><p>请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。</p><p>这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ？字符，因为使用？会将整数限制到只有两位数。</p><p>如果你想设置0 ~ 99 的两位数，可以使用下面的表达式来至少指定以为但至多两位数字。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;/</span><br></pre></td></tr></table></figure><p>上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。</p><p>改进下，匹配 1~ 99 的正整数表达式如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]?/</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;/</span><br></pre></td></tr></table></figure><p><strong><code>*</code> 和 <code>+</code> 限定符都是贪婪的，因为它们尽可能多的匹配文字，只有在它们的后面加一个 ？ 就可以实现非贪婪或最小匹配。</strong></p><p>例如，您可能搜索 HTML 文档，以查找在 <code>h1</code> 标签内的内容。HTML 如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;正则表达式&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p><strong>贪婪</strong>：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="xml">&lt;.*&gt;/</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/08/Udl5vchT4Y7H1Rb.png" alt="贪婪.png"></p><p><strong>非贪婪</strong>：如果你只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 &lt;h1&gt;。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="xml">&lt;.*?&gt;/</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/08/XgHnQDoVkyUzaME.png" alt="非贪婪.png"></p><p>也可以使用以下正则表达式来匹配 h1 标签，表达式则是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/<span class="xml">&lt;\w+?&gt;/</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/08/LyP62VYmt7GvNgu.png" alt="匹配 h1.png"></p><hr><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符使你能够将正则表达式固定到行首或行尾。它们还使你能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<code>^</code> 和 <code>$</code> 分别指字符串的开始与结束，<code>\b</code> 描述单词的前或后边界，<code>\B</code> 表示非单词的边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td>$</td><td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td>\b</td><td>匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td>\B</td><td>非单词边界匹配。</td></tr></tbody></table><p><strong>注意</strong>：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <code>^*</code> 之类的表达式。</p><p>若要匹配一行文本开始处的文本，请在正则表达式的开始使用 <code>^</code> 字符。不要将 <code>^</code> 的这种用法与中括号表达式内的用法混淆。</p><p>若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 <code>$</code> 字符。</p><p>若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^Chapter [<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;/</span><br></pre></td></tr></table></figure><p>真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它既有出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可以做到这一点。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^Chapter [<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;$/</span><br></pre></td></tr></table></figure><p><code>\b</code> 字符的位置非常重要。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ter\b/</span><br></pre></td></tr></table></figure><p>下面的表达式匹配 Chapter 中的字符串 apt ，但不匹配 aptitude 中的字符串 apt：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/\Bapt/</span><br></pre></td></tr></table></figure><p>字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 <code>\B</code> 非单词边界运算符，位置不重要，因为匹配不关心究竟是单词的开头还是结尾。</p><hr><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>用圆括号<code>()</code> 将所有选择项括起来，相邻的选择项之间用<code>|</code> 分隔。</p><p><code>()</code> 表示捕获分组，<code>()</code> 会把每个分组里的匹配的值保存起来，多个匹配值可以通过数字 n 来查看（n是一个数字，表示第 n 个捕获的内容）。</p><p>但圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 <code>?:</code> 放在第一个选项来消除这种副作用。</p><p>其中 <code>?:</code> 是非捕获元之一，还有两个非捕获元是 <code>?=</code> 和 <code>?!</code> ,这两个还有更多含义，前者正向预查，在任何还是匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式的位置来匹配搜索字符串。</p><p><strong>以下列出 ?=、?&lt;=、?!、?&lt;! 的使用区别</strong></p><p><code>exp1(?=exp2)</code>：查找 exp2 前面的exp1.</p><p><img src="https://i.loli.net/2021/09/08/FfgNYISRhTcod7z.png" alt="前字符串.png"></p><p><code>(?&lt;=exp2)exp1</code>：查找 exp2 后面的 exp1。</p><p><img src="https://i.loli.net/2021/09/08/U9P1m37TOiIj6aA.png" alt="匹配后面的字符串.png"></p><p><code>exp1(?!exp2)</code>：查找后面不是 exp2 的 exp1。</p><p><img src="https://i.loli.net/2021/09/08/neLYNJ1FAdHXoMy.png" alt="匹配字符串后非数字.png"></p><p><code>(?&lt;!exp2)exp1</code>：查找前面不是 exp2 的 exp1。</p><p><img src="https://i.loli.net/2021/09/08/CJIRtbHOLuwon3a.png" alt="匹配前面不是数字的biile.png"></p><h2 id="第3章-修饰符-标记"><a href="#第3章-修饰符-标记" class="headerlink" title="第3章 修饰符(标记)"></a>第3章 修饰符(标记)</h2><p>标记也称修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/pattern/flags</span><br></pre></td></tr></table></figure><p>下表列出了正则表达式常用的修饰符：</p><table><thead><tr><th>修饰符</th><th>含义</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>ignore - 不区分大小写</td><td>将匹配设置为不区分大小写，搜索时不区分大小写：A 和 a 没有区别。</td></tr><tr><td>g</td><td>global - 全局匹配</td><td>查找所有的匹配项。</td></tr><tr><td>m</td><td>multi line - 多行匹配</td><td>使边界字符 <code>^</code> 和 <code>$</code> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td>s</td><td>特殊字符圆点 <code> .</code> 中包含换行符 <code>\n</code></td><td>默认情况下的圆点 <code>.</code> 是匹配除换行符 <code>\n</code>  之外的任何字符，加上 <code>s</code> 修饰符之后， <code>.</code> 中包含换行符 <code>\n</code>。</td></tr></tbody></table><h3 id="g-修饰符"><a href="#g-修饰符" class="headerlink" title="g 修饰符"></a>g 修饰符</h3><p>g 修饰符可以查找字符串所有的匹配项：</p><p><img src="https://i.loli.net/2021/09/08/QyLBZvauk1YhXjz.png" alt="全局匹配.png"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;google biile Bing biile&quot;</span><span class="keyword">var</span> str1=str.match(<span class="regexp">/biile/</span>);<span class="comment">//查找第一次匹配项var str2=str.match(/biile/g);//查找所有匹配项</span></span><br></pre></td></tr></table></figure><hr><h3 id="i-修饰符"><a href="#i-修饰符" class="headerlink" title="i 修饰符"></a>i 修饰符</h3><p>i 修饰符为不区分大小写匹配，实例如下：</p><p><img src="https://i.loli.net/2021/09/08/4S96tBxKAP3QYNr.png" alt="不分大小写.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;google biile Bing Biile&quot;</span><span class="keyword">var</span> str1=str.match(<span class="regexp">/biile/g</span>);<span class="comment">//区分大小写var str2=str.match(/biile/gi);//不区分大小写</span></span><br></pre></td></tr></table></figure><hr><h3 id="m-修饰符"><a href="#m-修饰符" class="headerlink" title="m 修饰符"></a>m 修饰符</h3><p>m 修饰符可以使 <code>^</code> 和 <code>$</code> 匹配一段文本中每行的开始和结束位置。</p><p>g 只匹配第一行，添加 m 之后实现多行。</p><p><img src="https://i.loli.net/2021/09/08/4FBzMuLUetpSxrH.png" alt="多行匹配.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;googlebiileBingBiile\nbiileBingBiile&quot;</span><span class="keyword">var</span> str1=str.match(<span class="regexp">/^biile/g</span>);<span class="comment">//匹配一个var str2=str.match(/^biile/gm);//多行匹配</span></span><br></pre></td></tr></table></figure><hr><h3 id="s-修饰符"><a href="#s-修饰符" class="headerlink" title="s - 修饰符"></a>s - 修饰符</h3><p>默认情况下的圆点 <code>.</code> 是匹配除换行符 <code>\n</code>之外的任何字符，加上 s 之后，<code>.</code> 中包含换行符 <code>\n</code>。</p><p><img src="https://i.loli.net/2021/09/08/PdYs1j9L5iwaxGv.png" alt="匹配包含换行符.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;google\nbiile\n&quot;</span><span class="keyword">var</span> str1=str.match(<span class="regexp">/biile./</span>);<span class="comment">//没有使用 s，无法匹配\nvar str2=str.match(/biile./s);//使用 s，匹配\n</span></span><br></pre></td></tr></table></figure><h2 id="第4章-元字符"><a href="#第4章-元字符" class="headerlink" title="第4章 元字符"></a>第4章 元字符</h2><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td>{n,}</td><td>n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td>{n,m}</td><td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td></td><td>匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td></tr><tr><td>(pattern)</td><td>匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?&lt;=pattern)</td><td>反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95</td></tr><tr><td>x|y</td><td>匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\cx</td><td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于 <code>[^0-9]</code>。</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td>\s</td><td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td>\W</td><td>匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td>\xn</td><td>匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td>\num</td><td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td>\n</td><td>标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td>\nm</td><td>标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td>\nml</td><td>如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td>\um</td><td>匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h4><p>分析一个匹配邮箱的正则表达式，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str <span class="string">&quot;abcd test@biile.xyz 1234&quot;</span><span class="keyword">var</span> pat=<span class="regexp">/\b[\w.%+-]+@[\w.-]+.[a-zA-Z]&#123;2,6&#125;\b/g</span>;<span class="keyword">var</span> email=str.match(pat);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/08/lZEeW5wJGOQhvLB.png" alt="匹配到域名.png"></p><p><img src="https://i.loli.net/2021/09/08/dz6Zae74CBjxMKF.png" alt="匹配邮箱.png"></p><h2 id="第5章-运算符优先级"><a href="#第5章-运算符优先级" class="headerlink" title="第5章 运算符优先级"></a>第5章 运算符优先级</h2><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行计算，不同优先级的运算先高后低。</p><p>下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义符</td></tr><tr><td>()，(?:)，(?=)，[]</td><td>圆括号和方括号</td></tr><tr><td>*，+，?，{n}，{n,}，{n,m}</td><td>限定符</td></tr><tr><td>^，$，\任何元字符、任何字符</td><td>定位点和序列（即：位置和顺序）</td></tr><tr><td>|</td><td>替换，”或“操作<br />字符具有高于替换运算符的优先级，使得”m|food“匹配”m”或“food”。若要匹配“mood”或“food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table><h2 id="第6章-匹配规则"><a href="#第6章-匹配规则" class="headerlink" title="第6章 匹配规则"></a>第6章 匹配规则</h2><h3 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h3><p>一切从最基本开始。模式，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">^once</span><br></pre></td></tr></table></figure><p>这个模式包含一个特殊字符 <code>^</code> ，表示该模式只匹配那些以 once开头的字符串。例如该模式与字符串 <strong>”once upon a time “</strong> 匹配，与 <strong>”There once was a man from NewYork“</strong> 不匹配。正如如 <code>^</code> 符号表示开头一样，<code>$</code> 符号来匹配那些以给定模式结尾的字符串。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bucket$</span><br></pre></td></tr></table></figure><p>这个模式与 <strong>”Who kept all of this cash in a bucket“</strong> 匹配，与 <strong>“bucket”</strong> 不匹配。字符<code>^</code>  和 <code>$</code> 同时使用时，表示精确匹配（字符串与模式一样）。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">^bucket$</span><br></pre></td></tr></table></figure><p>只匹配字符串 **“bucket”**。如果一个模式不包括<code>^</code>  和 <code>$</code> ，那么它与任何包含该模式的字符串匹配。例如模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">once</span><br></pre></td></tr></table></figure><p>与字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There once was a man from NewYorkWho kept all of his cash in a bucket.</span><br></pre></td></tr></table></figure><p>是匹配的。</p><p>在该模式中的字母<strong>（o-n-c-e）</strong>是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠 <code>\</code> 大头。制表符的转义序列是 <code>\t</code> 。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">^\t</span><br></pre></td></tr></table></figure><p>类似的，用<code>\n</code> 表示 <strong>“新行”</strong> ，<code>\r</code> 表示回车。其他的特殊符号，也可以用在前面加上反斜杠，如反斜杠本身用<code>\\</code>表示，句号 <code>.</code> 用 <code>\.</code> 表示，以此类推。</p><hr><h3 id="字符簇"><a href="#字符簇" class="headerlink" title="字符簇"></a>字符簇</h3><p>在 INTERNET 的程序中，正则表达式通常用来验证用户的输入。当用户提交一个 FORM 以后，要判断输入的电话号码、地址、 EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。</p><p>所以要用一种更自由的描述我们要的模式的办法，他就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[AaEeIiOoUu]</span><br></pre></td></tr></table></figure><p>这个模式与任何元音字符匹配，但只能表示一个字符。用连字符可以表示一个字符的范围，如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[a-z]<span class="comment">//匹配所有的小写字母[A-Z]//匹配所有的大写字母[a-zA-z]//匹配所有字母[0-9]//匹配所有数字[0-9\.\-]//匹配所有数字，句号，减号[\f\r\t\n]//匹配所有的白字符</span></span><br></pre></td></tr></table></figure><p>同样的，这些只表示一个字符，这是一个非常重要的。如果要撇皮一个由小写字母和一位数字组成的字符串，比如 “z2”、”t6”、或 “g7”，但不是 “ab2”、”r2d3” 或 “b52” 用这个模式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">^[a-z][<span class="number">0</span>-<span class="number">9</span>]$</span><br></pre></td></tr></table></figure><p>这个模式与 “&amp;5”、”g7” 及 “-2” 是匹配的，但与 “12” 、”66” 是不匹配的。下面是几个排除特定字符的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[^a-z]<span class="comment">//除了小写字母以外的所有字符[^\\\/\^]//除了(\)(/)(^)之外的所有字符[^\&quot;\&#x27;]//除了双引号(&quot;)和单引号(&#x27;)之外的所有字符</span></span><br></pre></td></tr></table></figure><p>特殊字符 <code>.</code> （点，句号）在正则表达式中用来表示除了”新行“之外的所有字符。所有模式 <code>^.5$</code> 与任何两个字符的、以数字 5 结尾和其他非 ”新行“ 字符开头的字符串匹配。模式 <code>.</code> 可以匹配任何字符串，<strong>换行符（\n、\r）除外</strong>。</p><p>PHP的正则表达式有一些内置的通用字符簇，列表如下：</p><table><thead><tr><th>字符簇</th><th>描述</th></tr></thead><tbody><tr><td>[[:alpha:]]</td><td>任何字母</td></tr><tr><td>[[:digit:]]</td><td>任何数字</td></tr><tr><td>[[:alnum:]]</td><td>任何字母和数字</td></tr><tr><td>[[:space:]]</td><td>任何空白字符</td></tr><tr><td>[[:upper:]]</td><td>任何大写字母</td></tr><tr><td>[[:lower:]]</td><td>任何小写字母</td></tr><tr><td>[[:punct:]]</td><td>任何标点符号</td></tr><tr><td>[[:xdigit:]]</td><td>任何16进制的数字，相当于[0-9a-fA-F]</td></tr></tbody></table><hr><h3 id="确定重复出现"><a href="#确定重复出现" class="headerlink" title="确定重复出现"></a>确定重复出现</h3><p>到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能匹配一个单词或一组数字。一个单词有若干字母组成，一组数字有若干个单个数字组成。跟在字符或字符簇后面的花括号（{}）用来确定前面的内容的重复出现的次数。</p><table><thead><tr><th>字符簇</th><th>描述</th></tr></thead><tbody><tr><td>^[a-zA-Z_]$</td><td>所有的字母和下划线</td></tr><tr><td>^[[:alpha:]]{3}$</td><td>所有的3个字母的单词</td></tr><tr><td>^a$</td><td>字母a</td></tr><tr><td>^a{4}$</td><td>aaaa</td></tr><tr><td>^a{2,4}$</td><td>aa，aaa 或 aaaa</td></tr><tr><td>^a{1,3}$</td><td>a，aa 或 aaa</td></tr><tr><td>^a{2,}$</td><td>包含多余两个a的字符串</td></tr><tr><td>^a{2,}</td><td>如：aarvark 和 aaab，但apple不行</td></tr><tr><td>a{2,}</td><td>如：baad 和aaa，但 Nantucket 不行</td></tr><tr><td>\t{2}</td><td>两个制表符</td></tr><tr><td>{2}</td><td>所有的两个字符</td></tr></tbody></table><p>这些例子描述了花括的三种不同的用法。一个数字 <code>&#123;x&#125;</code> 的意思是<strong>前面的字符或字符簇只出现x次</strong>；一个数字加逗号 <code>&#123;x,&#125;</code> 的意思是<strong>前面的内容出现x或更多的次数</strong>；两个数字用逗号分隔的数字 <code>&#123;x,y&#125;</code> 表示<strong>前面的内容至少出现x次，但不超过y次</strong>。我们可以把模式扩展到更多的单词或数字：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z0-9_]&#123;<span class="number">1</span>,&#125;$      <span class="comment">// 所有包含一个以上的字母、数字或下划线的字符串 ^[1-9][0-9]&#123;0,&#125;$        // 所有的正整数 ^\-&#123;0,1&#125;[0-9]&#123;1,&#125;$      // 所有的整数 ^[-]?[0-9]+\.?[0-9]+$   // 所有的浮点数</span></span><br></pre></td></tr></table></figure><p>最后一个例子不太好理解，是吗？这么看吧：以一个可选的负号 (<code>[-]?</code>) 开头 (<code>^</code>)、跟着1个或更多的数字(<code>[0-9]+</code>)、和一个小数点(<strong>.</strong>)再跟上1个或多个数字(<code>[0-9]+</code>)，并且后面没有其他任何东西(<code>$</code>)。下面你将知道能够使用的更为简单的方法。</p><p>特殊字符 <code>?</code> 与 <code>&#123;0,1&#125;</code> 是相等的，它们都代表着： <strong>0个或1个前面的内容</strong> 或 <strong>前面的内容是可选的</strong> 。所以刚才的例子可以简化为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">^\-?[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,&#125;\.?[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,&#125;$</span><br></pre></td></tr></table></figure><p>特殊字符 <code>*</code> 与 <code>&#123;0,&#125;</code> 是相等的，它们都代表着 <strong>0 个或多个前面的内容</strong> 。最后，字符 <code>+</code> 与 <code>&#123;1,&#125;</code> 是相等的，表示 <strong>1 个或多个前面的内容</strong> ，所以上面的4个例子可以写成：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">^[a-zA-Z0-9_]+$      <span class="comment">// 所有包含一个以上的字母、数字或下划线的字符串 ^[1-9][0-9]*$        // 所有的正整数 ^\-?[0-9]+$          // 所有的整数 ^[-]?[0-9]+(\.[0-9]+)?$ // 所有的浮点数</span></span><br></pre></td></tr></table></figure><p>当然这并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。</p><h2 id="第7章-示例"><a href="#第7章-示例" class="headerlink" title="第7章 示例"></a>第7章 示例</h2><h3 id="简单表达式"><a href="#简单表达式" class="headerlink" title="简单表达式"></a>简单表达式</h3><p>正则表达式的最简单形式是在搜索字符串中匹配其本身的单个普通字符。例如，单字符模式，如A，不论出现在搜索字符串中的何处，它总是匹配字母 A。下面是一些单字符正则表达式模式的实例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/a<span class="comment">//7//M/</span></span><br></pre></td></tr></table></figure><p>可以将许多单字符组合起来i形成大的表达式。例如，以下正则表达式组合了但子表达式：a、7、M。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/a7M/</span><br></pre></td></tr></table></figure><p>请注意，没有串联运算符。只须在一个字符后面键入另一个字符。</p><hr><h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><p>句点( . )匹配字符串中的各种打印或非打印字符，只有一个字符例外。这个例外就是换行符(\n)。下面的正则表达式匹配aac、abc、acc、adc等，以及a1c、a2c、a-c 和 a#c：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/a.c/</span><br></pre></td></tr></table></figure><p>若要匹配包含文件名的字符串，而句点( . ) 是输入字符串的组成部分，请在正则表达式中的句点前面加反斜杠(<code>\</code>)字符。举例说明，下面的正则表达式匹配 filename.ext：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/filename\.ext/</span><br></pre></td></tr></table></figure><p>这些表达式只让你匹配”任何“单个字符。可能只需要匹配列表中的特定字符组。例如，可能需要查找用数字表示章节标题（Chapter1、Chapter2等等）。</p><hr><h3 id="中括号表达式"><a href="#中括号表达式" class="headerlink" title="中括号表达式"></a>中括号表达式</h3><p>若要创建匹配字符组的一个列表，请在方括号（[和]）内放置一个或更多单个字符。当字符在中括号内时，该列表称为”中括号表达式“。与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。大多数特殊字符在中括号表达式内出现时失去他们的意义。不过也有一些例外，如：</p><ul><li>如果 ] 字符不是第一项，它结束一个列表。若要匹配列表中的 ] 字符，请将它放在第一位，紧跟在开始 [ 后面。</li><li>\ 字符继续作为转义符。若要匹配\ 字符，请使用 \\。</li></ul><p>括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符。以下正则表达式匹配 Chapter1、Chapter2、Chapter3、和 Chapter4和Chapter5：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/Chapter [<span class="number">12345</span>]/</span><br></pre></td></tr></table></figure><p>请注意，单词 Chaoter和后面的空格的位置相对于中括号内的字符时固定的。中括号表达式指定的只是匹配紧跟在单词 Chapter 和空格的单个字符位置的字符集。这是第九个字符位置。</p><p>若要使用范围代替字符本身来表示匹配字符集，请使用连字符（-）将范围中的开始字符和结束字符分开。单个字符的字符值确定范围内的相对顺序。下面的正则表达式包含范围表达式，该范围表达式等效于上面显示的中括号中的列表：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Chapter [<span class="number">1</span>-<span class="number">5</span>]/</span><br></pre></td></tr></table></figure><p>当以这种方式指定范围时，开始值和结束值两者都包括在范围内。注意，还有一点很重要，按 Unicode 排序顺序，开始值必须在结束值的前面。若要在中括号表达式中包括连字符，请采用下列方式之一：</p><ul><li><p>用反斜杠将它转义：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[\-]</span><br></pre></td></tr></table></figure></li><li><p>将连字符放在中括号列表的开始和结尾。下面的表达式匹配所有小写字母和连字符：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[-a-z][a-z-]</span><br></pre></td></tr></table></figure></li><li><p>创建一个范围，在该范围中，开始字符值小于连字符，而结束符值等于或大于连字符。下面的两个正则表达式都满足这一要求：</p></li><li><p>```js<br>[!–][!-~]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">若要查找不在列表或范围的所有字符，请将插入符号（^）放在列表的开头。如果插入字符出现在列表中的其他任何位置，则它匹配其本身。下面的正则表达式匹配1、2、3、4 或 5 之外的任何数字和字符：</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">/Chapter [^12345]/</span><br></pre></td></tr></table></figure><p>在上面的示例中，表达式在第九个位置匹配1、2、3、4或 5 之外的任何数字和字符。这样，例如，Chapter7 就是一个匹配项，Chapter 9 也是一个匹配项。</p><p>上面的表达式可以使连字符（-）来表示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/Chapter [^<span class="number">1</span>-<span class="number">5</span>]/</span><br></pre></td></tr></table></figure><p>中括号表达式的典型用途是指定任何大写或小写字母或任何数字的匹配。下面的表达式指定这样的匹配：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[A-Za-z0-<span class="number">9</span>]/</span><br></pre></td></tr></table></figure><hr><h3 id="替换和分组"><a href="#替换和分组" class="headerlink" title="替换和分组"></a>替换和分组</h3><p>替换使用 | 字符来允许在两个或多个替换选项之间进行选择。例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。但是，这并不象您可能认为的那样简单。替换匹配 | 字符任一侧最大的表达式。</p><p>您可能认为，下面的表达式匹配出现在行首和行尾、后面跟一个或两个数字的 Chapter 或 Section：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^Chapter|Section [<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;$/</span><br></pre></td></tr></table></figure><p>很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter。如果输入字符串是 Section 22，那么该表达式匹配 Section 22。</p><p>若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。</p><p>下面的正则表达式使用括号来组合 Chapter 和 Section，以便表达式正确地起作用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^(Chapter|Section) [<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;$/</span><br></pre></td></tr></table></figure><p>尽管这些表达式正常工作，但 Chapter|Section 周围的括号还将捕获两个匹配字中的任一个供以后使用。由于在上面的表达式中只有一组括号，因此，只有一个被捕获的”子匹配项”。</p><p>在上面的示例中，您只需要使用括号来组合单词 Chapter 和 Section 之间的选择。若要防止匹配被保存以备将来使用，请在括号内正则表达式模式之前放置 ?:。下面的修改提供相同的能力而不保存子匹配项：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^(?:Chapter|Section) [<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;$/</span><br></pre></td></tr></table></figure><p>除 ?: 元字符外，两个其他非捕获元字符创建被称为”预测先行”匹配的某些内容。正向预测先行使用 ?= 指定，它匹配处于括号中匹配正则表达式模式的起始点的搜索字符串。反向预测先行使用 ?! 指定，它匹配处于与正则表达式模式不匹配的字符串的起始点的搜索字符串。</p><p>例如，假设您有一个文档，该文档包含指向 Windows 3.1、Windows 95、Windows 98 和 Windows NT 的引用。再进一步假设，您需要更新该文档，将指向 Windows 95、Windows 98 和 Windows NT 的所有引用更改为 Windows 2000。下面的正则表达式（这是一个正向预测先行的示例）匹配 Windows 95、Windows 98 和 Windows NT：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/Windows(?=<span class="number">95</span> |<span class="number">98</span> |NT )/</span><br></pre></td></tr></table></figure><p>找到一处匹配后，紧接着就在匹配的文本（不包括预测先行中的字符）之后搜索下一处匹配。例如，如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。</p><hr><h3 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h3><table><thead><tr><th>正则表达式</th><th>描述</th></tr></thead><tbody><tr><td>/\b([a-z]+) \1\b/gi</td><td>一个单词连续出现的位置。</td></tr><tr><td>/(\w+)://([^/:]+)(:\d*)?([^# ]*)/</td><td>将一个URL解析为协议、域、端口及相对路径。</td></tr><tr><td>/^(?:Chapter|Section) [1-9][0-9]{0,1}$/</td><td>定位章节的位置。</td></tr><tr><td>/[-a-z]/</td><td>a至z共26个字母再加一个-号。</td></tr><tr><td>/ter\b/</td><td>可匹配chapter，而不能匹配terminal。</td></tr><tr><td>/\Bapt/</td><td>可匹配chapter，而不能匹配aptitude。</td></tr><tr><td>/Windows(?=95 |98 |NT )/</td><td>可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。</td></tr><tr><td>/^\s*$/</td><td>匹配空行</td></tr><tr><td>/\d{2}-\d{5}/</td><td>验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。</td></tr><tr><td>/&lt;\s*(\S+)(\s[^&gt;]<em>)?&gt;[\s\S]</em>&lt;\s*/\1\s*&gt;/</td><td>匹配 HTML 标记。</td></tr></tbody></table></li></ul><h2 id="第8章-在线工具"><a href="#第8章-在线工具" class="headerlink" title="第8章 在线工具"></a>第8章 在线工具</h2><p>​    <a href="https://regexr.com/">RegExr</a> – 正则表达式在线测试工具</p><blockquote><p><strong>一、校验数字的表达式</strong><br> 数字：^[0-9]<em>$<br> n位的数字：^\d{n}$<br> 至少n位的数字：^\d{n,}$<br> m-n位的数字：^\d{m,n}$<br> 零和非零开头的数字：^(0|[1-9][0-9]</em>)$<br> 非零开头的最多带两位小数的数字：^([1-9][0-9]<em>)+(.[0-9]{1,2})?$<br> 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})$<br> 正数、负数、和小数：^(-|+)?\d+(.\d+)?$<br> 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$<br> 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$<br> 非零的正整数：^[1-9]\d</em>$ 或 ^([1-9][0-9]<em>){1,3}$ 或 ^+?[1-9][0-9]</em>$<br> 非零的负整数：^-[1-9][]0-9”<em>$ 或 ^-[1-9]\d</em>$<br> 非负整数：^\d+$ 或 ^[1-9]\d*|0$<br> 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$<br> 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d<em>.\d</em>|0.\d*[1-9]\d*|0?.0+|0$<br> 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*))|0?.0+|0$<br> 正浮点数：^[1-9]\d<em>.\d</em>|0.\d*[1-9]\d*$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]<em>.[0-9]+)|([0-9]</em>[1-9][0-9]</em>))$<br> 负浮点数：^-([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]<em>.[0-9]+)|([0-9]</em>[1-9][0-9]</em>)))$<br> 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*|0?.0+|0)$<br><strong>二、校验字符的表达式</strong><br> 汉字：^[\u4e00-\u9fa5]{0,}$<br> 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$<br> 长度为3-20的所有字符：^.{3,20}$<br> 由26个英文字母组成的字符串：^[A-Za-z]+$<br> 由26个大写英文字母组成的字符串：^[A-Z]+$<br> 由26个小写英文字母组成的字符串：^[a-z]+$<br> 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$<br> 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$<br> 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$<br> 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$<br> 可以输入含有^%&amp;’,;=?$&quot;等字符：[^%&amp;’,;=?$\x22]+<br> 禁止输入含有<del>的字符：[^</del>\x22]+<br><strong>三、特殊需求表达式</strong><br> Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)<em>.\w+([-.]\w+)</em>$<br> 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.?<br> InternetURL：[a-zA-z]+://[^\s]</em> 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]<em>)?$<br> 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$<br> 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$<br> 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}<br> 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: ((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)<br> 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)<br> 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$<br> 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$<br> 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.<em>\d)(?=.</em>[a-z])(?=.</em>[A-Z])[a-zA-Z0-9]{8,10}$<br> 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：^(?=.<em>\d)(?=.</em>[a-z])(?=.<em>[A-Z]).{8,10}$<br> 日期格式：^\d{4}-\d{1,2}-\d{1,2}<br> 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$<br> 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$<br> 钱的输入格式：<br> 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]</em>$<br> 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]<em>)$<br> 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]</em>)$<br>     这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$<br> 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$<br> 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$<br> 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})<em>(.[0-9]{1,2})?$<br> 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})</em>)(.[0-9]{1,2})?$<br> 备注：这就是最终结果了,别忘了”+”可以用”<em>“替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里<br> xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$<br> 中文字符的正则表达式：[\u4e00-\u9fa5]<br> 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))<br> 空白行的正则表达式：\n\s</em>\r (可以用来删除空白行)<br> HTML标记的正则表达式：&lt;(\S*?)[^&gt;]<em>&gt;.</em>?|&lt;.<em>? /&gt; ( 首尾空白字符的正则表达式：^\s</em>|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)<br> 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)<br> 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)<br> IPv4地址：((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 服务端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery实现tab页切换</title>
      <link href="/2021/09/05/jQuery%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E5%88%87%E6%8D%A2/"/>
      <url>/2021/09/05/jQuery%E5%AE%9E%E7%8E%B0tab%E9%A1%B5%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><p>切换tab显示不同的内容</p><h2 id="效果展示图"><a href="#效果展示图" class="headerlink" title="效果展示图"></a>效果展示图</h2><p><strong>tab1</strong></p><p><img src="https://i.loli.net/2021/09/05/HVJdEQCBFgjN1M3.png" alt="tab1.png"></p><p><strong>tab2</strong></p><p><img src="https://i.loli.net/2021/09/05/K29IiTnqxRfjoYp.png" alt="tab2.png"></p><h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><h3 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account-container-wrap account-container&quot;</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 330px; height:336px; visibility: visible;&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account-card&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 卡片 title --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account-card-tab&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account-card-tab-item account-card-tab-item-Active&quot;</span> <span class="attr">id</span>=<span class="string">&quot;loginTab&quot;</span>&gt;</span>祝贺我们<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account-card-tab-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;registTab&quot;</span>&gt;</span>日与夜<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 卡片内容 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account-card-cnt&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account-card-login account-card-Active account-card-inActive&quot;</span> <span class="attr">id</span>=<span class="string">&quot;loginCard&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./imgs/Congratulations.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;祝贺&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;account-card-regist account-card-Active&quot;</span> <span class="attr">id</span>=<span class="string">&quot;registCard&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./imgs/couple-date-night.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;日与夜&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="css代码"><a href="#css代码" class="headerlink" title="css代码"></a>css代码</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.account-container-wrap</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">334px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">387px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-container</span>&#123;</span><br><span class="line">    <span class="comment">/*float: right;*/</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">200px</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">56</span>, <span class="number">248</span>, <span class="number">184</span>, <span class="number">0.438</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">334px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">387px</span>;</span><br><span class="line">    -<span class="attribute">height</span>: <span class="number">371px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">12</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">style attribute&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">330px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">336px</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-tab</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="built_in">rgba</span>(<span class="number">56</span>, <span class="number">248</span>, <span class="number">184</span>, <span class="number">0.438</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">245</span>, <span class="number">255</span>, <span class="number">248</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span> <span class="number">6px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-tab-item</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-tab-item-Active</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-cnt</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">336px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-login</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-regist</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-Active</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-Active</span> <span class="selector-tag">h2</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: inline;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.account-card-inActive</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jQuery代码"><a href="#jQuery代码" class="headerlink" title="jQuery代码"></a>jQuery代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     $(<span class="string">&quot;.account-card-tab-item&quot;</span>).on(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="comment">// alert(&quot;点击了&quot; + $(this).html());</span></span><br><span class="line">       <span class="comment">// 为当前触发标签添加 Active css， 并且为标签的兄弟删除Active css</span></span><br><span class="line">       $(<span class="built_in">this</span>).addClass(<span class="string">&#x27;account-card-tab-item-Active&#x27;</span>).siblings().removeClass(<span class="string">&#x27;account-card-tab-item-Active&#x27;</span>);</span><br><span class="line">       $(<span class="string">&quot;.account-card-Active&quot;</span>).eq($(<span class="built_in">this</span>).index()).addClass(<span class="string">&#x27;account-card-inActive&#x27;</span>).siblings().removeClass(<span class="string">&#x27;account-card-inActive&#x27;</span>);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tab页切换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机和主机之间复制、粘贴内容、拖拽文件的详细方法</title>
      <link href="/2021/06/29/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%A4%8D%E5%88%B6%E3%80%81%E7%B2%98%E8%B4%B4%E5%86%85%E5%AE%B9%E3%80%81%E6%8B%96%E6%8B%BD%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95-1/"/>
      <url>/2021/06/29/VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%B8%BB%E6%9C%BA%E4%B9%8B%E9%97%B4%E5%A4%8D%E5%88%B6%E3%80%81%E7%B2%98%E8%B4%B4%E5%86%85%E5%AE%B9%E3%80%81%E6%8B%96%E6%8B%BD%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E6%96%B9%E6%B3%95-1/</url>
      
        <content type="html"><![CDATA[<p>​        Vmware正确安装完linux虚拟机之后，这里以Ubuntu为例（其他linux或windows系统也是类似的），如果你使用的默认配置，正常情况下就可以复制、粘贴和拖拽内容的，双方向都是支持的。如果不能复制和拖拽一般是vmware tools没有正确安装导致。<br>     下面把可能的几种情况做一个总结，包括手工安装vmware tools的两种方法。</p><h1 id="VMware-tools-显示灰色"><a href="#VMware-tools-显示灰色" class="headerlink" title="VMware tools 显示灰色"></a>VMware tools 显示灰色</h1><ol><li>打开vmware，在主界面上点“虚拟机”，如下图所示“安装vmware tools”菜单是灰色的，这说明vmware tools工具没有成功安装。<br><img src="https://i.loli.net/2021/06/17/RukE7tOZU3qgKBH.png" alt="1.png"></li></ol><p>vmware tools工具成功安装之后界面如下图所示，会显示“重新安装”的字样。</p><h2 id="解决方法如下："><a href="#解决方法如下：" class="headerlink" title="解决方法如下："></a>解决方法如下：</h2><p>1.关闭虚拟机，点击菜单栏“虚拟机”，双击设备栏中的“CD/DVD(SATA)”</p><p><img src="https://i.loli.net/2021/06/17/CiXqUjNVWzDgker.png" alt="2.png"></p><ol start="2"><li><p>如果有软盘驱动则移除，用不到了，然后选中CD/DVD 光盘，右边 “连接” 选中”自动检测“，如下图所示：</p><p><img src="https://i.loli.net/2021/06/17/MEn2x5UktBj4oQa.png" alt="3.png"></p></li><li><p>打开虚拟机后，灰色字即点亮，可以正常安装。</p></li></ol><p><img src="https://i.loli.net/2021/06/17/7RSmVUXAJjevGp1.png" alt="4.png"></p><h2 id="VMware-tools安装"><a href="#VMware-tools安装" class="headerlink" title="VMware tools安装"></a>VMware tools安装</h2><ol><li>先把VMwareTools 文件复制到其他文件夹下</li></ol><p><img src="https://i.loli.net/2021/06/17/H7ApIPXLJONztqg.png" alt="5.png"></p><ol start="2"><li><p>压缩包格式为 <code>tar.gz</code> ，终端解压VMware Tools 文件 <code>tar -xzvf filename.tar,gz</code> </p></li><li><p>进入解压后的文件夹，<code>cd  Vmware-tools-distrib</code></p></li></ol><p><img src="https://i.loli.net/2021/06/17/26VmPaAMF3lzYGN.png" alt="6.png"></p><ol start="4"><li>执行 <code>./VMware-install.pl</code>，一路回车默认选项，如下图所示，即安装成功。</li></ol><p><img src="https://i.loli.net/2021/06/17/XUPnAZz1Y2VpBmW.png" alt="7.png"></p><p>安装成功后就可以实现主机与虚拟机之间的复制粘贴。</p><h1 id="文件拖拽"><a href="#文件拖拽" class="headerlink" title="文件拖拽"></a>文件拖拽</h1><ol><li><p>卸载系统原来的虚拟工具条</p><p><code>sudo apt-get autoremove open-vm-tools</code></p></li><li><p>安装桌面版的虚拟工具条，支持windows和linux之间文件的拖拽</p><p><code>sudo apt-get install open-vm-tools-desktop</code></p></li><li><p>重启，一定要重启才行。</p></li><li><p>重启之后就能实现文件的来回拖拽了，很方便，很实用。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> VMware </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android地图 - 开发注意事项</title>
      <link href="/2021/06/28/Android%20-%20%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%98%BE%E7%A4%BA/"/>
      <url>/2021/06/28/Android%20-%20%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建-AS-项目"><a href="#1-创建-AS-项目" class="headerlink" title="1. 创建 AS 项目"></a>1. 创建 AS 项目</h1><p>在Android Studio创建一个Android项目</p><h2 id="1-1-注册和获取秘钥"><a href="#1-1-注册和获取秘钥" class="headerlink" title="1.1 注册和获取秘钥"></a>1.1 注册和获取秘钥</h2><blockquote><p>什么是秘钥？</p></blockquote><p>开发者在使用SDK之前需要获取百度地图移动版开发秘钥（AK），该AK与你的百度账号相关联。<strong>妥善保管你的AK，地图初始化时需要AK。</strong></p><h3 id="获取开发秘钥（AK）"><a href="#获取开发秘钥（AK）" class="headerlink" title="获取开发秘钥（AK）"></a>获取开发秘钥（AK）</h3><p>百度地图SDK开发秘钥的申请地址👉<a href="https://lbsyun.baidu.com/apiconsole/key">在这里</a>👈</p><p>申请步骤大致可分为如下四个步骤：</p><p>1.若未登录百度账号，请先登录你的百度账号，如下图：</p><p><img src="https://i.loli.net/2021/06/24/Bvx2L1QkfVX9OzK.png" alt="login1.png"></p><p>（若没有百度账号，则按图根据提示注册登录）</p><p>2.登陆后进入API控制台，如下图：</p><p><img src="https://i.loli.net/2021/06/24/KRAFnQmyDiwlEIT.png" alt="login2.png"></p><p>3.点击“创建应用”开始申请开发秘钥，如下图：</p><p><img src="https://i.loli.net/2021/06/24/MshQavz8ipWLAj6.png" alt="login3.png"></p><p>4.填写应用名称，注意应用类型选择“Android SDK”、正确填写SHA1和程序包名（SHA1和包名的获取方法见下文）。如下图：</p><p><img src="https://i.loli.net/2021/06/24/hAsjnxoENYCIk6M.png" alt="login4.png"></p><p>填写清楚以上内容之后点击提交会为您生成该应用的AK，到这您就可以使用AK来完成您的开发工作了。 <strong>注意：同一个AK中，可以填写开发版SHA1和发布版SHA1，这样app开发、测试到发布整个过程中均不需要改动AK。</strong><br>此功能完全兼容以前的AK，默认将原有的SHA1放在发布版SHA1上，开发者也可自己更新，将原有的开发版本的AK和发布版本的AK对应的SHA1值合并后使用。 </p><h3 id="获取包名"><a href="#获取包名" class="headerlink" title="获取包名"></a>获取包名</h3><ul><li><p>使用Android Studio开发</p><p>在app目录下的build.gradle文件中applicationId，并确保其值与AndroidManifest.xml中定义的package相同。</p><p><img src="https://i.loli.net/2021/06/29/oX83YwULqG2HWyI.png" alt="图片.png"><br><img src="https://i.loli.net/2021/06/29/49F5sD3Hf287EqX.png" alt="图片.png"></p></li></ul><p><strong>注意：使用Android Studio开发，如遇到applicationId 与package不一致的情况，</strong>以applicationid为准。</p><p><a href="https://developer.android.com/studio/build/application-id.html">查看Android官方说明链接</a></p><h3 id="获取SHA1"><a href="#获取SHA1" class="headerlink" title="获取SHA1"></a>获取SHA1</h3><p>调试版本（debug）和发布版本（release）下的SHA1值是不同的，发布apk时需要根据apk对应的keystore重新配置key。<strong>（注意：我们这里使用的是调试版本，在开发时请使用调试版本）。</strong></p><ol><li>进入控制台（以Mac为例，Windows则进入cmd控制台，同样执行下述命令），执行 <code>cd .android</code> 定位到 <code>.android</code> 文件下。</li></ol><p><img src="https://i.loli.net/2021/06/29/JOzvWKY3buSdQlL.png" alt="图片.png"></p><ol start="2"><li><p>继续在控制台输入以下命令：</p><p>调试版本使用指令：<code>keytool -list -v -keystore debug.keystore</code></p><p>发布版本使用指令：<code>keytool -list -v -keystore apk</code> 的 keystore </p><p><img src="https://i.loli.net/2021/06/29/oD8h5RSaNGnswlt.png" alt="图片.png"></p></li><li><p>输入口令：</p><p>调试版本默认密码时 android，发布模式的密码是apk的keystore设置的密码。输入秘钥后回车（如果没设置密码，可直接回车），此时可在控制台显示的信息中获取SHA1值，如下图所示：</p><p><img src="https://i.loli.net/2021/06/29/AcT5fWohkLmGZBM.png" alt="图片.png"></p></li></ol><h1 id="2-在项目中集成BaiduMap-SDK"><a href="#2-在项目中集成BaiduMap-SDK" class="headerlink" title="2. 在项目中集成BaiduMap SDK"></a>2. 在项目中集成BaiduMap SDK</h1><p><strong>下载开发包</strong></p><p>普通的地图服务和包含骑行导航的地图服务需要下载不同的开发包，<a href="https://lbsyun.baidu.com/index.php?title=sdk/download&action#selected=mapsdk_basicmap,mapsdk_searchfunction,mapsdk_lbscloudsearch,mapsdk_calculationtool,mapsdk_radar">点击下载开发包</a></p><h2 id="2-1下载普通开发包"><a href="#2-1下载普通开发包" class="headerlink" title="2.1下载普通开发包"></a>2.1下载普通开发包</h2><p>第二行选择基础地图服务</p><p><img src="https://i.loli.net/2021/06/29/U4B9XQz65cGaAxb.png" alt="图片.png"></p><h2 id="2-2-下载步骑行导航的开发包"><a href="#2-2-下载步骑行导航的开发包" class="headerlink" title="2.2 下载步骑行导航的开发包"></a>2.2 下载步骑行导航的开发包</h2><p>第二行选择步骑行导航（含基础地图）</p><p><img src="https://i.loli.net/2021/06/29/we9r1QnTFdmvxsf.png" alt="图片.png"></p><p><strong>注：其他的功能（如定位服务、检索功能、全景图功能等则根据你的开发需要下载）</strong></p><h2 id="2-3-将开发包拷贝至工程"><a href="#2-3-将开发包拷贝至工程" class="headerlink" title="2.3 将开发包拷贝至工程"></a>2.3 将开发包拷贝至工程</h2><p><strong>（截图以普通地图服务的开发为例，步骑行导航的开发包同理）</strong></p><ol><li><h4 id="添加jar文件"><a href="#添加jar文件" class="headerlink" title="添加jar文件"></a>添加jar文件</h4><p>打开解压后的开发包文件夹，找到BaiduLBS_Android.jar 文件将其拷贝至工程的app/libs</p><p>目录下，如图：</p><p><img src="https://i.loli.net/2021/06/29/219NRPm4tCniEVS.png" alt="图片.png"></p></li><li><h4 id="添加so文件"><a href="#添加so文件" class="headerlink" title="添加so文件"></a>添加so文件</h4><p>有两种方法可以实现。</p><ul><li><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>在下载的开发包中拷贝需要的CPU架构对应的so文件夹到app/libs目录下，如图：</p><p><img src="https://i.loli.net/2021/06/29/QJVChaWpd1cTFvK.png" alt="图片.png"></p><p>在app目录下的build.gradle文件中的android块中配置sourceSets标签，如果没有使用该标签则新增，详细配置带么如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">           main &#123;</span><br><span class="line">               jniLibs.srcDir &#x27;libs&#x27;</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注：jar文件和so文件的版本号必须一致，并且保证jar文件与so文件时同一版本包取出的。</p></li><li><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>在src/main目录下新建jniLibs目录（如果项目中已经包含则该目录不需要重复创建），在下载的开发包中拷贝项目中需要的CPU架构对应的so文件文件夹到jniLibs目录，如图：<br><img src="https://i.loli.net/2021/06/29/FIS9gz8awPVcriD.png" alt="图片.png"></p></li></ul></li><li><h4 id="往工程添加jar文件"><a href="#往工程添加jar文件" class="headerlink" title="往工程添加jar文件"></a>往工程添加jar文件</h4><p>在工程配置中需要将前面添加的jar文件集成到我们的工程中。</p><ul><li><h5 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h5><p>在libs目录下，选中每一个jar文件（此处只有一个BaiduLbs_Android.jar）右键，选择Add AsLibrary……</p><p>此时会发现在app目录的build.gradle的dependencies块中生成了工程所依赖的jar文件的对应说明，如下：</p><p><img src="https://i.loli.net/2021/06/29/VXv8onHmZ7PDlOq.png" alt="图片.png"></p><p>注意:最新版本的Android Studio中compile被替换为implementation，具体的写法与您的Android Studio版本有关。</p></li><li><h5 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h5><ol><li><p>菜单栏选择File -&gt; Project Structure</p></li><li><p>在弹出的Project Structure对话框中选中左侧的Modules列表下的app目录，然后点击右侧页面中的Dependencies选项卡。如图：</p><p><img src="https://i.loli.net/2021/06/29/Nq8uai6CQZhYrFM.png" alt="图片.png"></p></li><li><p>点击左上角“＋”号选择<code>JAR/AAR dependency</code> ,然后选择要添加的jar文件即可（此处拷贝至libs目录下的BaiduLBS_Android.jar）结果如图：</p><p><img src="https://i.loli.net/2021/06/29/SwyWkbsc8frYiU6.png" alt="图片.png"></p><p>完成上述操作之后在app目录的build.gradle的dependencies块中生成了工程所依赖的jar文件的对应说明，见方法一。</p></li></ol></li></ul></li></ol><h1 id="3-Hello-BaiduMap"><a href="#3-Hello-BaiduMap" class="headerlink" title="3. Hello BaiduMap"></a>3. Hello BaiduMap</h1><p>百度地图SDK为开发者提供了便捷的使用百度地图能力的接口，通过以下几步操作，即可在您的应用中使用百度地图：</p><ol><li><p>配置 <code>AndroidManifest.xml</code> 文件</p><ol><li><p>在<application>中加入如下代码配置开发秘钥（AK）：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;application&gt;  </span><br><span class="line">    &lt;meta-data  </span><br><span class="line">        android:name=&quot;com.baidu.lbsapi.API_KEY&quot;  </span><br><span class="line">        android:value=&quot;开发者 key&quot; /&gt;  </span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure><p>若还没有申请。👉<a href="https://yyaxu.xyz/2021/06/24/Android%E5%9C%B0%E5%9B%BE%20-%20%E6%B3%A8%E5%86%8C%E5%92%8C%E8%8E%B7%E5%8F%96%E7%A7%98%E9%92%A5/">走这里</a>👈</p></li><li><p>在<application>外部添加如下权限：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 访问网络，进行地图相关业务数据请求，包括地图数据，路线规划，POI检索等 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">&lt;!-- 获取网络状态，根据网络状态切换进行数据请求网络转换 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!-- 读取外置存储。如果开发者使用了so动态加载功能并且把so文件放在了外置存储区域，则需要申请该权限，否则不需要 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">&lt;!-- 写外置存储。如果开发者使用了离线地图，并且数据写在外置存储区域，则需要申请该权限 --&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注：自Android6.0起部分权限的使用需要开发者在代码中动态申请。</p></blockquote></li></ol></li><li><p>在布局文件中添加地图容器</p><blockquote><p>注意：在SDK各功能组件使用之前都需要调用“SDKInitializer.initialize(getApplicationContext())”，因此建议在应用创建时初始化SDK引用的Context为全局变量。</p></blockquote><p>新建一个自定义的Application，在其onCreate方法中完成SDK的初始化。示例代码如下： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">//在使用SDK各组件之前初始化context信息，传入ApplicationContext   </span></span><br><span class="line">        SDKInitializer.initialize(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//自4.3.0起，百度地图SDK所有接口均支持百度坐标和国测局坐标，用此方法设置您使用的坐标类型.</span></span><br><span class="line">        <span class="comment">//包括BD09LL和GCJ02两种坐标，默认是BD09LL坐标。</span></span><br><span class="line">        SDKInitializer.setCoordType(CoordType.BD09LL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AndroidManifest.xml</code>文件中声明Application</p><p><img src="https://i.loli.net/2021/06/29/SuHkpAENUzRwOjI.png" alt="图片.png"></p><p>创建地图Activity，管理MapView生命周期</p><p>注意：在项目中使用地图的时候要特别注意合理地管理地图生命周期，这非常重要。</p><p>以下示例代码简述对地图生命周期的管理： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> MapView mMapView = <span class="keyword">null</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);    </span><br><span class="line">        setContentView(R.layout.activity_main);  </span><br><span class="line">        <span class="comment">//获取地图控件引用  </span></span><br><span class="line">        mMapView = (MapView) findViewById(R.id.bmapView);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">super</span>.onResume();  </span><br><span class="line">       <span class="comment">//在activity执行onResume时执行mMapView. onResume ()，实现地图生命周期管理  </span></span><br><span class="line">       mMapView.onResume();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">super</span>.onPause();  </span><br><span class="line">      <span class="comment">//在activity执行onPause时执行mMapView. onPause ()，实现地图生命周期管理  </span></span><br><span class="line">      mMapView.onPause();  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">super</span>.onDestroy();  </span><br><span class="line">      <span class="comment">//在activity执行onDestroy时执行mMapView.onDestroy()，实现地图生命周期管理  </span></span><br><span class="line">      mMapView.onDestroy();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上工作即可在应用中显示地图。</p></li></ol><h1 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="*开发注意事项"></a>*开发注意事项</h1><h2 id="开发包系统兼容性"><a href="#开发包系统兼容性" class="headerlink" title="开发包系统兼容性"></a>开发包系统兼容性</h2><ol><li>支持5种CPU架构：armeabi、armeabi-v7a、arm64-v8a、x86、x86_64</li><li>支持Android v4.0 已上系统</li></ol><h2 id="开发包形式说明"><a href="#开发包形式说明" class="headerlink" title="开发包形式说明"></a>开发包形式说明</h2><ol><li><p>自v3.6起，原内置覆盖物相关类代码开源（OverlayManager/PoiOverlay/TransitRouteOverlay/WalkingRouteOverlay/BusLineOverlay），源码可在BaiduMapsApiDemo和BaiduMapsApiASDemo工程中overlayutil包下找到。 </p></li><li><p>地图SDK采用一体化包进行依赖，旧包无法与新包同时混用，请将之前所有旧包（so和jar）全部替换为新包。 </p><table><thead><tr><th align="center">jar</th><th align="center">场景</th><th align="center">so</th><th align="center">功能包内容</th></tr></thead><tbody><tr><td align="center">BaiduLBS_Android.jar</td><td align="center">基础地图</td><td align="center">libBaiduMapSDK_base_vX_X_X.so<br/>libBaiduMapSDK_map_vX_X_X.so<br/>liblocSDKXX.so</td><td align="center">基础地图、室内地图、个性化地图、检索、云检索、计算工具、路线规划、定位等，可结合自身需求自定义组合下载</td></tr><tr><td align="center">BaiduLBS_Android.jar</td><td align="center">步骑行导航<br/><br/>（包含基础地图）</td><td align="center">ibBaiduMapSDK_base_vX_X_X.so<br/>libBaiduMapSDK_map_for_bikenavi_vX_X_X.so<br/>libBaiduMapSDK_bikenavi_vX_X_X.so<br/>liblocSDKXX.so</td><td align="center">普通自行车骑行导航（v4.2.0起）、电动车骑行导航（v4.4.0起）、步行AR导航（v4.4.0起），基础地图全部功能</td></tr></tbody></table></li></ol><h2 id="支持HTTPS"><a href="#支持HTTPS" class="headerlink" title="支持HTTPS"></a>支持HTTPS</h2><p><strong>地图SDK自v4.5.0起支持HTTPS协议</strong>，开发者可以通过setHttpsEnable(boolean isEnable);控制是否使用https，<strong>V5.3.2版本之前版本默认使用http协议；V5.3.2版本之后（包含）默认使用https协议</strong>。<br>如果使用默认的http协议，由于Android P（包含更高版本）系统禁止使用所有未加密的连接，所以在使用检索功能（poi检索，路线规划，行政区域检索，地理编码，逆地理编码）会返回error.SEARCH_SERVER_INTERNAL_ERROR。并有如下异常信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">W/System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted</span><br></pre></td></tr></table></figure><p><strong>针对该问题有以下三种解决方案如下：</strong></p><ol><li><p>初始化时改用https请求（建议）；</p></li><li><p>targetSdkVersion 降到27以下;</p></li><li><p>按如下方式更改网络安全配置</p></li><li><p>在res文件夹下创建一个xml文件夹，然后创建一个network_security_config.xml文件，文件内容如下： </p></li></ol><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;network-security-config&gt;</span><br><span class="line">  &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/network-security-config&gt;</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>在AndroidManifest.xml文件下的application标签增加以下属性：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">...</span><br><span class="line">  android:networkSecurityConfig=&quot;@xml/network_security_config&quot;</span><br><span class="line">...</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：使用https，会存在加密、解密的过程，可能会影响效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的算法设计策略</title>
      <link href="/2021/06/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/"/>
      <url>/2021/06/23/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><p><strong>分治法</strong> 的思想是将一个难以直接解决的大问题，分割成k个规模较小的子问题，这些子问题相互独立，且与原问题相同，然后逐个击破，分而治之。</p><p><strong>分治法</strong>常常与递归结合使用：通过反复应用分治，可以使子问题与原问题类型一致而规模不断缩小，最终使子问题缩小到很容易求出其解，由此自然导致递归算法。</p><p>根据分治法的分割原则，应把原问题分割成多少个子问题才比较适宜?每个子问题是否规模相同或怎样才为适当? 问题很难给与肯定的回答。但人们从大量实践中发现，在使用分治法时，最好均匀划分，且在很多问题中可以取k=2。这种使子问题规模大致相等的做法源自一种平衡子问题的思想，几乎总是比使子问题规模不等的做法好。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划法与分治法类似，基本思想也是将原问题分解成若干个子问题。与分治法不同的是，分解出的子问题往往不是相互独立的。这种情况下若用分治法会对一问题进行多次求解，这显然是不必要的。动态规划法在求解过程中把所有已解决的子问题的答案保存起来，从而避免对子问题重复求解。</p><p>动态规划常用于解决最优化问题。对一个最优化问题可否应用动态规划法，取决于该问题是否具有如下两个性质:</p><h2 id="最优子结构性质"><a href="#最优子结构性质" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h2><p>当问题的最优解包含其子问题的最优解时，称该问题具有最优子结构性质。要证明原问题具有最优子结构性质，通常采用反证法。假设由问题的最优解导出的子问题的解不是最优的,然后再设法说明在该假设下可构造出比原问题的最优解更好的解，从而导致矛盾。</p><h2 id="子问题重叠性质"><a href="#子问题重叠性质" class="headerlink" title="子问题重叠性质"></a>子问题重叠性质</h2><p>子问题重叠性质是指由原问题分解出的子问题不是相互独立的，存在重叠现象。</p><p>用动态规划法解题过程中，应当先找出最优解的结构特征，即原问题的最优解与其子问题的最优解的关联。</p><p>然后有如下两种程序设计方法:</p><h3 id="自底向上递归法"><a href="#自底向上递归法" class="headerlink" title="自底向上递归法"></a>自底向上递归法</h3><p>利用问题的最优子结构性质,以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。</p><h3 id="自顶向下递归法-即备忘录法"><a href="#自顶向下递归法-即备忘录法" class="headerlink" title="自顶向下递归法(即备忘录法)"></a>自顶向下递归法(即备忘录法)</h3><p>利用问题的最优子结构性质，与直接递归法相同的控制结构自顶向下地进行递归求解。初始时在表格中为每个子问题存入一个标识解。在求解过程中，对每个待求子问题，首先查看表格中相应的记录项。若记录项为初始时的标识值，则表示该子问题是初次遇到，此时应利用问题的最优子结构性质进行递归求解，并将结果存入表格,以备以后查看。否则说明该问题已被求解过，直接返回表格中相应的值即可,不必重新计算。</p><p>当一个问题的所有子问题都要求解时，应当用自底向上递归法。当子问题空间中的部分子问题可不必求解时，自底向上递归法会进行多余的计算，此时应采自顶向下递归法。</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>当一个问题具有最优子结构性质时,可用动态规划法求解。但有时会有比动态规划更简单更直接效率更高的算法—贪心法。贪心法总是做出在当前看来最好的选择，也就是说贪心法并不从整体最优考虑,它所做出的选择只是在某种意义上的局部最优选择。虽然贪心法并不能对所有问题都得到整体最优解，但是对许多问题它能产生整体最优解。有些情况下，贪心法虽然不能得到整体最优解，但其最终结果却是最优解的很好的近似。</p><p>贪心法常用于解决最优化问题。对一个最优化问题可否应用贪心法，取决于该问题是否具有如下两个性质:</p><h2 id="贪心选择性质"><a href="#贪心选择性质" class="headerlink" title="贪心选择性质"></a>贪心选择性质</h2><p>贪心选择性质是指原问题总有一个整体最优解可通过当前的局部最优选择,即贪心选择来达到。</p><p>对于一个具体问题，要确定它是否具有贪心选择性质,通常可考察问题的一个整体最优解,并证明可修改这个最优解，使其以贪心选择开始。由此证明该问题总有一个最优解可通过贪心选择得到, 即具有贪心选择性质。</p><h2 id="最优子结构性质-1"><a href="#最优子结构性质-1" class="headerlink" title="最优子结构性质"></a>最优子结构性质</h2><p>这一点与动态规划相同。做出贪心选择后，由于最优子结构性质，原问题简化为规模更小的类似子问题。如果</p><p>将子问题的最优解和之前所做的贪心选择合并，则可得到原问题的一个最优解。</p><p>贪心问题的整体最优解可通过一系列局部的最优选择，即贪心选择来达到。这也是贪心法与动态规划的主要区别。在动态规划中，每一步所做出的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能做出选择。而在贪心法中，仅做出当前状态下的最好选择，即局部最优选择。然后再去解做出这个选择之后产生的相应的子问题。贪心法所做出的贪心选择可以依赖于以往所做过的选择，但绝不依赖于将来所做的选择，也不依赖于子问题的解。正是由于这种差别，动态规划通常以自顶向上的方式解各个子问题，而贪心法通常以自顶向下的方式进行,以迭代的方式做出相继的贪心选择，每做出一 次贪心选择就将所求问题简化为规模更小的子问题。</p><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><p><strong>回溯法</strong>是对问题的解空间树进行深度优先搜索，但是在对每个节点进行DFS之前，要先判断该节点是否有可能包含问题的解。如果肯定不包含,则跳过对以该节点为根的子树的搜索，逐层向其祖先节点回溯。如果有可能包含,则进入该子树，进行DFS。</p><p>回溯法通常的解题步骤如下:</p><ol><li>定义问题的解空间。</li><li>将解空间组织成便于进行DFS的结构，通常采用树或图的形式。</li><li>对解空间进行DFS,并在搜索过程中用剪枝函数避免无效搜索。</li></ol><p>用回溯法解题时并不需要显式地存储整个解空间，而是在DFS过程中动态地产生问题的解空间。在任何时刻，算法只保存从根节点到当前节点的路径。如果解空间树的高度为h,则回溯法的空间复杂度通常为O(h)。</p><h1 id="分支限界"><a href="#分支限界" class="headerlink" title="分支限界"></a>分支限界</h1><p>回溯法是对解空间进行深度优先搜索，事实上任何搜索遍整个解空间的算法均可解决问题。所以采用通用图搜索（树可抽象为特殊的图）的任何实现作为搜索策略均可解决问题，只要做到穷举即可。除了深度优先搜索之外，我们还可采用广度优先搜索，分支限界法则是对解空间进行优先级优先搜索。</p><p><strong>分支限界法</strong>的搜索策略是，在当前节点处，先生成其所有的子节点（分支）并为每个满足约束条件的子节点计算一个函数值（限界），再将满足约束条件的子节点全部加入解空间树的活结点优先队列。然后再从当前的活节点优先队列中选择优先级最大的节点(节点的优先级由其限界函数的值来确定)作为新的当前节点。重复这一过程，直到到达一个叶节点为止。所到达的叶节点就是最优解。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行工具CLI使用指南</title>
      <link href="/2021/06/22/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7CLI%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2021/06/22/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7CLI%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="安装命令行工具（基于Linux）"><a href="#安装命令行工具（基于Linux）" class="headerlink" title="安装命令行工具（基于Linux）"></a>安装命令行工具（基于Linux）</h1><ol><li><p>安装Homebrew</p><p>​    <a href="https://yyaxu.xyz/2021/06/22/Homebrew%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85-%E5%9B%BD%E5%86%85%E5%9C%B0%E5%9D%80/">看这里</a></p></li><li><p>安装 ‘lean-cli’</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. # 安装</span><br><span class="line">2. brew update</span><br><span class="line">3. brew install lean-cli</span><br><span class="line">4. # 帮助、版本</span><br><span class="line">5. lean help</span><br><span class="line">6. lean --version</span><br></pre></td></tr></table></figure></li></ol><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><p>如果你未登录，还需要通过下面的命令登录你的账号。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lean login --region cn-n1</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/23/cAldNKVMY8zsWm9.png" alt="image.png"></p><h2 id="切换账户"><a href="#切换账户" class="headerlink" title="切换账户"></a>切换账户</h2><p>要切换账户，重新执行 <code>lean login</code> 即可</p><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>初始化一个项目，并且关联到已有的云服务应用上。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$lean init</span><br><span class="line">[?] Please select an app:</span><br><span class="line"> 1) AwesomeApp</span><br><span class="line"> 2) Foobar</span><br></pre></td></tr></table></figure><p>选择项目语言/框架</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[?] Please select a language</span><br><span class="line"> 1) Node.js</span><br><span class="line"> 2) Python</span><br><span class="line"> 3) Java</span><br><span class="line"> 4) PHP</span><br><span class="line"> 5) .Net</span><br><span class="line"> 6）Go</span><br><span class="line"> 7) Others</span><br></pre></td></tr></table></figure><p>之后命令行工具会将此项目模板下载到本地，如此即初始化完成</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[INFO] Downloading templates 1.87 KiB / 1.87 KiB [==================] 100.00% 0s</span><br><span class="line">[INFO] Creating project...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="关联已有项目"><a href="#关联已有项目" class="headerlink" title="关联已有项目"></a>关联已有项目</h1><p>如果已经使用其他方法创建好了项目，可以直接在项目目录执行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ lean switch</span><br></pre></td></tr></table></figure><p>将已有项目关联到云服务应用上。</p>]]></content>
      
      
      <categories>
          
          <category> Lean </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Lean </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Homebrew自动安装(国内地址)</title>
      <link href="/2021/06/22/Homebrew%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85-%E5%9B%BD%E5%86%85%E5%9C%B0%E5%9D%80/"/>
      <url>/2021/06/22/Homebrew%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85-%E5%9B%BD%E5%86%85%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="自动脚本（在终端运行即可）"><a href="#自动脚本（在终端运行即可）" class="headerlink" title="自动脚本（在终端运行即可）"></a>自动脚本（在终端运行即可）</h1><h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><h3 id="常规安装脚本（推荐-安全体-几分钟安装完成）"><a href="#常规安装脚本（推荐-安全体-几分钟安装完成）" class="headerlink" title="常规安装脚本（推荐 安全体 几分钟安装完成）"></a>常规安装脚本（推荐 安全体 几分钟安装完成）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="极速安装脚本（精简版-几秒钟完成）"><a href="#极速安装脚本（精简版-几秒钟完成）" class="headerlink" title="极速安装脚本（精简版 几秒钟完成）"></a>极速安装脚本（精简版 几秒钟完成）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; speed</span><br></pre></td></tr></table></figure><h3 id="卸载脚本"><a href="#卸载脚本" class="headerlink" title="卸载脚本"></a>卸载脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;</span><br></pre></td></tr></table></figure><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm Homebrew.sh </span><br><span class="line">wget https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh </span><br><span class="line">bash Homebrew.sh</span><br></pre></td></tr></table></figure><h3 id="卸载脚本-1"><a href="#卸载脚本-1" class="headerlink" title="卸载脚本"></a>卸载脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm HomebrewUninstall.sh</span><br><span class="line">wget https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh</span><br><span class="line">bash HomebrewUninstall.sh</span><br></pre></td></tr></table></figure><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p><a href="https://gitee.com/cunkai/HomebrewCN/blob/master/error.md">去这里看看</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FileZilla 使用</title>
      <link href="/2021/06/16/FileZilla-%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/06/16/FileZilla-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.filezilla.cn/download">FileZilla</a>  是一种快速、可信赖的FTP客户端以及服务器端开放源代码程式，具有多种特色、直觉的接口。 可控性、有条理的界面和管理多站点的简化方式使得Filezilla客户端版成为一个方便高效的FTP客户端工具。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ol><li><p>一个能够访问的FTP站点。</p></li><li><p>有FTP的IP，用户名,密码，端口号信息。</p></li></ol><h1 id="方法-步骤"><a href="#方法-步骤" class="headerlink" title="方法/步骤"></a>方法/步骤</h1><ol><li><p>打开FileZilla 。</p><p>在右上角点击小服务器图标。新建站点<br><img src="https://i.loli.net/2021/06/17/Z2dT9Aso5Wi4lBc.png" alt="1.jpg"></p></li><li><p>点击左侧  新建站点   。输入IP，端口号（默认不用输入)，</p><p>登录类型中选择正常（如果FTP需要用户名和密码）</p><p>并且输入IP，然后点击链接。</p><p><img src="https://i.loli.net/2021/06/17/YcvBlNIMFP3J6mn.png" alt="2.jpg"></p></li><li><p>如果连接上了。那么就可以往FTP中传文件了。</p><p>一般来说，本地要有一个专门的文件夹和ftp中的网站或是资料对应。</p><p>比如我在本地新建一个E:\命名\</p><p>这个文件夹用来专门和虚机上的数据进行同步等。</p><p><img src="https://i.loli.net/2021/06/17/uRemDsPG16ob4ET.png" alt="3.jpg"></p></li><li><p>如果我有较多的文件，而且，我想指定先上传哪一个之后在自动上传哪一个。</p><p>可以选择文件（夹）后，右击—&gt;添加到处理队列。<br><img src="https://i.loli.net/2021/06/17/T3Xf9bDMKR4AuQr.jpg" alt="4.jpg"></p></li><li><p>然后，在最下面的队列中。给每个文件（夹)指定优先级。然后就会按照优先级先上传和后上传了</p><p><img src="https://i.loli.net/2021/06/17/cOkTSrdZGRalFf9.jpg" alt="5.jpg"></p></li><li><p>如果现在在上传后执行关机或是其他动作。</p><p>可以再下面的队列空白处。</p><p>右击—-&gt;队里完成后执行动作。</p><p><img src="https://i.loli.net/2021/06/17/a8wz6fOiFIMegZV.jpg" alt="6.jpg"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github 搭建博客</title>
      <link href="/2021/06/16/Hexo-Github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/06/16/Hexo-Github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的博客是搭建在虚拟机上的，但是最近硬盘出问题，所以想迁到本地主机上，顺手记录一下搭建过程好了，适用于小白~</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Github是什么？"><a href="#Github是什么？" class="headerlink" title="Github是什么？"></a>Github是什么？</h3><ul><li><a href="https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages">What is Github? - Github Help</a></li></ul><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p><h3 id="Hexo是什么？"><a href="#Hexo是什么？" class="headerlink" title="Hexo是什么？"></a>Hexo是什么？</h3><p>官网:  <a href="https://link.zhihu.com/?target=https://hexo.io/zh-cn/">hexo.io</a></p><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p><h3 id="Hexo-Github-文章发布原理"><a href="#Hexo-Github-文章发布原理" class="headerlink" title="Hexo + Github 文章发布原理"></a>Hexo + Github 文章发布原理</h3><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。</p><h3 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>免费；静态、轻量快速；按需定制；托管在Github，安全省心；迁移方便……</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>发文不方便，依赖于固定的本地环境；比较适用于个人博客；Github在国内访问速度不快。</p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>使用Git Bash进行操作（支持Win）</li><li>文中的“用户名”和“邮箱”替换为自己的Github账户名和绑定的邮箱</li></ol><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。</p><ul><li>Node.js：<a href="https://link.zhihu.com/?target=https://nodejs.org/zh-cn">nodejs.org/zh-cn</a></li><li>Git：<a href="https://link.zhihu.com/?target=https://git-scm.com/downloads">git-scm.com/downloads</a></li></ul><h4 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h4><blockquote><ol><li><p>解压下载的压缩包</p><p>​    <code>tar -xvf node-版本号.tar.xz</code></p></li><li><p>设置软链接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s  【压缩包所在路径】/node/bin/node /usr/bin/node  </span><br><span class="line"></span><br><span class="line">ln -s  【压缩包所在路径】/node/bin/npm /usr/bin/npm</span><br></pre></td></tr></table></figure></li><li><p>查看版本号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u@ubuntu:~/blog/hexo$ node -v</span><br><span class="line">v16.3.0</span><br><span class="line">u@ubuntu:~/blog/hexo$ npm -v</span><br><span class="line">7.16.0</span><br></pre></td></tr></table></figure></li></ol></blockquote><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>输入命令： <code>sudo apt-get install git</code></p><p>查看版本号</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u@ubuntu:~/blog/hexo$ git --version</span><br><span class="line">git version 2.25.1</span><br></pre></td></tr></table></figure><h2 id="连接Github"><a href="#连接Github" class="headerlink" title="连接Github"></a>连接Github</h2><p>为了能将个人博客服务器上的博客数据推送到 GitHub，使数据永久保存，我们需要把博客服务器的 SSH keys 信息在 GitHub 上添加信任。</p><p>右键 -&gt; Git Bash Here,<strong>设置用户名和邮箱</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Github 用户名&quot;</span><br><span class="line">git config --glabal user.email &quot;Github 邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>创建 SSH 密钥</strong></p><p>输入 <code>ssh-keygen -t rsa -C &quot;Github 邮箱&quot;</code>  一路回车。<br><img src="https://i.loli.net/2021/06/17/ovFjlOCDKnwd72L.png" alt="1.png"></p><p>这样即生成成功</p><p><strong>添加密钥</strong></p><p>命令行输入 <code>cat /User/用户名/.ssh/id_rsa.pub</code> ，复制内容</p><p>登录<code>Github</code>，进入<code>settings</code> 页，选择左栏中的<code>SSH and GPG keys</code>， 点击 <code>New SSH key</code></p><p>title可取任意，粘贴刚才复制的内容到key栏中，点击Add SSH key 完成添加。</p><p><img src="https://i.loli.net/2021/06/17/ADyWlnJhOg6ufVb.png" alt="2.png"></p><p><strong>验证是否免密成功</strong></p><p>在 <code>Git Bash</code> 中，输入 <code>SSH -T git@github.com</code> 出现“Are you sure……”，输入y回车确认。</p><p>如下图所示即连接成功</p><p><img src="https://i.loli.net/2021/06/17/A8NkmC6pHcwdifb.png" alt="3.png"></p><h2 id="创建Github-Pages仓库"><a href="#创建Github-Pages仓库" class="headerlink" title="创建Github Pages仓库"></a>创建Github Pages仓库</h2><ol><li>Github 主页右上角 + 号 -&gt; New repository：</li></ol><ul><li>Repository name：输入 <code>用户名.github.io</code></li><li>勾选 “Initialize this repository with a README”</li><li>Description 选填</li></ul><p>完成填写后点击 Create repository创建。</p><p><img src="https://i.loli.net/2021/06/17/F6HPe7GqomdO3Bc.png" alt="4.png"></p><ol start="2"><li><p>开启Github Pages</p><p>在仓库内点击Setting</p><p><img src="https://i.loli.net/2021/06/17/EgWV15QYyLo8z6l.png" alt="5.png"></p></li></ol><p>​        选择theme</p><p>​    <img src="https://i.loli.net/2021/06/17/6Wp5zwX1ODKgnSZ.png" alt="6.png"></p><p>​        浏览器访问 <code>用户名.github.io</code>,如图所示<br>​    <img src="https://i.loli.net/2021/06/17/c7BoEXKWseJpwLO.png" alt="7.png"></p><h2 id="本地安装Hexo博客"><a href="#本地安装Hexo博客" class="headerlink" title="本地安装Hexo博客"></a>本地安装Hexo博客</h2><p>1.在任意位置新建blog文件夹，命令行切换到blog文件夹下，并运行如下命令</p><blockquote><ol><li><p>为了提高下载速度，修改npm的资源镜像链接为淘宝网</p><p>npm config set registry <a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a></p></li><li><p>以下是安装hexo</p><p>npm install hexo-cli -g</p></li><li><p>设置软连接</p></li></ol><p>  sudo ln -s ~/node_modules/hexo/bin/hexo   /usr/bin/hexo</p><ol start="5"><li>初始化博客文件夹blog</li></ol><p>  hexo init blog</p><ol start="6"><li>把目录切换到blog</li></ol><p>  cd blog</p><ol start="7"><li>安装必要插件</li></ol><p>  cnpm install</p><ol start="8"><li>生成资源</li></ol><p>  hexo g</p><ol start="9"><li>开启本地浏览服务</li></ol><p>  hexo s</p></blockquote><p>初始化成功如下：<br><img src="https://i.loli.net/2021/06/17/dBr2YUhiMgwbXS5.png" alt="8.png"></p><p>​        执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。</p><p>​        hexo s是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容。</p><p><img src="https://i.loli.net/2021/06/17/ElyHcx5ROqLskDz.png" alt="9.png"></p><ul><li>tips： 如果本地浏览无法加载，可能是端口被占用。 <code>Ctrl + C</code>  关闭服务器， 执行 <code>hexo server -p 5000</code> 更改端口号后重启服务器。</li></ul><p>​    Hexo 博客文件夹目录结构如下：</p><p><img src="https://i.loli.net/2021/06/17/4iKwYcHuMUJP6vW.png" alt="10.png"></p><h2 id="部署Hexo到Github"><a href="#部署Hexo到Github" class="headerlink" title="部署Hexo到Github"></a>部署Hexo到Github</h2><p>使用邮箱注册  <a href="https://link.zhihu.com/?target=https://github.com/">GitHub</a> 账户，选择免费账户（Free），并完成邮件验证。有的话可忽略此步</p><p><code>hexo s</code>  本地测试成功后，就可以上传到 Github 上进行部署了，使其能够自由访问。</p><ol><li><p><strong>安装hexo-deployer-git</strong>:</p><p> <code>npm install hexo-deployer-git --save</code> </p></li><li><p><strong>修改 <strong><code> _config.yml</code>  文件末尾的</strong># Deployment</strong>部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:用户名/用户名.github.io.git//这里是GitHub上创建的博客的ssh地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>安装依赖</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="4"><li><p>执行命令部署文件到 GitHub</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean//清除缓存文件</span><br><span class="line">hexo generate//生成静态文件</span><br><span class="line">hexo deploy//部署到GitHub</span><br></pre></td></tr></table></figure></li></ol><p>部署成功后在GitHub创建的repository上显示如下：</p><p><img src="https://i.loli.net/2021/06/17/7APqeBUctYGE3oR.png" alt="11.png"></p><h2 id="绑定域名（可选）"><a href="#绑定域名（可选）" class="headerlink" title="绑定域名（可选）"></a>绑定域名（可选）</h2><p>搭建完成使用的是GitHub的子域名（用户名.github.io），我们可以绑定自己的域名以替换GitHub域名。</p><p>我在 <a href="https://www.aliyun.com/activity?spm=5176.8048432.J_8058803260.3.1db62cf8aJjhLH">阿里云</a> 进行注册，便宜好用</p><p><img src="https://i.loli.net/2021/06/17/lKOdgkfQPI4haWC.png" alt="12.png"></p><h3 id="域名注册和解析"><a href="#域名注册和解析" class="headerlink" title="域名注册和解析"></a>域名注册和解析</h3><ul><li>域名注册和解析</li></ul><p>在 DNS 设置部分，删除原有记录，然后添加 CNAME 记录将www域名指向<code>用户名.github.io</code> </p><p><img src="https://i.loli.net/2021/06/17/BvMEWTDYruUeCy6.png" alt="13.png"></p><h3 id="绑定域名到-Hexo-博客"><a href="#绑定域名到-Hexo-博客" class="headerlink" title="绑定域名到 Hexo 博客"></a>绑定域名到 Hexo 博客</h3><p>方法一：进入blog博客文件夹的 source 目录，打开记事本，输入注册的域名，如 <code>http://www.example.com</code> ，保存名称为 <strong>CNAME</strong></p><p>清楚缓存等文件并重新发布：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean#  清楚缓存文件等</span><br><span class="line">hexo g#  生成静态页面</span><br><span class="line">hexo d#  启动本地预览</span><br></pre></td></tr></table></figure><p>方法二：在 GitHub 仓库页面点击新建</p><p><img src="https://i.loli.net/2021/06/17/6yKANrM2mvoSEhC.png" alt="14.png"></p><p>在GitHub.io仓库点击setting，将域名填入Constom domain</p><p><img src="https://i.loli.net/2021/06/17/DShwQkHL7T8Kl3u.png" alt="15.png"></p><p>再访问域名时即成功</p><p><img src="https://i.loli.net/2021/06/17/dWp2JBNcC5gS9Xl.png" alt="16.png"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搭建博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>busybox v1.30.1 built-int shell(sah)</title>
      <link href="/2021/06/16/busybox-v1-30-1-built-int-shell-sah/"/>
      <url>/2021/06/16/busybox-v1-30-1-built-int-shell-sah/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>因为虚拟机一直放在移动硬盘上，最近接触不稳定总是会突然掉线，每次掉线后再开机就会卡在启动页面，且一直黑屏，还显示</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BusyBox v1.30.1 (Ubuntu 1:1.30.1-4ubuntu6.3) Built-in shell (ash)</span><br><span class="line"></span><br><span class="line">Enter &#x27;help&#x27; for a list of built-in commands</span><br></pre></td></tr></table></figure><p>根据提示输入 <code>help</code> 之后提示：<br><img src="https://i.loli.net/2021/06/17/PabSuTJ1p9GXHCd.png" alt="busy1.png"></p><h1 id="解决方法如下"><a href="#解决方法如下" class="headerlink" title="解决方法如下"></a>解决方法如下</h1><p>1.输入<code>fsck -y /dev/sda5</code> 命令成功执行后，出现<code>FILE SYSTEM WAS MODIFIED</code> 字样</p><ul><li>这里/dev/sda5 是在黑屏前频繁报错的上图有显示</li></ul><p><img src="https://i.loli.net/2021/06/17/TJNSHQrpB9lhLv3.png" alt="busy2.png"></p><p>2.输入<code>exit</code> 显示如下信息即可重启</p><p><img src="https://i.loli.net/2021/06/17/FdO2zLW6DypseIK.png" alt="busy3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA安装</title>
      <link href="/2021/06/07/IDEA%E5%AE%89%E8%A3%85/"/>
      <url>/2021/06/07/IDEA%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>在官网下载<a href="https://www.jetbrains.com/idea/download/#section=windows">IDEA</a></p><p><img src="https://i.loli.net/2021/06/17/WNrzoTvjYLU2VJk.png" alt="1.png"></p><p>我选的是UItimate版本</p><p>IDEA各版本的区别：</p><p>Community：社区版，免费，功能有限制</p><p>UItimate：终极版，收费，功能无限制</p><p>EAP：终极版的免费版，免费，功能无限制，但是每个月需要安装一次</p><h1 id="安装IDEA"><a href="#安装IDEA" class="headerlink" title="安装IDEA"></a>安装IDEA</h1><p>1.双击下载的exe文件，一路默认即可</p><p><img src="https://i.loli.net/2021/06/17/oVk9ciIaZf5KsBC.png" alt="2.png"></p><p>3.安装成功</p><p><img src="https://i.loli.net/2021/06/17/Zcfy8IYRJU3WOzV.png" alt="3.png"></p><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><blockquote><p>Appearance &amp; Behavior(外观和行为)</p></blockquote><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p><img src="https://i.loli.net/2021/06/17/hLCFwxeEgIrZW3D.png" alt="4.png"></p><h2 id="设置窗体及菜单的字体及字体大小（可忽略）"><a href="#设置窗体及菜单的字体及字体大小（可忽略）" class="headerlink" title="设置窗体及菜单的字体及字体大小（可忽略）"></a>设置窗体及菜单的字体及字体大小（可忽略）</h2><p><img src="https://i.loli.net/2021/06/17/BQIgVHbyqZGR1cx.png" alt="5.png"></p><h2 id="设置编辑区主题"><a href="#设置编辑区主题" class="headerlink" title="设置编辑区主题"></a>设置编辑区主题</h2><p><img src="https://i.loli.net/2021/06/17/kx4vSo8LMfFV6Hw.png" alt="6.png"></p><h2 id="通过插件更换主题"><a href="#通过插件更换主题" class="headerlink" title="通过插件更换主题"></a>通过插件更换主题</h2><p><img src="https://i.loli.net/2021/06/17/w9YefUzabAIg7qG.png" alt="7.png"></p><blockquote><p>Editor–&gt;General</p></blockquote><h2 id="通过鼠标滚轮修改字体大小"><a href="#通过鼠标滚轮修改字体大小" class="headerlink" title="通过鼠标滚轮修改字体大小"></a>通过鼠标滚轮修改字体大小</h2><p><code>Ctrl+鼠标滚轮</code>来控制代码字体大小的显示<br><img src="https://i.loli.net/2021/06/17/mkOaQ79K2lTYrqx.png" alt="8.png"></p><h2 id="设置自动导包"><a href="#设置自动导包" class="headerlink" title="设置自动导包"></a>设置自动导包</h2><ul><li>Add unambiguous imports on the fly：自动导入不明确的结构</li><li> Optimize imports on the fly： 自动帮我们优化导入的包</li></ul><p><img src="https://i.loli.net/2021/06/17/8q1ECUVxDHYnQ4m.png" alt="9.png"></p><h2 id="设置行号和方法之间的分隔符"><a href="#设置行号和方法之间的分隔符" class="headerlink" title="设置行号和方法之间的分隔符"></a>设置行号和方法之间的分隔符</h2><p><img src="https://i.loli.net/2021/06/17/rSyPp8fFnHckmXv.png" alt="10.png"></p><p><img src="https://i.loli.net/2021/06/17/9LNRSDBFlMPHJ5w.png" alt="11.png"></p><h2 id="修改类头的注释信息"><a href="#修改类头的注释信息" class="headerlink" title="修改类头的注释信息"></a>修改类头的注释信息</h2><p><img src="https://i.loli.net/2021/06/17/8lImhkUs9xwD4Nv.png" alt="12.png"></p><h2 id="设置版权"><a href="#设置版权" class="headerlink" title="设置版权"></a>设置版权</h2><p><img src="https://i.loli.net/2021/06/17/vcnIBpmZjrzMlkH.png" alt="13.png"></p><h2 id="设置自动编译"><a href="#设置自动编译" class="headerlink" title="设置自动编译"></a>设置自动编译</h2><p><img src="https://i.loli.net/2021/06/17/6fxbr3N5U2ezQS7.png" alt="15.png"></p><h2 id="设置省电模式"><a href="#设置省电模式" class="headerlink" title="设置省电模式"></a>设置省电模式</h2><p>省电模式会关掉代码检查和代码提示功能</p><p><img src="https://i.loli.net/2021/06/17/wailWpXSHuB9n2v.png" alt="16.png"></p>]]></content>
      
      
      <categories>
          
          <category> 软件安装教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android - ProgressDialog</title>
      <link href="/2021/06/02/Android%20-%20ProgressDialog/"/>
      <url>/2021/06/02/Android%20-%20ProgressDialog/</url>
      
        <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>1.直接调用ProgressDialog提供的静态方法show ()显示</p><p>2.创建ProgressDialog，再设置对话框的参数，最后show()出来</p><h1 id="进度对话框"><a href="#进度对话框" class="headerlink" title="进度对话框"></a>进度对话框</h1><p><img src="https://i.loli.net/2021/06/17/fJwIljOMgLmcQFE.png" alt="1.png"></p><h2 id="条形进度条"><a href="#条形进度条" class="headerlink" title="条形进度条"></a>条形进度条</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btn_process.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ProgressDialog pDialog;</span><br><span class="line">                pDialog=<span class="keyword">new</span> ProgressDialog(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                pDialog.setTitle(<span class="string">&quot;进度条框&quot;</span>);</span><br><span class="line">                pDialog.setIcon(R.mipmap.ic_launcher);</span><br><span class="line">                pDialog.setMessage(<span class="string">&quot;正在下载...&quot;</span>);</span><br><span class="line">                pDialog.setProgress(<span class="number">100</span>);</span><br><span class="line">                pDialog.setIndeterminate(<span class="keyword">false</span>);</span><br><span class="line">                pDialog.setCancelable(<span class="keyword">true</span>);</span><br><span class="line">                pDialog.setButton(<span class="string">&quot;取消&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">                        dialog.cancel();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                pDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);</span><br><span class="line">                pDialog.show();</span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">while</span> (iCount &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                                pDialog.setProgress(iCount++);</span><br><span class="line">                                Thread.sleep(<span class="number">80</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            pDialog.cancel();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/17/Ke1G6V2klza79AI.png" alt="2.png"></p><h2 id="圆形进度条"><a href="#圆形进度条" class="headerlink" title="圆形进度条"></a>圆形进度条</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btn_circle.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ProgressDialog pDialog;</span><br><span class="line">                pDialog=<span class="keyword">new</span> ProgressDialog(MainActivity.<span class="keyword">this</span>);</span><br><span class="line">                pDialog.setTitle(<span class="string">&quot;圆形框&quot;</span>);</span><br><span class="line">                pDialog.setIcon(R.mipmap.ic_launcher);</span><br><span class="line">                pDialog.setMessage(<span class="string">&quot;请等待...&quot;</span>);</span><br><span class="line">                pDialog.setProgress(<span class="number">100</span>);</span><br><span class="line">                pDialog.setIndeterminate(<span class="keyword">false</span>);</span><br><span class="line">                pDialog.setCancelable(<span class="keyword">true</span>);</span><br><span class="line">                pDialog.setButton(<span class="string">&quot;取消&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">                        dialog.cancel();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                pDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);</span><br><span class="line">                pDialog.show();</span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">while</span> (iCount &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                                pDialog.setProgress(iCount++);</span><br><span class="line">                                Thread.sleep(<span class="number">80</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            pDialog.cancel();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);s</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/17/9SQFUjKZcL4Iv7t.png" alt="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对话框 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android - AlertDialog</title>
      <link href="/2021/06/02/Android%20-%20AlertDialog/"/>
      <url>/2021/06/02/Android%20-%20AlertDialog/</url>
      
        <content type="html"><![CDATA[<h1 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h1><ul><li>step1：创建AlertDialog.Builder对象；</li><li>step2：调用setIcon()设置图标，setTitile()或setCustomTitle()设置标题；</li><li>step3：设置对话框的内容：setMessage()还有其他方法来制定 现实的内容；</li><li>step4：调用setPositive/Negative/NeturalButton()设置：确定、取消、中立按钮；</li><li>step5：调用create()方法创建这个对象，再调用show()方法将对话显示出来。</li></ul><h1 id="常用对话框"><a href="#常用对话框" class="headerlink" title="常用对话框"></a>常用对话框</h1><p><img src="https://i.loli.net/2021/06/17/RT84yUW1Axm5SOX.png" alt="1.png"></p><h2 id="普通对话框"><a href="#普通对话框" class="headerlink" title="普通对话框"></a>普通对话框</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btn_normal.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        AlertDialog dialog;</span><br><span class="line">        AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">                .setTitle(<span class="string">&quot;普通对话框&quot;</span>)</span><br><span class="line">                .setIcon(R.mipmap.ic_launcher)</span><br><span class="line">                .setMessage(<span class="string">&quot;这是一个普通对话框！&quot;</span>)</span><br><span class="line">                .setPositiveButton(<span class="string">&quot;确定&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                        dialog.dismiss();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .setNegativeButton(<span class="string">&quot;取消&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                         dialog.dismiss();</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">       dialog = builder.create();</span><br><span class="line">       dialog.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/17/WQ8PhmIMNCdxfJb.png" alt="2.png"></p><h2 id="单选对话框"><a href="#单选对话框" class="headerlink" title="单选对话框"></a>单选对话框</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btn_singal.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        AlertDialog dialog;</span><br><span class="line">        AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">              .setTitle(<span class="string">&quot;请选择性别&quot;</span>)</span><br><span class="line">              .setIcon(R.mipmap.ic_launcher)</span><br><span class="line">              .setSingleChoiceItems(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;男&quot;</span>, <span class="string">&quot;女&quot;</span>&#125;, <span class="number">0</span>,</span><br><span class="line">                     <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123; &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                        )</span><br><span class="line">              .setPositiveButton(<span class="string">&quot;确定&quot;</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                       dialog.dismiss();</span><br><span class="line">                   &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">        dialog = builder.create();</span><br><span class="line">        dialog.show();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/17/IqE5oKHdRnJbphz.png" alt="3.png"></p><h2 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btn_more.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        AlertDialog dialog;</span><br><span class="line">        AlertDialog.Builder builder = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">              .setTitle(<span class="string">&quot;请添加兴趣爱好&quot;</span>)</span><br><span class="line">              .setIcon(R.mipmap.ic_launcher)</span><br><span class="line">              .setMultiChoiceItems(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;旅游&quot;</span>, <span class="string">&quot;美食&quot;</span>, <span class="string">&quot;汽车&quot;</span>, <span class="string">&quot;科技&quot;</span>, <span class="string">&quot;宠物&quot;</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">              .setPositiveButton(<span class="string">&quot;确定&quot;</span>,<span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">                      dialog.dismiss();</span><br><span class="line">                   &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">       dialog = builder.create();</span><br><span class="line">       dialog.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/17/myEY9xfU5nDSqvX.png" alt="4.png"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对话框 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主机与虚拟机之间的文件拖拽</title>
      <link href="/2021/06/01/%E4%B8%BB%E6%9C%BA%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E6%8B%96%E6%8B%BD/"/>
      <url>/2021/06/01/%E4%B8%BB%E6%9C%BA%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%96%87%E4%BB%B6%E6%8B%96%E6%8B%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>每次传文件都要打开 filezilla 太麻烦了，所以想一劳永逸，实现虚拟机和主机之间的文件拖拽，但是安装时显示灰色字体，哦豁，百度了呗，记录一下</p><p><img src="https://i.loli.net/2021/06/17/45Gflbk2yRgQhOz.png" alt="2.png"></p><h1 id="安装VMware-Tools"><a href="#安装VMware-Tools" class="headerlink" title="安装VMware Tools"></a>安装VMware Tools</h1><p>1.先把文件拷贝到download路径下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp VMwareTools-10.3.23-17030940.tar.gz ~/Download</span><br></pre></td></tr></table></figure><p>2.解压缩</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxf VMwareTools-10.3.23-17030940.tar.gz</span><br></pre></td></tr></table></figure><p>3.进到解压后的文件夹里</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd vmware-tools-distrib/</span><br></pre></td></tr></table></figure><p>4.执行安装文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ./vmware-install.pl</span><br></pre></td></tr></table></figure><h1 id="安装字体为灰色"><a href="#安装字体为灰色" class="headerlink" title="安装字体为灰色"></a>安装字体为灰色</h1><p>1.关闭虚拟机，点击菜单栏‘虚拟机’，打开设置<br><img src="https://i.loli.net/2021/06/17/6LFBmnUMSc2EH58.png" alt="6.png"></p><p>2.打开虚拟机设置界面如下。在下面的界面里先把软盘驱动器删除（现在也没有人用软盘，删了就不用设置这一项了），然后选中CD/DVD光盘，右边“连接”下面设置“自动检测”</p><p><img src="https://i.loli.net/2021/06/17/kY1aGHVg2StwvdF.png" alt="3.png"></p><p>3.把原来的也设置为’自动检测’</p><p><img src="https://i.loli.net/2021/06/17/RwGBU3Fkvoehzmg.png" alt="4.png"></p><p>4.再打开虚拟机时，灰色字体就可以点亮了，可以正常安装</p><p><img src="https://i.loli.net/2021/06/17/ud5nZoxGRqKXbHz.png" alt="5.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware Tools文件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android——实现简易QQ登录界面</title>
      <link href="/2021/06/01/Android%20-%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93QQ%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2/"/>
      <url>/2021/06/01/Android%20-%20%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93QQ%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><p>QQ是日常生活最常用的软件之一，包括了登陆界面和登陆后的聊天界面、好友列表以及空间动态界面等。登陆界面的制作极为简单，主要考察对布局的使用。现在任何APP开发的首要工作都是实现登陆界面，所以熟悉QQ界面的实现对此后开发有重要作用。</p><h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul><li>操作系统：Windows 10系统</li><li>开发工具： JDK11 Android4.2</li><li>API版本：Android API30</li></ul><h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="头像设计"><a href="#头像设计" class="headerlink" title="头像设计"></a>头像设计</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/iv&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;70dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/head&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="账号输入框"><a href="#账号输入框" class="headerlink" title="账号输入框"></a>账号输入框</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/number_11&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@+id/iv&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;15dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/shape&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_number&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;账号:&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_number&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_toRightOf</span>=<span class="string">&quot;@+id/tv_number&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:inputType</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="密码输入框"><a href="#密码输入框" class="headerlink" title="密码输入框"></a>密码输入框</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/password_11&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@+id/number_11&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/shape&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;密码:&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_toRightOf</span>=<span class="string">&quot;@+id/tv_password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="登陆按键"><a href="#登陆按键" class="headerlink" title="登陆按键"></a>登陆按键</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/password_11&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@+id/number_11&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_centerHorizontal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@drawable/shape&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;horizontal&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/tv_password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;密码:&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textColor</span>=<span class="string">&quot;#000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textSize</span>=<span class="string">&quot;20sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_toRightOf</span>=<span class="string">&quot;@+id/tv_password&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">&quot;@null&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:inputType</span>=<span class="string">&quot;textPassword&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;10dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="按键监听事件"><a href="#按键监听事件" class="headerlink" title="按键监听事件"></a>按键监听事件</h2><p>在MainActivity里声明btn的变量，并绑定登陆按键。</p><p>在setOnClickListener按键监听事件，在监听事件里声明onClick方法，在里面声明Toast用于提示信息</p><p>number变量获取了账号对话框输入的内容，password变量获取了密码对话框输入的内容</p><p>Toast提示信息显示是否输入账号密码，登陆是否成功</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//单击按钮时，获取账号密码</span></span><br><span class="line">       String number = et_number.getText().toString().trim();</span><br><span class="line">       String password = et_password.getText().toString();</span><br><span class="line">       <span class="keyword">if</span> (TextUtils.isEmpty(number) || TextUtils.isEmpty(password) ) &#123;</span><br><span class="line">           Toast.makeText(getApplicationContext(), <span class="string">&quot;账号或密码不能为空 ！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           Toast.makeText(getApplicationContext(), <span class="string">&quot;登陆成功！&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//保存用户信息</span></span><br><span class="line">       <span class="keyword">boolean</span> isSaveSuccess = FileSaveQQ.saveUserInfo(MainActivity.<span class="keyword">this</span>,number,password);</span><br><span class="line">       <span class="keyword">if</span> (isSaveSuccess)&#123;</span><br><span class="line">           Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;保存成功&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;保存失败&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/17/3r5ib6uR2oVekUy.png" alt="QQ_login.png"></p><h1 id="保存QQ密码"><a href="#保存QQ密码" class="headerlink" title="保存QQ密码"></a>保存QQ密码</h1><p>使用文件存储数据是一个独立的模块，因此，创建一个单独的FileSaveQQ工具类，用于实现QQ账号和密码的存储与读取功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSaveQQ</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存账号密码到data.txt文件中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">saveUserInfo</span><span class="params">(Context context, String number, String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileOutputStream fos = context.openFileOutput(<span class="string">&quot;data.txt&quot;</span>,Context.MODE_PRIVATE);</span><br><span class="line">            fos.write((number + <span class="string">&quot;:&quot;</span> + password).getBytes());</span><br><span class="line">            fos.close();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从data.txt文件中获取存储的账号和密码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; <span class="title">getUserInfo</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fis = context.openFileInput(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[fis.available()];</span><br><span class="line">            fis.read(buffer);</span><br><span class="line">            content = <span class="keyword">new</span> String(buffer);</span><br><span class="line">            Map&lt;String,String&gt; userMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            String[] infos = content.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            userMap.put(<span class="string">&quot;number&quot;</span>,infos[<span class="number">0</span>]);</span><br><span class="line">            userMap.put(<span class="string">&quot;password&quot;</span>,infos[<span class="number">1</span>]);</span><br><span class="line">            fis.close();</span><br><span class="line">            <span class="keyword">return</span> userMap;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目效果图"><a href="#项目效果图" class="headerlink" title="项目效果图"></a>项目效果图</h1><h2 id="账号密码为空则显示警告信息"><a href="#账号密码为空则显示警告信息" class="headerlink" title="账号密码为空则显示警告信息"></a>账号密码为空则显示警告信息</h2><p><img src="https://i.loli.net/2021/06/17/S4tTVC8QcYU3wuz.png" alt="账号密码不为空.png"></p><h2 id="保存成功"><a href="#保存成功" class="headerlink" title="保存成功"></a>保存成功</h2><p><img src="https://i.loli.net/2021/06/17/UBa24vpVm7kWIyY.png" alt="保存成功.png"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ登录界面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法-希尔排序算法</title>
      <link href="/2021/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/04/27/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。希尔排序是记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h1 id="希尔排序算法复杂度分析"><a href="#希尔排序算法复杂度分析" class="headerlink" title="希尔排序算法复杂度分析"></a>希尔排序算法复杂度分析</h1><p><strong>希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个字序列，实现跳跃式的移动，使得排序的效率提高。</strong>这的“增量”选取就非常关键了。我们采用的是increase/3+1的方式选取。可究竟选取一个什么样的值，最好呢？目前还是数学难题，不过科学研究表明，当增量序列为dlta[k] = 2^（t-k+1） - 1 ，0 &lt;=k&lt;=t&lt;=log2(n+1)时，可以获得不错的效率，其时间复杂度为O(n^(3/2))，要好于O(n^2)。</p><h1 id="希尔算法实现"><a href="#希尔算法实现" class="headerlink" title="希尔算法实现"></a>希尔算法实现</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序 升序</span></span><br><span class="line"><span class="comment">//根据插入排序的原理，将原来的一个大组，采用间隔的形式分成很多小组，分别进行插入排序</span></span><br><span class="line"><span class="comment">//每一轮结束后 继续分成更小的组进行 插入排序，直到分成的小组长度为1，说明插入排序完毕</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort_Up</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> increase = length;</span><br><span class="line"> <span class="keyword">int</span> i, j, k, temp;</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line">  increase = increase / <span class="number">3</span> + <span class="number">1</span>;<span class="comment">//每个小组的长度，也就是增量</span></span><br><span class="line">  <span class="comment">//每个小组的第0个元素</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; increase; i++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//对每个小组进行插入排序，因为是间隔的形式分组，每个小组的下一个元素为 j+=increse</span></span><br><span class="line">   <span class="keyword">for</span> (j = i + increase; j &lt; length; j += increase)</span><br><span class="line">   &#123;</span><br><span class="line">    temp = arr[j];<span class="comment">//待插入元素</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = j - increase; k &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[k]; k -= increase)</span><br><span class="line">    &#123;</span><br><span class="line">     arr[k + increase] = arr[k];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[k + increase] = temp;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">while</span> (increase&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-命令</title>
      <link href="/2021/04/24/Hexo-%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/24/Hexo-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>npm install hexo -g</td><td>#安装Hexo</td></tr><tr><td>npm update hexo -g</td><td>#升级</td></tr><tr><td>hexo init</td><td>#初始化博客</td></tr></tbody></table><h3 id="命令简写"><a href="#命令简写" class="headerlink" title="命令简写"></a>命令简写</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>hexo n ‘博客名’</td><td>hexo new “我的博客” #新建文章</td></tr><tr><td>hexo g</td><td>生成网页</td></tr><tr><td>hexo d</td><td>部署</td></tr><tr><td>hexo s</td><td>启动本地服务预览</td></tr></tbody></table><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>hexo server                         #Hexo会监视文件变动并自动更新，无须重启服务器</p><p>hexo server -s                     #静态模式</p><p>hexo server -p 5000            #更改端口</p><p>hexo server -i 192.168.1.1  #自定义 IP</p><p>hexo clean                          #清除缓存，若是网页正常情况下可以忽略这条命令</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ssh: connect to host github.com port 22: Connection refused</title>
      <link href="/2021/04/24/ssh-connect-to-host-github-com-port-22-Connection-refused/"/>
      <url>/2021/04/24/ssh-connect-to-host-github-com-port-22-Connection-refused/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在配置ssh时有报错,记录下</p><h2 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h2><p>通过 <code>ssh key</code> 解决本地盒服务器连接的问题。</p><p><code>$ cd ~/. ssh #检查本机已存在的ssh密钥</code></p><hr><p>如果提示 <code>No such file or directory</code> 则表示第一次使用git。</p><p>输入：<br><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></p><p>并且连续3次回车，最终会生成一个文件，找到 <code>ssh\id_rsa.pub</code> 文件，打开并复制里面的内容。然后打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><p><img src="https://i.loli.net/2021/06/17/xYhCBVa4vN1zoX9.png" alt="ssh key.png"></p><p>配置完成后输入 <code>ssh -T git@github.com</code> 验证是否配置成功，结果常出现报错如下：</p><p><code>ssh: connect to host github.com Port : 22 Connection refused</code></p><p>解决方法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在终端输入以下命令：</span><br><span class="line"></span><br><span class="line">1. cd ./.ssh</span><br><span class="line">2. sudo touch config</span><br><span class="line">3. sudo gedit config</span><br></pre></td></tr></table></figure><p>在config文件中写下面的信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Host github.com  </span><br><span class="line">2. User xxxxx@xx.com  //注册github的邮箱</span><br><span class="line">3. Hostname ssh.github.com  </span><br><span class="line">4. PreferredAuthentications publickey  </span><br><span class="line">5. IdentityFile ~/.ssh/id_rsa  </span><br><span class="line">6. Port 443</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh key </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树遍历</title>
      <link href="/2021/04/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"/>
      <url>/2021/04/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>想要从事这方面，今天才搞懂二叉树遍历，所以记录一下，温故而知新，可以为师亦嘛。</p><h1 id="遍历解析"><a href="#遍历解析" class="headerlink" title="遍历解析"></a>遍历解析</h1><p>遍历分三种，先序遍历，中序遍历后序遍历。这里的前中后都是针对根节点而言的。</p><p><img src="https://i.loli.net/2021/06/17/OsUGaN9yZd7qPI5.png" alt="tree.png"></p><h2 id="先序遍历："><a href="#先序遍历：" class="headerlink" title="先序遍历："></a>先序遍历：</h2><p>先遍历根结点，然后遍历左子树，最后遍历右子树。</p><blockquote><p>ABDHECFG</p></blockquote><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历:"></a>中序遍历:</h2><p>先遍历左子树，然后遍历根结点，最后遍历右子树。</p><blockquote><p>HDBEAFCG</p></blockquote><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历:"></a>后序遍历:</h2><p>先遍历左子树，然后遍历右子树，最后遍历根节点。</p><blockquote><p>HDEBFGCA</p></blockquote><h1 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h1><h2 id="已知一棵二叉树的前根序序列和中根序序列，构造该二叉树的过程如下："><a href="#已知一棵二叉树的前根序序列和中根序序列，构造该二叉树的过程如下：" class="headerlink" title="已知一棵二叉树的前根序序列和中根序序列，构造该二叉树的过程如下："></a>已知一棵二叉树的前根序序列和中根序序列，构造该二叉树的过程如下：</h2><ol><li>根据前根序序列的第一个元素建立根结点；</li><li>在中根序序列中找到该元素，确定根结点的左右子树的中根序序列；</li><li>在前根序序列中确定左右子树的前根序序列；</li><li>由左子树的前根序序列和中根序序列建立左子树；</li><li>由右子树的前根序序列和中根序序列建立右子树。</li></ol><h2 id="已知一棵二叉树的后根序序列和中根序序列，构造该二叉树的过程如下："><a href="#已知一棵二叉树的后根序序列和中根序序列，构造该二叉树的过程如下：" class="headerlink" title="已知一棵二叉树的后根序序列和中根序序列，构造该二叉树的过程如下："></a>已知一棵二叉树的后根序序列和中根序序列，构造该二叉树的过程如下：</h2><ol><li><p>根据后根序序列的最后一个元素建立根结点；</p></li><li><p>在中根序序列中找到该元素，确定根结点的左右子树的中根序序列；</p></li><li><p>在后根序序列中确定左右子树的后根序序列；</p></li><li><p>由左子树的后根序序列和中根序序列建立左子树；</p></li><li><p>由右子树的后根序序列和中根序序列建立右子树。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sudo命令密码</title>
      <link href="/2021/04/15/sudo%E5%91%BD%E4%BB%A4%E5%AF%86%E7%A0%81/"/>
      <url>/2021/04/15/sudo%E5%91%BD%E4%BB%A4%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于ubuntu，其他的linux应该都一样。</p><p>每次执行sudo密码时都要输密码，真的很烦，在网上找了这样比较有效：</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><blockquote><ol><li><p>切换root用户</p></li><li><p><code>su</code></p></li><li><p>给sudoers文件添加写入权限</p></li><li><p><code>chmod u+w /etc/sudoers</code></p></li><li><p>编辑sudoers文件</p></li><li><p><code>vi /etc/sudoers</code></p></li><li><p>不要忘记去掉加给sudoers的文件写入权限</p></li><li><p>`chmod u-w /etc/sudoers</p></li></ol></blockquote><h1 id="sudoers-文件编辑如下"><a href="#sudoers-文件编辑如下" class="headerlink" title="sudoers 文件编辑如下"></a>sudoers 文件编辑如下</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. # User privilege specification</span><br><span class="line"></span><br><span class="line">2. rootALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line">3. # Members of the admin group may gain root privileges</span><br><span class="line"></span><br><span class="line">4. %admin ALL=(ALL) ALL</span><br><span class="line"></span><br><span class="line">5. # Allow members of group sudo to execute any command</span><br><span class="line"></span><br><span class="line">6. %sudoALL=(ALL:ALL) ALL</span><br><span class="line">   #下面的user是你的用户名 添加这一行就能免密sudo了</span><br><span class="line">   user ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sudo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
